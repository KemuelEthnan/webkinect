<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinect 3D Scanner - Skanect Style</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="depth-to-mesh.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            color: #ecf0f1;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
        }

        .header h1 {
            font-size: 1.5em;
            font-weight: 600;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Left Panel - Depth Camera */
        .depth-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2c3e50;
        }

        .panel-header {
            padding: 15px;
            background: #2c3e50;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
        }

        .depth-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #depthCanvas {
            width: 280px;
            height: 210px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .depth-legend {
            margin-top: 15px;
            font-size: 12px;
            display: flex;
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        /* Center Panel - 3D Viewer */
        .viewer-panel {
            background: #1a1a1a;
            position: relative;
        }

        #viewer {
            width: 100%;
            height: 100%;
        }

        .viewer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
        }

        .viewer-overlay .title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        /* Right Panel - Controls */
        .control-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #2c3e50;
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .info-item {
            margin-bottom: 12px;
            padding: 10px;
            background: #2c3e50;
            border-radius: 6px;
        }

        .info-item label {
            font-size: 11px;
            color: #95a5a6;
            text-transform: uppercase;
            display: block;
            margin-bottom: 5px;
        }

        .info-item .value {
            font-size: 18px;
            font-weight: 700;
            color: #ecf0f1;
        }

        .scan-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
        }

        .scan-status.idle {
            background: #95a5a6;
        }

        .scan-status.scanning {
            background: #f39c12;
            animation: pulse-bg 1s infinite;
        }

        .scan-status.processing {
            background: #3498db;
        }

        .scan-status.ready {
            background: #2ecc71;
        }

        @keyframes pulse-bg {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .slider-control {
            margin-bottom: 15px;
        }

        .slider-control label {
            font-size: 12px;
            color: #95a5a6;
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2c3e50;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üéØ Kinect 3D Scanner - Skanect Style</h1>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </div>

        <!-- Left Panel: Depth Camera View -->
        <div class="depth-panel">
            <div class="panel-header">üì∑ Depth Camera (Real-time)</div>
            <div class="depth-viewer">
                <canvas id="depthCanvas" width="320" height="240"></canvas>
                <div class="depth-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00;"></div>
                        <span>Valid (0.8-2.5m)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff0000;"></div>
                        <span>Invalid</span>
                    </div>
                </div>
                <div style="margin-top: 20px; font-size: 12px; text-align: center; color: #95a5a6;">
                    <div>FPS: <span id="depthFps">0</span></div>
                    <div>Points: <span id="depthPoints">0</span></div>
                </div>
            </div>
        </div>

        <!-- Center Panel: 3D Viewer -->
        <div class="viewer-panel">
            <div id="viewer"></div>
            <div class="viewer-overlay">
                <div class="title">3D Mesh Viewer</div>
                <div style="font-size: 12px; line-height: 1.6;">
                    üñ±Ô∏è Drag to rotate<br>
                    ‚å®Ô∏è Shift+Drag to pan (up/down/left/right)<br>
                    üìú Scroll to zoom<br>
                    <span id="meshInfo">No mesh loaded</span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <!-- Connection -->
            <div class="control-section">
                <h3>üîå Connection</h3>
                <button id="connectBtn" class="btn-primary" onclick="connect()">Connect to Kinect</button>
                <button id="disconnectBtn" class="btn-danger" onclick="disconnect()" disabled>Disconnect</button>
            </div>

            <!-- Scanning Controls -->
            <div class="control-section">
                <h3>üé¨ Scanning</h3>
                <div class="info-item">
                    <label>Status</label>
                    <div class="scan-status idle" id="scanStatus">Idle</div>
                </div>
                <button id="startScanBtn" class="btn-success" onclick="startScan()" disabled>‚ñ∂Ô∏è Start Scan</button>
                <button id="stopScanBtn" class="btn-warning" onclick="stopScan()" disabled>‚è∏Ô∏è Stop Scan</button>
                <button id="generateBtn" class="btn-primary" onclick="generateMesh()" disabled>üî∑ Generate Mesh</button>
                <button id="exportBtn" class="btn-primary" onclick="exportSTL()" disabled>üíæ Export STL</button>
                <button id="clearBtn" class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
            </div>

            <!-- Scan Info -->
            <div class="control-section">
                <h3>üìä Scan Info</h3>
                <div class="info-item">
                    <label>Frames Captured</label>
                    <div class="value" id="frameCount">0</div>
                </div>
                <div class="info-item">
                    <label>Total Points</label>
                    <div class="value" id="totalPoints">0</div>
                </div>
                <div class="info-item">
                    <label>Mesh Vertices</label>
                    <div class="value" id="meshVertices">0</div>
                </div>
                <div class="info-item">
                    <label>Mesh Faces</label>
                    <div class="value" id="meshFaces">0</div>
                </div>
            </div>

            <!-- Settings -->
            <div class="control-section">
                <h3>‚öôÔ∏è Settings</h3>
                <div class="slider-control">
                    <label>
                        <span>Mesh Resolution</span>
                        <span id="resolutionValue">0.05</span>
                    </label>
                    <input type="range" id="resolutionSlider" min="0.01" max="0.15" step="0.01" value="0.05"
                           onchange="updateResolution(this.value)">
                </div>
                <div class="slider-control">
                    <label>
                        <span>Depth Range Min (m)</span>
                        <span id="depthMinValue">0.8</span>
                    </label>
                    <input type="range" id="depthMinSlider" min="0.3" max="2.0" step="0.1" value="0.8"
                           onchange="updateDepthMin(this.value)">
                </div>
                <div class="slider-control">
                    <label>
                        <span>Depth Range Max (m)</span>
                        <span id="depthMaxValue">2.5</span>
                    </label>
                    <input type="range" id="depthMaxSlider" min="1.0" max="8.0" step="0.5" value="2.5"
                           onchange="updateDepthMax(this.value)">
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL VARIABLES ====================
        let socket = null;
        let connected = false;
        let isScanning = false;

        // Three.js scene
        let scene, camera, renderer;
        let currentMesh = null;

        // Depth data
        let depthFrames = [];
        let totalPointsCollected = 0;
        let frameCount = 0;

        // Depth canvas
        const depthCanvas = document.getElementById('depthCanvas');
        const depthCtx = depthCanvas.getContext('2d');

        // Performance tracking
        let lastDepthRenderTime = 0;
        let depthFpsCounter = 0;
        let depthFpsInterval = null;

        // Settings - ADJUSTED untuk Kinect data actual (1.0-1.15m range)
        let meshResolution = 0.05;
        let depthMin = 0.8;  // Changed from 0.5 to 0.8 (closer to actual data)
        let depthMax = 2.5;  // Changed from 4.0 to 2.5 (typical room scanning)

        // Depth-to-Mesh converter
        let depthMeshConverter = null;

        // Real-time point cloud during scanning
        let realtimePointCloud = null;
        let meshFrames = []; // Store frames for real-time mesh generation

        // Camera pan controls
        let cameraPosition = { x: 0, y: 0, z: 2.5 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', function() {
            console.log('üîµ Initializing Kinect 3D Scanner...');
            initViewer();

            // Initialize depth-to-mesh converter
            if (typeof DepthToMeshConverter !== 'undefined') {
                depthMeshConverter = new DepthToMeshConverter();
                console.log('‚úÖ DepthToMeshConverter initialized');
            } else {
                console.warn('‚ö†Ô∏è DepthToMeshConverter not found');
            }

            // Start FPS counter
            depthFpsInterval = setInterval(() => {
                document.getElementById('depthFps').textContent = depthFpsCounter;
                depthFpsCounter = 0;
            }, 1000);

            console.log('‚úÖ Scanner ready!');
        });

        // ==================== THREE.JS VIEWER ====================
        function initViewer() {
            const container = document.getElementById('viewer');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera - FIXED POSITION untuk objek muncul di tengah
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.01,
                100
            );
            camera.position.set(0, 0, 2.5); // Posisi kamera optimal
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid helper
            const gridHelper = new THREE.GridHelper(4, 20, 0x444444, 0x222222);
            gridHelper.position.y = -1;
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(0.5);
            scene.add(axesHelper);

            // Mouse controls - IMPROVED with PAN support
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                isPanning = e.shiftKey; // Shift+drag = pan
                previousMouse = { x: e.clientX, y: e.clientY };
                panStart = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;

                    if (isPanning) {
                        // PAN mode - move camera (Shift+drag)
                        const panSpeed = 0.005;
                        cameraPosition.x -= deltaX * panSpeed;
                        cameraPosition.y += deltaY * panSpeed;

                        camera.position.x = cameraPosition.x;
                        camera.position.y = cameraPosition.y;
                        camera.lookAt(cameraPosition.x, cameraPosition.y, 0);
                    } else if (currentMesh || realtimePointCloud) {
                        // ROTATE mode - rotate mesh (normal drag)
                        rotation.y += deltaX * 0.01;
                        rotation.x += deltaY * 0.01;

                        if (currentMesh) {
                            currentMesh.rotation.y = rotation.y;
                            currentMesh.rotation.x = rotation.x;
                        }
                        if (realtimePointCloud) {
                            realtimePointCloud.rotation.y = rotation.y;
                            realtimePointCloud.rotation.x = rotation.x;
                        }
                    }

                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                cameraPosition.z *= scale;
                camera.position.z = cameraPosition.z;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // Start animation
            animate();

            console.log('‚úÖ 3D Viewer initialized');
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ==================== WEBSOCKET CONNECTION ====================
        function connect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            console.log('üîå Connecting to ws://127.0.0.1:8181...');
            socket = new WebSocket("ws://127.0.0.1:8181");

            socket.onopen = function() {
                console.log('‚úÖ Connected to Kinect server');
                connected = true;
                updateConnectionStatus(true);

                // Request PointCloud mode
                socket.send("PointCloud");
                console.log('üì§ Requested PointCloud mode');
            };

            socket.onclose = function() {
                console.log('‚ùå Disconnected');
                connected = false;
                updateConnectionStatus(false);
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                alert('Cannot connect to Kinect server. Make sure server.exe is running.');
            };

            socket.onmessage = function(event) {
                if (typeof event.data === "string") {
                    try {
                        const data = JSON.parse(event.data);

                        // Process PointCloud data
                        if (data.mode === 'PointCloud' && data.data && Array.isArray(data.data)) {
                            const depthData = {
                                points: data.data,
                                width: data.width || 320,
                                height: data.height || 240
                            };

                            // Always visualize depth (real-time)
                            visualizeDepth(depthData);

                            // If scanning, collect frames
                            if (isScanning) {
                                collectDepthFrame(depthData);
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing data:', e);
                    }
                }
            };
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }

        function updateConnectionStatus(isConnected) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const startScanBtn = document.getElementById('startScanBtn');

            if (isConnected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                startScanBtn.disabled = false;
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                startScanBtn.disabled = true;
            }
        }

        // ==================== DEPTH VISUALIZATION (SKANECT STYLE) ====================
        function visualizeDepth(depthData) {
            // Throttle rendering to 30 FPS for performance
            const now = Date.now();
            if (now - lastDepthRenderTime < 33) return; // 33ms = ~30 FPS
            lastDepthRenderTime = now;

            const { points, width, height } = depthData;
            if (!points || points.length === 0) return;

            // Update FPS counter
            depthFpsCounter++;

            // Update points count
            document.getElementById('depthPoints').textContent = points.length.toLocaleString();

            // Create image data
            const imageData = depthCtx.createImageData(width, height);
            const pixels = imageData.data;

            // Create depth map
            const depthMap = [];
            for (let y = 0; y < height; y++) {
                depthMap[y] = new Array(width).fill(null);
            }

            // Fill depth map from point cloud
            const focalLength = 525.0;
            const centerX = width / 2;
            const centerY = height / 2;

            for (const point of points) {
                const z = Math.abs(point.z);
                if (z <= 0.001) continue;

                // Project to 2D
                const x2d = Math.round((point.x * focalLength / z) + centerX);
                const y2d = Math.round((-point.y * focalLength / z) + centerY);

                if (x2d >= 0 && x2d < width && y2d >= 0 && y2d < height) {
                    depthMap[y2d][x2d] = z;
                }
            }

            // Render with colors (GREEN = valid, RED = invalid, BLACK = no data)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const depth = depthMap[y][x];

                    if (depth === null) {
                        // No data - black
                        pixels[idx] = 20;
                        pixels[idx + 1] = 20;
                        pixels[idx + 2] = 20;
                        pixels[idx + 3] = 255;
                    } else if (depth >= depthMin && depth <= depthMax) {
                        // Valid depth - GREEN (like Skanect!)
                        pixels[idx] = 0;
                        pixels[idx + 1] = 255;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    } else {
                        // Invalid depth - RED (like Skanect!)
                        pixels[idx] = 255;
                        pixels[idx + 1] = 0;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    }
                }
            }

            depthCtx.putImageData(imageData, 0, 0);
        }

        // ==================== SCANNING (MANUAL START/STOP) ====================
        function startScan() {
            console.log('üöÄ Starting scan...');

            isScanning = true;
            depthFrames = [];
            meshFrames = []; // Clear mesh frames for real-time visualization
            totalPointsCollected = 0;
            frameCount = 0;

            // Update UI
            updateScanStatus('scanning', 'Scanning...');
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('stopScanBtn').disabled = false;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true;

            // Clear previous mesh and point cloud
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
                updateMeshInfo(0, 0);
            }
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                realtimePointCloud = null;
            }

            console.log('‚úÖ Scan started - capturing depth frames...');
        }

        function stopScan() {
            console.log('‚è∏Ô∏è Stopping scan...');

            isScanning = false;

            // Update UI
            updateScanStatus('ready', 'Ready to generate');
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('stopScanBtn').disabled = true;
            document.getElementById('generateBtn').disabled = false;

            console.log(`‚úÖ Scan stopped. Captured ${frameCount} frames with ${totalPointsCollected.toLocaleString()} points`);
        }

        function collectDepthFrame(depthData) {
            // Collect frame (limit to prevent memory issues)
            if (depthFrames.length < 150) { // Max 150 frames
                depthFrames.push(depthData);
                frameCount++;
                totalPointsCollected += depthData.points.length;

                // Update UI
                document.getElementById('frameCount').textContent = frameCount;
                document.getElementById('totalPoints').textContent = totalPointsCollected.toLocaleString();

                // REAL-TIME VISUALIZATION - Show point cloud during scanning
                updateRealtimePointCloud(depthData);

                console.log(`üìä Frame ${frameCount} collected: ${depthData.points.length} points`);
            } else {
                console.warn('‚ö†Ô∏è Max frames reached (150), auto-stopping...');
                stopScan();
            }
        }

        // REAL-TIME MESH VISUALIZATION (Like Skanect!)
        function updateRealtimePointCloud(depthData) {
            if (!depthMeshConverter) {
                console.warn('‚ö†Ô∏è DepthToMeshConverter not available');
                return;
            }

            // Store frame for accumulation
            meshFrames.push({
                points: depthData.points,
                width: depthData.width || 320,
                height: depthData.height || 240
            });

            // Keep only last 10 frames for real-time performance
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }

            // Generate mesh from accumulated frames using DepthToMeshConverter
            console.log('üî∑ Generating real-time mesh from', meshFrames.length, 'frames...');
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);

            if (!geometry) {
                console.warn('‚ö†Ô∏è Failed to generate real-time mesh');
                return;
            }

            // Remove old mesh
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                if (realtimePointCloud.geometry) realtimePointCloud.geometry.dispose();
                if (realtimePointCloud.material) realtimePointCloud.material.dispose();
            }

            // Create material with vertex colors
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false,
                shininess: 30
            });

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'realtimeMesh';

            // CENTER THE MESH AT ORIGIN (0, 0, 0) - CRITICAL!
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            if (!box.isEmpty()) {
                const center = new THREE.Vector3();
                box.getCenter(center);

                // Translate geometry to center
                geometry.translate(-center.x, -center.y, -center.z);
            }

            // Add to scene
            realtimePointCloud = mesh;
            scene.add(realtimePointCloud);

            const vertexCount = geometry.attributes.position ? geometry.attributes.position.count : 0;
            console.log(`‚úÖ Real-time mesh updated: ${vertexCount} vertices`);
        }

        // ==================== MESH GENERATION ====================
        function generateMesh() {
            if (depthFrames.length === 0) {
                alert('No frames collected! Start scanning first.');
                return;
            }

            console.log('üî∑ Generating solid mesh from', depthFrames.length, 'frames...');
            updateScanStatus('processing', 'Generating mesh...');

            // Use setTimeout to prevent UI freeze
            setTimeout(() => {
                try {
                    // Merge all points from all frames
                    const allPoints = [];
                    for (const frame of depthFrames) {
                        if (frame.points && Array.isArray(frame.points)) {
                            // Filter points by depth range (Z-axis depth, NOT euclidean!)
                            const filteredPoints = frame.points.filter(p => {
                                const depth = Math.abs(p.z); // Z-axis depth in meters
                                return depth >= depthMin && depth <= depthMax;
                            });
                            allPoints.push(...filteredPoints);
                        }
                    }

                    console.log('üìä Total points to process:', allPoints.toLocaleString());

                    // CHECK: Validate point count
                    if (allPoints.length === 0) {
                        throw new Error('No valid points found! Check depth range settings (currently ' + depthMin + 'm - ' + depthMax + 'm)');
                    }
                    if (allPoints.length < 100) {
                        console.warn('‚ö†Ô∏è Very few points (' + allPoints.length + '). Mesh quality may be poor.');
                        if (!confirm('Only ' + allPoints.length + ' valid points found. Continue mesh generation? (May fail or produce poor quality)')) {
                            updateScanStatus('ready', 'Cancelled');
                            document.getElementById('generateBtn').disabled = false;
                            return;
                        }
                    }

                    // Generate mesh using DepthToMeshConverter
                    if (!depthMeshConverter) {
                        throw new Error('DepthToMeshConverter not initialized');
                    }

                    const geometry = depthMeshConverter.depthToMesh(allPoints, 320, 240);

                    if (!geometry) {
                        throw new Error('Mesh generation failed - not enough valid points or geometry error');
                    }
                    if (!geometry.attributes || !geometry.attributes.position) {
                        throw new Error('Mesh generation failed - invalid geometry (no positions)');
                    }

                    // Create mesh material with vertex colors
                    const material = new THREE.MeshPhongMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        shininess: 30
                    });

                    // Create mesh
                    currentMesh = new THREE.Mesh(geometry, material);

                    // CRITICAL: Center the mesh at origin (0, 0, 0)
                    geometry.computeBoundingBox();
                    const boundingBox = geometry.boundingBox;
                    const center = new THREE.Vector3();
                    boundingBox.getCenter(center);

                    // Translate geometry to center
                    geometry.translate(-center.x, -center.y, -center.z);

                    // Clear realtime point cloud (replace with final mesh)
                    if (realtimePointCloud) {
                        scene.remove(realtimePointCloud);
                        realtimePointCloud = null;
                    }

                    // Add to scene
                    scene.add(currentMesh);

                    // Update UI
                    const vertexCount = geometry.attributes.position.count;
                    const faceCount = geometry.index ? geometry.index.count / 3 : 0;

                    updateMeshInfo(vertexCount, faceCount);
                    updateScanStatus('ready', 'Mesh generated!');

                    document.getElementById('exportBtn').disabled = false;

                    console.log('‚úÖ SOLID MESH generated successfully!');
                    console.log('üìä Vertices:', vertexCount.toLocaleString());
                    console.log('üìä Faces:', Math.floor(faceCount).toLocaleString());
                } catch (error) {
                    console.error('‚ùå Mesh generation error:', error);
                    alert('Failed to generate mesh: ' + error.message);
                    updateScanStatus('ready', 'Error');
                    document.getElementById('generateBtn').disabled = false;
                }
            }, 100);
        }

        // ==================== EXPORT STL ====================
        function exportSTL() {
            if (!currentMesh || !currentMesh.geometry) {
                alert('No mesh to export!');
                return;
            }

            console.log('üíæ Exporting STL...');

            const geometry = currentMesh.geometry;
            let stlContent = 'solid KinectMesh\n';

            const positions = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;

            if (indices) {
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i] * 3;
                    const i2 = indices[i + 1] * 3;
                    const i3 = indices[i + 2] * 3;

                    const v1 = new THREE.Vector3(
                        positions.array[i1],
                        positions.array[i1 + 1],
                        positions.array[i1 + 2]
                    );
                    const v2 = new THREE.Vector3(
                        positions.array[i2],
                        positions.array[i2 + 1],
                        positions.array[i2 + 2]
                    );
                    const v3 = new THREE.Vector3(
                        positions.array[i3],
                        positions.array[i3 + 1],
                        positions.array[i3 + 2]
                    );

                    const normal = new THREE.Vector3()
                        .subVectors(v2, v1)
                        .cross(new THREE.Vector3().subVectors(v3, v1))
                        .normalize();

                    stlContent += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                    stlContent += `    outer loop\n`;
                    stlContent += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stlContent += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stlContent += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stlContent += `    endloop\n`;
                    stlContent += `  endfacet\n`;
                }
            }

            stlContent += 'endsolid KinectMesh\n';

            // Download
            const blob = new Blob([stlContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `kinect_mesh_${Date.now()}.stl`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('‚úÖ STL exported successfully');
        }

        // ==================== CLEAR ====================
        function clearAll() {
            console.log('üóëÔ∏è Clearing all data...');

            isScanning = false;
            depthFrames = [];
            meshFrames = []; // Clear mesh frames
            totalPointsCollected = 0;
            frameCount = 0;

            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                realtimePointCloud = null;
            }

            // Reset UI
            updateScanStatus('idle', 'Idle');
            document.getElementById('startScanBtn').disabled = !connected;
            document.getElementById('stopScanBtn').disabled = true;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true;
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('totalPoints').textContent = '0';
            updateMeshInfo(0, 0);

            console.log('‚úÖ Cleared');
        }

        // ==================== SETTINGS ====================
        function updateResolution(value) {
            meshResolution = parseFloat(value);
            document.getElementById('resolutionValue').textContent = value;
        }

        function updateDepthMin(value) {
            depthMin = parseFloat(value);
            document.getElementById('depthMinValue').textContent = value;
        }

        function updateDepthMax(value) {
            depthMax = parseFloat(value);
            document.getElementById('depthMaxValue').textContent = value;
        }

        // ==================== UI HELPERS ====================
        function updateScanStatus(statusClass, statusText) {
            const statusEl = document.getElementById('scanStatus');
            statusEl.className = 'scan-status ' + statusClass;
            statusEl.textContent = statusText;
        }

        function updateMeshInfo(vertices, faces) {
            document.getElementById('meshVertices').textContent = vertices.toLocaleString();
            document.getElementById('meshFaces').textContent = Math.floor(faces).toLocaleString();

            const meshInfoEl = document.getElementById('meshInfo');
            if (vertices > 0) {
                meshInfoEl.textContent = `${vertices.toLocaleString()} vertices, ${Math.floor(faces).toLocaleString()} faces`;
            } else {
                meshInfoEl.textContent = 'No mesh loaded';
            }
        }
    </script>
</body>
</html>
