<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinect 3D Scanner - Skanect Style</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="depth-to-mesh.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            color: #ecf0f1;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        .header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
        }

        .header h1 {
            font-size: 1.5em;
            font-weight: 600;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e74c3c;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #2ecc71;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Left Panel - Depth Camera */
        .depth-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2c3e50;
        }

        .panel-header {
            padding: 15px;
            background: #2c3e50;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
        }

        .depth-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #depthCanvas {
            width: 280px;
            height: 210px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .depth-legend {
            margin-top: 15px;
            font-size: 12px;
            display: flex;
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        /* Center Panel - 3D Viewer */
        .viewer-panel {
            background: #1a1a1a;
            position: relative;
        }

        #viewer {
            width: 100%;
            height: 100%;
        }

        .viewer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
        }

        .viewer-overlay .title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        /* Right Panel - Controls */
        .control-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #2c3e50;
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }

        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .info-item {
            margin-bottom: 12px;
            padding: 10px;
            background: #2c3e50;
            border-radius: 6px;
        }

        .info-item label {
            font-size: 11px;
            color: #95a5a6;
            text-transform: uppercase;
            display: block;
            margin-bottom: 5px;
        }

        .info-item .value {
            font-size: 18px;
            font-weight: 700;
            color: #ecf0f1;
        }

        .scan-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
        }

        .scan-status.idle {
            background: #95a5a6;
        }

        .scan-status.scanning {
            background: #f39c12;
            animation: pulse-bg 1s infinite;
        }

        .scan-status.processing {
            background: #3498db;
        }

        .scan-status.ready {
            background: #2ecc71;
        }

        @keyframes pulse-bg {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .slider-control {
            margin-bottom: 15px;
        }

        .slider-control label {
            font-size: 12px;
            color: #95a5a6;
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2c3e50;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üéØ Kinect 3D Scanner - Skanect Style</h1>
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </div>

        <!-- Left Panel: Depth Camera View -->
        <div class="depth-panel">
            <div class="panel-header">üì∑ Depth Camera (Real-time)</div>
            <div class="depth-viewer">
                <canvas id="depthCanvas" width="320" height="240"></canvas>
                <div class="depth-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #00ff00;"></div>
                        <span>Valid (0.8-2.5m)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff0000;"></div>
                        <span>Invalid</span>
                    </div>
                </div>
                <div style="margin-top: 20px; font-size: 12px; text-align: center; color: #95a5a6;">
                    <div>FPS: <span id="depthFps">0</span></div>
                    <div>Points: <span id="depthPoints">0</span></div>
                </div>
            </div>
        </div>

        <!-- Center Panel: 3D Viewer -->
        <div class="viewer-panel">
            <div id="viewer"></div>
            <div class="viewer-overlay">
                <div class="title">3D Mesh Viewer</div>
                <div style="font-size: 12px; line-height: 1.6;">
                    üñ±Ô∏è Drag to rotate<br>
                    ‚å®Ô∏è Shift+Drag to pan (up/down/left/right)<br>
                    üìú Scroll to zoom<br>
                    <span id="meshInfo">No mesh loaded</span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Controls -->
        <div class="control-panel">
            <!-- Connection -->
            <div class="control-section">
                <h3>üîå Connection</h3>
                <button id="connectBtn" class="btn-primary" onclick="connect()">Connect to Kinect</button>
                <button id="disconnectBtn" class="btn-danger" onclick="disconnect()" disabled>Disconnect</button>
            </div>

            <!-- Scanning Controls -->
            <div class="control-section">
                <h3>üé¨ Scanning</h3>
                <div class="info-item">
                    <label>Status</label>
                    <div class="scan-status idle" id="scanStatus">Idle</div>
                </div>
                <button id="startScanBtn" class="btn-success" onclick="startScan()" disabled>‚ñ∂Ô∏è Start Scan</button>
                <button id="stopScanBtn" class="btn-warning" onclick="stopScan()" disabled>‚è∏Ô∏è Stop Scan</button>
                <button id="removeBgBtn" class="btn-primary" onclick="removeBackground()" disabled>üéØ Remove Background</button>
                <button id="generateBtn" class="btn-primary" onclick="generateWatertight()" disabled>üíß Generate Watertight</button>
                <button id="exportBtn" class="btn-primary" onclick="exportSTL()" disabled>üíæ Export STL</button>
                <button id="clearBtn" class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
            </div>

            <!-- Scan Info -->
            <div class="control-section">
                <h3>üìä Scan Info</h3>
                <div class="info-item">
                    <label>Frames Captured</label>
                    <div class="value" id="frameCount">0</div>
                </div>
                <div class="info-item">
                    <label>Total Points</label>
                    <div class="value" id="totalPoints">0</div>
                </div>
                <div class="info-item">
                    <label>Mesh Vertices</label>
                    <div class="value" id="meshVertices">0</div>
                </div>
                <div class="info-item">
                    <label>Mesh Faces</label>
                    <div class="value" id="meshFaces">0</div>
                </div>
            </div>

            <!-- Settings -->
            <div class="control-section">
                <h3>‚öôÔ∏è Settings</h3>
                <div class="slider-control">
                    <label>
                        <span>Mesh Resolution</span>
                        <span id="resolutionValue">0.05</span>
                    </label>
                    <input type="range" id="resolutionSlider" min="0.01" max="0.15" step="0.01" value="0.05"
                           onchange="updateResolution(this.value)">
                </div>
                <div class="slider-control">
                    <label>
                        <span>Depth Range Min (m)</span>
                        <span id="depthMinValue">0.8</span>
                    </label>
                    <input type="range" id="depthMinSlider" min="0.3" max="2.0" step="0.1" value="0.8"
                           onchange="updateDepthMin(this.value)">
                </div>
                <div class="slider-control">
                    <label>
                        <span>Depth Range Max (m)</span>
                        <span id="depthMaxValue">2.5</span>
                    </label>
                    <input type="range" id="depthMaxSlider" min="1.0" max="8.0" step="0.5" value="2.5"
                           onchange="updateDepthMax(this.value)">
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL VARIABLES ====================
        let socket = null;
        let connected = false;
        let isScanning = false;

        // Three.js scene
        let scene, camera, renderer;
        let currentMesh = null;

        // Depth data
        let depthFrames = [];
        let totalPointsCollected = 0;
        let frameCount = 0;

        // Depth canvas
        const depthCanvas = document.getElementById('depthCanvas');
        const depthCtx = depthCanvas.getContext('2d');

        // Performance tracking
        let lastDepthRenderTime = 0;
        let depthFpsCounter = 0;
        let depthFpsInterval = null;

        // Settings - ADJUSTED untuk Kinect data actual (1.0-1.15m range)
        let meshResolution = 0.05;
        let depthMin = 0.8;  // Changed from 0.5 to 0.8 (closer to actual data)
        let depthMax = 2.5;  // Changed from 4.0 to 2.5 (typical room scanning)

        // Depth-to-Mesh converter
        let depthMeshConverter = null;

        // Real-time point cloud during scanning
        let realtimePointCloud = null;
        let meshFrames = []; // Store frames for real-time mesh generation

        // Camera pan controls
        let cameraPosition = { x: 0, y: 0, z: 2.5 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };

        // ==================== INITIALIZATION ====================
        window.addEventListener('load', function() {
            console.log('üîµ Initializing Kinect 3D Scanner...');
            initViewer();

            // Initialize depth-to-mesh converter
            if (typeof DepthToMeshConverter !== 'undefined') {
                depthMeshConverter = new DepthToMeshConverter();

                // MONKEY PATCH: Fix hard-coded euclidean distance filtering
                // Original uses: Math.sqrt(x¬≤+y¬≤+z¬≤) with range 0.85-2.5m (WRONG for Z-depth!)
                // Fixed to use: Math.abs(z) with very wide range (user controls via sliders)
                const originalCreateDepthMap = depthMeshConverter.createDepthMap.bind(depthMeshConverter);
                depthMeshConverter.createDepthMap = function(points, width, height) {
                    const depthMap = [];
                    const mapWidth = width || 320;
                    const mapHeight = height || 240;

                    // Initialize grid
                    for (let y = 0; y < mapHeight; y++) {
                        depthMap[y] = [];
                        for (let x = 0; x < mapWidth; x++) {
                            depthMap[y][x] = null;
                        }
                    }

                    // Fill grid with point data - FIXED FILTERING!
                    for (let i = 0; i < points.length; i++) {
                        const p = points[i];

                        // FIX: Use Z-depth only (NOT euclidean distance!)
                        const z = Math.abs(p.z);
                        if (z <= 0 || z < 0.3 || z > 8.0) continue; // Very wide range

                        // Project 3D point to 2D
                        const x2d = Math.round((p.x * this.focalLength / z) + this.centerX);
                        const y2d = Math.round((-p.y * this.focalLength / z) + this.centerY);

                        if (x2d >= 0 && x2d < mapWidth && y2d >= 0 && y2d < mapHeight) {
                            if (!depthMap[y2d][x2d] || depthMap[y2d][x2d].z > z) {
                                depthMap[y2d][x2d] = {
                                    x: p.x, y: p.y, z: z,
                                    r: p.r || 128, g: p.g || 128, b: p.b || 128
                                };
                            }
                        }
                    }

                    return depthMap;
                };

                console.log('‚úÖ DepthToMeshConverter initialized with Z-depth filtering fix');
            } else {
                console.warn('‚ö†Ô∏è DepthToMeshConverter not found');
            }

            // Start FPS counter
            depthFpsInterval = setInterval(() => {
                document.getElementById('depthFps').textContent = depthFpsCounter;
                depthFpsCounter = 0;
            }, 1000);

            console.log('‚úÖ Scanner ready!');
        });

        // ==================== THREE.JS VIEWER ====================
        function initViewer() {
            const container = document.getElementById('viewer');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera - FIXED POSITION untuk objek muncul di tengah
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.01,
                100
            );
            camera.position.set(0, 0, 2.5); // Posisi kamera optimal
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(1, 1, 1);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-1, -1, -1);
            scene.add(directionalLight2);

            // Grid helper
            const gridHelper = new THREE.GridHelper(4, 20, 0x444444, 0x222222);
            gridHelper.position.y = -1;
            scene.add(gridHelper);

            // Axes helper
            const axesHelper = new THREE.AxesHelper(0.5);
            scene.add(axesHelper);

            // Mouse controls - IMPROVED with PAN support
            let isDragging = false;
            let previousMouse = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                isPanning = e.shiftKey; // Shift+drag = pan
                previousMouse = { x: e.clientX, y: e.clientY };
                panStart = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMouse.x;
                    const deltaY = e.clientY - previousMouse.y;

                    if (isPanning) {
                        // PAN mode - move camera (Shift+drag)
                        const panSpeed = 0.005;
                        cameraPosition.x -= deltaX * panSpeed;
                        cameraPosition.y += deltaY * panSpeed;

                        camera.position.x = cameraPosition.x;
                        camera.position.y = cameraPosition.y;
                        camera.lookAt(cameraPosition.x, cameraPosition.y, 0);
                    } else if (currentMesh || realtimePointCloud) {
                        // ROTATE mode - rotate mesh (normal drag)
                        rotation.y += deltaX * 0.01;
                        rotation.x += deltaY * 0.01;

                        if (currentMesh) {
                            currentMesh.rotation.y = rotation.y;
                            currentMesh.rotation.x = rotation.x;
                        }
                        if (realtimePointCloud) {
                            realtimePointCloud.rotation.y = rotation.y;
                            realtimePointCloud.rotation.x = rotation.x;
                        }
                    }

                    previousMouse = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                cameraPosition.z *= scale;
                camera.position.z = cameraPosition.z;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            // Start animation
            animate();

            console.log('‚úÖ 3D Viewer initialized');
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ==================== WEBSOCKET CONNECTION ====================
        function connect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            console.log('üîå Connecting to ws://127.0.0.1:8181...');
            socket = new WebSocket("ws://127.0.0.1:8181");

            socket.onopen = function() {
                console.log('‚úÖ Connected to Kinect server');
                connected = true;
                updateConnectionStatus(true);

                // Request PointCloud mode
                socket.send("PointCloud");
                console.log('üì§ Requested PointCloud mode');
            };

            socket.onclose = function() {
                console.log('‚ùå Disconnected');
                connected = false;
                updateConnectionStatus(false);
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                alert('Cannot connect to Kinect server. Make sure server.exe is running.');
            };

            socket.onmessage = function(event) {
                if (typeof event.data === "string") {
                    try {
                        const data = JSON.parse(event.data);

                        // Process PointCloud data
                        if (data.mode === 'PointCloud' && data.data && Array.isArray(data.data)) {
                            const depthData = {
                                points: data.data,
                                width: data.width || 320,
                                height: data.height || 240
                            };

                            // Always visualize depth (real-time)
                            visualizeDepth(depthData);

                            // If scanning, collect frames
                            if (isScanning) {
                                collectDepthFrame(depthData);
                            }
                        }
                    } catch (e) {
                        console.error('Error parsing data:', e);
                    }
                }
            };
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }

        function updateConnectionStatus(isConnected) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const startScanBtn = document.getElementById('startScanBtn');

            if (isConnected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                startScanBtn.disabled = false;
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                startScanBtn.disabled = true;
            }
        }

        // ==================== DEPTH VISUALIZATION (SKANECT STYLE) ====================
        function visualizeDepth(depthData) {
            // Throttle rendering to 30 FPS for performance
            const now = Date.now();
            if (now - lastDepthRenderTime < 33) return; // 33ms = ~30 FPS
            lastDepthRenderTime = now;

            const { points, width, height } = depthData;
            if (!points || points.length === 0) return;

            // Update FPS counter
            depthFpsCounter++;

            // Update points count
            document.getElementById('depthPoints').textContent = points.length.toLocaleString();

            // Create image data
            const imageData = depthCtx.createImageData(width, height);
            const pixels = imageData.data;

            // Create depth map
            const depthMap = [];
            for (let y = 0; y < height; y++) {
                depthMap[y] = new Array(width).fill(null);
            }

            // Fill depth map from point cloud
            const focalLength = 525.0;
            const centerX = width / 2;
            const centerY = height / 2;

            for (const point of points) {
                const z = Math.abs(point.z);
                if (z <= 0.001) continue;

                // Project to 2D
                const x2d = Math.round((point.x * focalLength / z) + centerX);
                const y2d = Math.round((-point.y * focalLength / z) + centerY);

                if (x2d >= 0 && x2d < width && y2d >= 0 && y2d < height) {
                    depthMap[y2d][x2d] = z;
                }
            }

            // Render with colors (GREEN = valid, RED = invalid, BLACK = no data)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const depth = depthMap[y][x];

                    if (depth === null) {
                        // No data - black
                        pixels[idx] = 20;
                        pixels[idx + 1] = 20;
                        pixels[idx + 2] = 20;
                        pixels[idx + 3] = 255;
                    } else if (depth >= depthMin && depth <= depthMax) {
                        // Valid depth - GREEN (like Skanect!)
                        pixels[idx] = 0;
                        pixels[idx + 1] = 255;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    } else {
                        // Invalid depth - RED (like Skanect!)
                        pixels[idx] = 255;
                        pixels[idx + 1] = 0;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    }
                }
            }

            depthCtx.putImageData(imageData, 0, 0);
        }

        // ==================== SCANNING (MANUAL START/STOP) ====================
        function startScan() {
            console.log('üöÄ Starting scan...');

            isScanning = true;
            depthFrames = [];
            meshFrames = []; // Clear mesh frames for real-time visualization
            totalPointsCollected = 0;
            frameCount = 0;

            // Update UI
            updateScanStatus('scanning', 'Scanning...');
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('stopScanBtn').disabled = false;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true;

            // Clear previous mesh and point cloud
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
                updateMeshInfo(0, 0);
            }
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                realtimePointCloud = null;
            }

            console.log('‚úÖ Scan started - capturing depth frames...');
        }

        function stopScan() {
            console.log('‚è∏Ô∏è Stopping scan...');

            isScanning = false;

            // Update UI
            updateScanStatus('ready', 'Scan complete');
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('stopScanBtn').disabled = true;
            document.getElementById('removeBgBtn').disabled = false;
            document.getElementById('exportBtn').disabled = false; // Enable direct export

            console.log(`‚úÖ Scan stopped. Captured ${frameCount} frames with ${totalPointsCollected.toLocaleString()} points`);
        }

        function collectDepthFrame(depthData) {
            // Collect frame (limit to prevent memory issues)
            if (depthFrames.length < 150) { // Max 150 frames
                depthFrames.push(depthData);
                frameCount++;
                totalPointsCollected += depthData.points.length;

                // Update UI
                document.getElementById('frameCount').textContent = frameCount;
                document.getElementById('totalPoints').textContent = totalPointsCollected.toLocaleString();

                // REAL-TIME VISUALIZATION - Show point cloud during scanning
                updateRealtimePointCloud(depthData);

                console.log(`üìä Frame ${frameCount} collected: ${depthData.points.length} points`);
            } else {
                console.warn('‚ö†Ô∏è Max frames reached (150), auto-stopping...');
                stopScan();
            }
        }

        // REAL-TIME MESH VISUALIZATION (Like Skanect!)
        function updateRealtimePointCloud(depthData) {
            if (!depthMeshConverter) {
                console.warn('‚ö†Ô∏è DepthToMeshConverter not available');
                return;
            }

            // Store frame for accumulation
            meshFrames.push({
                points: depthData.points,
                width: depthData.width || 320,
                height: depthData.height || 240
            });

            // Keep only last 10 frames for real-time performance
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }

            // Generate mesh from accumulated frames using DepthToMeshConverter
            console.log('üî∑ Generating real-time mesh from', meshFrames.length, 'frames...');
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);

            if (!geometry) {
                console.warn('‚ö†Ô∏è Failed to generate real-time mesh');
                return;
            }

            // Remove old mesh
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                if (realtimePointCloud.geometry) realtimePointCloud.geometry.dispose();
                if (realtimePointCloud.material) realtimePointCloud.material.dispose();
            }

            // Create material with vertex colors
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false,
                shininess: 30
            });

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = 'realtimeMesh';

            // CENTER THE MESH AT ORIGIN (0, 0, 0) - CRITICAL!
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            if (!box.isEmpty()) {
                const center = new THREE.Vector3();
                box.getCenter(center);

                // Translate geometry to center
                geometry.translate(-center.x, -center.y, -center.z);
            }

            // Add to scene
            realtimePointCloud = mesh;
            scene.add(realtimePointCloud);

            const vertexCount = geometry.attributes.position ? geometry.attributes.position.count : 0;
            console.log(`‚úÖ Real-time mesh updated: ${vertexCount} vertices`);
        }

        // ==================== BACKGROUND REMOVAL ====================
        function removeBackground() {
            if (!realtimePointCloud || !realtimePointCloud.geometry) {
                alert('No mesh to process! Scan first.');
                return;
            }

            console.log('üéØ Removing background...');
            updateScanStatus('processing', 'Removing background...');

            setTimeout(() => {
                try {
                    const geometry = realtimePointCloud.geometry;
                    const positions = geometry.attributes.position;
                    const colors = geometry.attributes.color;
                    const indices = geometry.index;

                    // STEP 1: Analyze depth distribution to find foreground/background threshold
                    const depths = [];
                    for (let i = 0; i < positions.count; i++) {
                        const z = Math.abs(positions.getZ(i));
                        depths.push(z);
                    }
                    depths.sort((a, b) => a - b);

                    // Find depth clusters using histogram
                    const depthHistogram = new Map();
                    const binSize = 0.1; // 10cm bins
                    for (const d of depths) {
                        const bin = Math.floor(d / binSize) * binSize;
                        depthHistogram.set(bin, (depthHistogram.get(bin) || 0) + 1);
                    }

                    // Find the foreground cluster (closest and largest)
                    let maxCount = 0;
                    let foregroundBin = 0;
                    for (const [bin, count] of depthHistogram.entries()) {
                        if (count > maxCount && bin < 3.0) { // Within 3m
                            maxCount = count;
                            foregroundBin = bin;
                        }
                    }

                    // Set threshold: foreground ¬± 0.5m
                    const minDepth = foregroundBin - 0.3;
                    const maxDepth = foregroundBin + 0.5;

                    console.log('üìä Background removal threshold:', {
                        foregroundDepth: foregroundBin.toFixed(2) + 'm',
                        minDepth: minDepth.toFixed(2) + 'm',
                        maxDepth: maxDepth.toFixed(2) + 'm'
                    });

                    // STEP 2: Filter vertices (keep only foreground)
                    const newPositions = [];
                    const newColors = [];
                    const vertexMap = new Map(); // old index -> new index

                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const z = positions.getZ(i);
                        const depth = Math.abs(z);

                        // Keep only foreground vertices
                        if (depth >= minDepth && depth <= maxDepth) {
                            vertexMap.set(i, newPositions.length / 3);
                            newPositions.push(x, y, z);
                            newColors.push(
                                colors.getX(i),
                                colors.getY(i),
                                colors.getZ(i)
                            );
                        }
                    }

                    if (newPositions.length === 0) {
                        throw new Error('No foreground vertices found!');
                    }

                    // STEP 3: Rebuild indices (only triangles with all vertices in foreground)
                    const newIndices = [];
                    for (let i = 0; i < indices.count; i += 3) {
                        const i1 = indices.getX(i);
                        const i2 = indices.getX(i + 1);
                        const i3 = indices.getX(i + 2);

                        // Check if all 3 vertices are in foreground
                        if (vertexMap.has(i1) && vertexMap.has(i2) && vertexMap.has(i3)) {
                            newIndices.push(
                                vertexMap.get(i1),
                                vertexMap.get(i2),
                                vertexMap.get(i3)
                            );
                        }
                    }

                    // STEP 4: Create new geometry
                    const newGeometry = new THREE.BufferGeometry();
                    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                    newGeometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
                    newGeometry.setIndex(newIndices);
                    newGeometry.computeVertexNormals();
                    newGeometry.computeBoundingBox();

                    // Center the mesh
                    const box = newGeometry.boundingBox;
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    newGeometry.translate(-center.x, -center.y, -center.z);

                    // STEP 5: Replace mesh
                    scene.remove(realtimePointCloud);
                    if (realtimePointCloud.geometry) realtimePointCloud.geometry.dispose();
                    if (realtimePointCloud.material) realtimePointCloud.material.dispose();

                    const material = new THREE.MeshPhongMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        shininess: 30
                    });

                    realtimePointCloud = new THREE.Mesh(newGeometry, material);
                    scene.add(realtimePointCloud);

                    // Update UI
                    const vertexCount = newPositions.length / 3;
                    const faceCount = newIndices.length / 3;
                    updateMeshInfo(vertexCount, faceCount);
                    updateScanStatus('ready', 'Background removed');
                    document.getElementById('generateBtn').disabled = false;

                    console.log('‚úÖ Background removed successfully!');
                    console.log('üìä Remaining vertices:', vertexCount.toLocaleString());
                    console.log('üìä Remaining faces:', Math.floor(faceCount).toLocaleString());

                } catch (error) {
                    console.error('‚ùå Background removal error:', error);
                    alert('Failed to remove background: ' + error.message);
                    updateScanStatus('ready', 'Error');
                }
            }, 100);
        }

        // ==================== WATERTIGHT MESH GENERATION ====================
        function generateWatertight() {
            if (!realtimePointCloud || !realtimePointCloud.geometry) {
                alert('No mesh to process! Scan and remove background first.');
                return;
            }

            console.log('üíß Generating watertight mesh...');
            updateScanStatus('processing', 'Generating watertight...');

            setTimeout(() => {
                try {
                    const sourceGeometry = realtimePointCloud.geometry;

                    // Use DepthToMeshConverter with improved hole filling
                    if (!depthMeshConverter) {
                        throw new Error('DepthToMeshConverter not initialized');
                    }

                    // Extract points from current mesh
                    const positions = sourceGeometry.attributes.position;
                    const colors = sourceGeometry.attributes.color;
                    const points = [];

                    for (let i = 0; i < positions.count; i++) {
                        points.push({
                            x: positions.getX(i),
                            y: positions.getY(i),
                            z: positions.getZ(i),
                            r: Math.floor(colors.getX(i) * 255),
                            g: Math.floor(colors.getY(i) * 255),
                            b: Math.floor(colors.getZ(i) * 255)
                        });
                    }

                    console.log('üìä Processing', points.length.toLocaleString(), 'points for watertight mesh...');

                    // Generate watertight mesh with improved algorithm
                    const geometry = depthMeshConverter.depthToMesh(points, 320, 240);

                    if (!geometry) {
                        throw new Error('Watertight mesh generation failed');
                    }

                    // Apply Laplacian smoothing for better surface quality
                    console.log('üîß Applying Laplacian smoothing...');
                    smoothMeshLaplacian(geometry, 3); // 3 iterations

                    // Create mesh material
                    const material = new THREE.MeshPhongMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        shininess: 50
                    });

                    // Create final mesh
                    currentMesh = new THREE.Mesh(geometry, material);

                    // Center the mesh
                    geometry.computeBoundingBox();
                    const box = geometry.boundingBox;
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);

                    // Remove realtime mesh, show watertight mesh
                    if (realtimePointCloud) {
                        scene.remove(realtimePointCloud);
                        realtimePointCloud = null;
                    }

                    scene.add(currentMesh);

                    // Update UI
                    const vertexCount = geometry.attributes.position.count;
                    const faceCount = geometry.index ? geometry.index.count / 3 : 0;
                    updateMeshInfo(vertexCount, faceCount);
                    updateScanStatus('ready', 'Watertight generated!');
                    document.getElementById('exportBtn').disabled = false;

                    console.log('‚úÖ Watertight mesh generated!');
                    console.log('üìä Vertices:', vertexCount.toLocaleString());
                    console.log('üìä Faces:', Math.floor(faceCount).toLocaleString());

                } catch (error) {
                    console.error('‚ùå Watertight generation error:', error);
                    alert('Failed to generate watertight mesh: ' + error.message);
                    updateScanStatus('ready', 'Error');
                }
            }, 100);
        }

        // Mesh simplification to reduce file size
        function simplifyMesh(geometry, targetRatio = 0.5) {
            // Simple decimation: keep every N-th vertex
            const positions = geometry.attributes.position;
            const colors = geometry.attributes.color;
            const indices = geometry.index;

            const originalVertexCount = positions.count;
            const targetVertexCount = Math.floor(originalVertexCount * targetRatio);
            const step = Math.max(1, Math.floor(originalVertexCount / targetVertexCount));

            const newPositions = [];
            const newColors = [];
            const vertexMap = new Map();

            // Sample vertices
            for (let i = 0; i < positions.count; i += step) {
                vertexMap.set(i, newPositions.length / 3);
                newPositions.push(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                if (colors) {
                    newColors.push(
                        colors.getX(i),
                        colors.getY(i),
                        colors.getZ(i)
                    );
                }
            }

            // Rebuild indices
            const newIndices = [];
            if (indices) {
                for (let i = 0; i < indices.count; i += 3) {
                    const i1 = indices.getX(i);
                    const i2 = indices.getX(i + 1);
                    const i3 = indices.getX(i + 2);

                    // Keep triangle only if all vertices are in the simplified mesh
                    if (vertexMap.has(i1) && vertexMap.has(i2) && vertexMap.has(i3)) {
                        newIndices.push(
                            vertexMap.get(i1),
                            vertexMap.get(i2),
                            vertexMap.get(i3)
                        );
                    }
                }
            }

            // Create simplified geometry
            const simplified = new THREE.BufferGeometry();
            simplified.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            if (newColors.length > 0) {
                simplified.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
            }
            if (newIndices.length > 0) {
                simplified.setIndex(newIndices);
            }
            simplified.computeVertexNormals();

            return simplified;
        }

        // Laplacian smoothing for better mesh quality
        function smoothMeshLaplacian(geometry, iterations = 1) {
            const positions = geometry.attributes.position;
            const indices = geometry.index;

            // Build vertex adjacency list
            const adjacency = new Map();
            for (let i = 0; i < positions.count; i++) {
                adjacency.set(i, new Set());
            }

            for (let i = 0; i < indices.count; i += 3) {
                const i1 = indices.getX(i);
                const i2 = indices.getX(i + 1);
                const i3 = indices.getX(i + 2);

                adjacency.get(i1).add(i2);
                adjacency.get(i1).add(i3);
                adjacency.get(i2).add(i1);
                adjacency.get(i2).add(i3);
                adjacency.get(i3).add(i1);
                adjacency.get(i3).add(i2);
            }

            // Apply Laplacian smoothing
            for (let iter = 0; iter < iterations; iter++) {
                const newPositions = new Float32Array(positions.array.length);

                for (let i = 0; i < positions.count; i++) {
                    const neighbors = adjacency.get(i);

                    if (neighbors.size === 0) {
                        // Keep original position if no neighbors
                        newPositions[i * 3] = positions.getX(i);
                        newPositions[i * 3 + 1] = positions.getY(i);
                        newPositions[i * 3 + 2] = positions.getZ(i);
                    } else {
                        // Average of neighbors
                        let sumX = 0, sumY = 0, sumZ = 0;
                        for (const neighborIdx of neighbors) {
                            sumX += positions.getX(neighborIdx);
                            sumY += positions.getY(neighborIdx);
                            sumZ += positions.getZ(neighborIdx);
                        }

                        const lambda = 0.5; // Smoothing factor (0-1)
                        const avgX = sumX / neighbors.size;
                        const avgY = sumY / neighbors.size;
                        const avgZ = sumZ / neighbors.size;

                        // Blend original and averaged position
                        newPositions[i * 3] = positions.getX(i) * (1 - lambda) + avgX * lambda;
                        newPositions[i * 3 + 1] = positions.getY(i) * (1 - lambda) + avgY * lambda;
                        newPositions[i * 3 + 2] = positions.getZ(i) * (1 - lambda) + avgZ * lambda;
                    }
                }

                // Update positions
                positions.array.set(newPositions);
                positions.needsUpdate = true;
            }

            // Recompute normals after smoothing
            geometry.computeVertexNormals();
        }

        // ==================== EXPORT STL ====================
        function exportSTL() {
            // Support both watertight mesh (currentMesh) and direct export (realtimePointCloud)
            let meshToExport = currentMesh || realtimePointCloud;

            if (!meshToExport || !meshToExport.geometry) {
                alert('No mesh to export! Scan first.');
                return;
            }

            console.log('üíæ Exporting STL...');

            let geometry = meshToExport.geometry.clone();

            // STEP 0: Simplify mesh if too large (reduce file size)
            const vertexCount = geometry.attributes.position.count;
            const faceCount = geometry.index ? geometry.index.count / 3 : 0;

            console.log('üìä Original mesh:', vertexCount.toLocaleString(), 'vertices,', Math.floor(faceCount).toLocaleString(), 'faces');

            if (vertexCount > 50000) {
                console.log('üîß Mesh is large, applying simplification...');
                geometry = simplifyMesh(geometry, 0.5); // Reduce to 50%
                console.log('‚úÖ Simplified to:', geometry.attributes.position.count.toLocaleString(), 'vertices');
            }

            // STEP 1: Apply mesh transformations (rotation if exists)
            console.log('üîß Preparing mesh for export...');
            if (meshToExport.rotation) {
                const matrix = new THREE.Matrix4();
                matrix.makeRotationFromEuler(meshToExport.rotation);
                geometry.applyMatrix4(matrix);
            }

            // STEP 2: Compute original bounds
            geometry.computeBoundingBox();
            let box = geometry.boundingBox;
            let size = new THREE.Vector3();
            box.getSize(size);
            let center = new THREE.Vector3();
            box.getCenter(center);

            console.log('üì¶ Original mesh bounds:', {
                size: { x: size.x.toFixed(3), y: size.y.toFixed(3), z: size.z.toFixed(3) }
            });

            // STEP 3: Determine optimal orientation
            // Find the longest axis and make it Z-up
            const maxDimension = Math.max(size.x, size.y, size.z);
            let rotationMatrix = new THREE.Matrix4();

            if (size.y === maxDimension) {
                // Y is tallest - rotate to make it Z (standard case for standing objects)
                rotationMatrix.makeRotationX(-Math.PI / 2);
                console.log('üìê Orientation: Y-up ‚Üí Z-up (Portrait)');
            } else if (size.x === maxDimension) {
                // X is longest - rotate to make it Z
                rotationMatrix.makeRotationY(Math.PI / 2).multiply(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                console.log('üìê Orientation: X-up ‚Üí Z-up (Landscape)');
            } else {
                // Z is already tallest - just flip if needed
                rotationMatrix.makeRotationX(-Math.PI / 2);
                console.log('üìê Orientation: Z-up (keeping as is)');
            }

            geometry.applyMatrix4(rotationMatrix);

            // STEP 4: Recompute bounds after rotation
            geometry.computeBoundingBox();
            box = geometry.boundingBox;
            size = new THREE.Vector3();
            box.getSize(size);
            center = new THREE.Vector3();
            box.getCenter(center);

            console.log('üì¶ After rotation:', {
                size: { x: size.x.toFixed(3), y: size.y.toFixed(3), z: size.z.toFixed(3) }
            });

            // STEP 5: Center mesh and place bottom at Z=0 (on build plate)
            const translation = new THREE.Matrix4();
            translation.makeTranslation(-center.x, -center.y, -box.min.z);
            geometry.applyMatrix4(translation);

            // STEP 6: Scale to reasonable size (in mm)
            // Convert from meters to millimeters, but limit max size
            const scaleMatrix = new THREE.Matrix4();
            scaleMatrix.makeScale(1000, 1000, 1000); // meters to mm
            geometry.applyMatrix4(scaleMatrix);

            // STEP 7: Ensure mesh fits in reasonable print volume (max 200mm)
            geometry.computeBoundingBox();
            box = geometry.boundingBox;
            size = new THREE.Vector3();
            box.getSize(size);

            const maxSize = Math.max(size.x, size.y, size.z);
            if (maxSize > 200) {
                const scaleFactor = 200 / maxSize;
                console.log('üîß Scaling down to fit 200mm print volume (factor:', scaleFactor.toFixed(2), ')');
                const fitScale = new THREE.Matrix4();
                fitScale.makeScale(scaleFactor, scaleFactor, scaleFactor);
                geometry.applyMatrix4(fitScale);

                // Recenter after scaling
                geometry.computeBoundingBox();
                box = geometry.boundingBox;
                center = new THREE.Vector3();
                box.getCenter(center);
                const recenter = new THREE.Matrix4();
                recenter.makeTranslation(-center.x, -center.y, -box.min.z);
                geometry.applyMatrix4(recenter);
            }

            geometry.computeBoundingBox();
            box = geometry.boundingBox;
            size = new THREE.Vector3();
            box.getSize(size);

            console.log('‚úÖ Final mesh size (mm):', {
                x: size.x.toFixed(1),
                y: size.y.toFixed(1),
                z: size.z.toFixed(1)
            });

            // STEP 7: Generate STL content
            let stlContent = 'solid KinectMesh\n';

            const positions = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;

            if (indices) {
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i] * 3;
                    const i2 = indices[i + 1] * 3;
                    const i3 = indices[i + 2] * 3;

                    const v1 = new THREE.Vector3(
                        positions.array[i1],
                        positions.array[i1 + 1],
                        positions.array[i1 + 2]
                    );
                    const v2 = new THREE.Vector3(
                        positions.array[i2],
                        positions.array[i2 + 1],
                        positions.array[i2 + 2]
                    );
                    const v3 = new THREE.Vector3(
                        positions.array[i3],
                        positions.array[i3 + 1],
                        positions.array[i3 + 2]
                    );

                    const normal = new THREE.Vector3()
                        .subVectors(v2, v1)
                        .cross(new THREE.Vector3().subVectors(v3, v1))
                        .normalize();

                    stlContent += `  facet normal ${normal.x} ${normal.y} ${normal.z}\n`;
                    stlContent += `    outer loop\n`;
                    stlContent += `      vertex ${v1.x} ${v1.y} ${v1.z}\n`;
                    stlContent += `      vertex ${v2.x} ${v2.y} ${v2.z}\n`;
                    stlContent += `      vertex ${v3.x} ${v3.y} ${v3.z}\n`;
                    stlContent += `    endloop\n`;
                    stlContent += `  endfacet\n`;
                }
            }

            stlContent += 'endsolid KinectMesh\n';

            // Download
            const blob = new Blob([stlContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `kinect_mesh_${Date.now()}.stl`;
            link.click();
            URL.revokeObjectURL(url);

            console.log('‚úÖ STL exported successfully (proper bounds and orientation)');
        }

        // ==================== CLEAR ====================
        function clearAll() {
            console.log('üóëÔ∏è Clearing all data...');

            isScanning = false;
            depthFrames = [];
            meshFrames = []; // Clear mesh frames
            totalPointsCollected = 0;
            frameCount = 0;

            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh = null;
            }
            if (realtimePointCloud) {
                scene.remove(realtimePointCloud);
                realtimePointCloud = null;
            }

            // Reset UI
            updateScanStatus('idle', 'Idle');
            document.getElementById('startScanBtn').disabled = !connected;
            document.getElementById('stopScanBtn').disabled = true;
            document.getElementById('removeBgBtn').disabled = true;
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('exportBtn').disabled = true;
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('totalPoints').textContent = '0';
            updateMeshInfo(0, 0);

            console.log('‚úÖ Cleared');
        }

        // ==================== SETTINGS ====================
        function updateResolution(value) {
            meshResolution = parseFloat(value);
            document.getElementById('resolutionValue').textContent = value;
        }

        function updateDepthMin(value) {
            depthMin = parseFloat(value);
            document.getElementById('depthMinValue').textContent = value;
        }

        function updateDepthMax(value) {
            depthMax = parseFloat(value);
            document.getElementById('depthMaxValue').textContent = value;
        }

        // ==================== UI HELPERS ====================
        function updateScanStatus(statusClass, statusText) {
            const statusEl = document.getElementById('scanStatus');
            statusEl.className = 'scan-status ' + statusClass;
            statusEl.textContent = statusText;
        }

        function updateMeshInfo(vertices, faces) {
            document.getElementById('meshVertices').textContent = vertices.toLocaleString();
            document.getElementById('meshFaces').textContent = Math.floor(faces).toLocaleString();

            const meshInfoEl = document.getElementById('meshInfo');
            if (vertices > 0) {
                meshInfoEl.textContent = `${vertices.toLocaleString()} vertices, ${Math.floor(faces).toLocaleString()} faces`;
            } else {
                meshInfoEl.textContent = 'No mesh loaded';
            }
        }
    </script>
</body>
</html>
