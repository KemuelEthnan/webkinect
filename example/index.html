<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Kinect - Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="pointcloud-processor.js"></script>
    <script src="depth-to-mesh.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 1.1em;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #44ff44;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        button.active {
            background: linear-gradient(135deg, #44ff44 0%, #00cc00 100%);
            box-shadow: 0 5px 15px rgba(68, 255, 68, 0.4);
        }

        button.scanning {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            animation: pulse-button 1s infinite;
        }

        @keyframes pulse-button {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .video-container {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            position: relative;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cameraImage {
            max-width: 100%;
            max-height: 600px;
            display: block;
        }

        .placeholder {
            color: #888;
            font-size: 1.2em;
        }

        .data-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .data-panel h2 {
            margin-bottom: 15px;
            color: #667eea;
        }

        #skeletonData {
            background: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .info p {
            margin: 5px 0;
        }

        /* 3D Scanning Styles - Skanect-like Layout */
        #scanningTab {
            height: calc(100vh - 200px);
            overflow: hidden;
        }

        .scanning-container {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            grid-template-rows: 1fr;
            height: 100%;
            gap: 0;
            background: #2c3e50;
        }

        /* Left Panel - Depth Camera */
        .depth-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .panel-header {
            padding: 15px;
            background: #2c3e50;
            font-weight: 600;
            color: #ecf0f1;
            border-bottom: 2px solid #667eea;
        }

        .depth-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #depthCanvas {
            width: 280px;
            height: 210px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .depth-legend {
            margin-top: 15px;
            font-size: 12px;
            display: flex;
            gap: 15px;
            color: #ecf0f1;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .depth-stats {
            margin-top: 20px;
            font-size: 12px;
            text-align: center;
            color: #95a5a6;
        }

        /* Center Panel - 3D Viewer */
        .viewer-panel {
            background: #1a1a1a;
            position: relative;
        }

        #viewer {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 0;
            overflow: hidden;
            margin-bottom: 0;
        }

        .viewer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            color: #ecf0f1;
            z-index: 10;
        }

        .viewer-overlay .title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        /* Right Panel - Controls */
        .control-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #2c3e50;
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .control-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.3em;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .info-item label {
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #333;
            font-size: 1.1em;
        }

        .info-item .value {
            font-size: 18px;
            font-weight: 700;
            color: #ecf0f1;
        }

        .scan-progress {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .scan-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            color: white;
        }

        .scan-status.idle {
            background: #95a5a6;
        }

        .scan-status.scanning {
            background: #f39c12;
            animation: pulse-bg 1s infinite;
        }

        .scan-status.processing {
            background: #3498db;
        }

        .scan-status.ready {
            background: #2ecc71;
        }

        @keyframes pulse-bg {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .slider-control {
            margin-bottom: 15px;
        }

        .slider-control label {
            font-size: 12px;
            color: #95a5a6;
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2c3e50;
            outline: none;
            -webkit-appearance: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        @media (max-width: 1200px) {
            .scanning-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Web Kinect Example</h1>
            <div class="status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Menghubungkan ke server...</span>
            </div>
        </div>

        <div class="content">
            <div class="info">
                <p><strong>Catatan:</strong> Pastikan server Kinect sudah berjalan di <code>ws://127.0.0.1:8181</code></p>
                <p>Server dapat dijalankan dengan menjalankan <code>bin/server.exe</code></p>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('normal')">üéÆ Normal Mode</button>
                <button class="tab" onclick="switchTab('scanning')">üì∑ 3D Scanning</button>
            </div>

            <!-- Normal Mode Tab -->
            <div id="normalTab" class="tab-content active">
                <div class="controls">
                    <button id="connectBtn" onclick="connect()">Hubungkan</button>
                    <button id="disconnectBtn" onclick="disconnect()" disabled>Putuskan Koneksi</button>
                    <button id="showBothBtn" onclick="showBothStreams()" disabled>Tampilkan Color & Depth</button>
                    <button id="colorBtn" onclick="setColorMode()" disabled>Hanya Color</button>
                    <button id="depthBtn" onclick="setDepthMode()" disabled>Hanya Depth</button>
                </div>

                <div class="info" style="background: #e8f5e9; border-left: 4px solid #4caf50;">
                    <p><strong>üí° Fitur Baru:</strong> Klik "Tampilkan Color & Depth" untuk melihat kedua stream secara bersamaan (side-by-side)</p>
                </div>

                <div id="dualStreamContainer" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div class="video-container" style="margin-bottom: 0;">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 16px; border-radius: 5px; font-weight: 600; z-index: 10;">üìπ Color Camera</div>
                            <img id="colorImage" style="display: none; max-width: 100%; max-height: 400px;" alt="Color Camera">
                            <div class="placeholder" id="colorPlaceholder">Menunggu data color...</div>
                        </div>
                        <div class="video-container" style="margin-bottom: 0;">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(118, 75, 162, 0.9); color: white; padding: 8px 16px; border-radius: 5px; font-weight: 600; z-index: 10;">üåä Depth Camera</div>
                            <img id="depthImage" style="display: none; max-width: 100%; max-height: 400px;" alt="Depth Camera">
                            <div class="placeholder" id="depthPlaceholder">Menunggu data depth...</div>
                        </div>
                    </div>
                </div>

                <div id="singleStreamContainer" class="video-container">
                    <img id="cameraImage" style="display: none;" alt="Kinect Camera Feed">
                    <div class="placeholder" id="placeholder">Tidak ada data kamera</div>
                </div>

                <div class="data-panel">
                    <h2>üìä Skeleton Data</h2>
                    <div id="skeletonData">Menunggu data skeleton...</div>
                </div>
            </div>

            <!-- 3D Scanning Tab - Skanect-like Layout -->
            <div id="scanningTab" class="tab-content">
                <div class="scanning-container">
                    <!-- Left Panel: Depth Camera View -->
                    <div class="depth-panel">
                        <div class="panel-header">üì∑ Depth Camera (Real-time)</div>
                        <div class="depth-viewer">
                            <canvas id="depthCanvas" width="320" height="240"></canvas>
                            <div class="depth-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #00ff00;"></div>
                                    <span>Valid (0.5-4m)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #ff0000;"></div>
                                    <span>Invalid</span>
                                </div>
                            </div>
                            <div class="depth-stats">
                                <div>FPS: <span id="depthFps">0</span></div>
                                <div>Points: <span id="depthPoints">0</span></div>
                            </div>
                        </div>
                    </div>

                    <!-- Center Panel: 3D Viewer -->
                    <div class="viewer-panel">
                        <div id="viewer"></div>
                        <div class="viewer-overlay">
                            <div class="title">3D Mesh Viewer</div>
                            <div style="font-size: 12px; line-height: 1.6;">
                                üñ±Ô∏è Drag to rotate<br>
                                üìú Scroll to zoom<br>
                                <span id="meshInfo">No mesh loaded</span>
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel: Controls -->
                    <div class="control-panel">
                        <!-- Connection -->
                        <div class="control-section">
                            <h3>üîå Connection</h3>
                            <button id="connectBtnScan" class="btn-primary" onclick="connect()" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">Connect to Kinect</button>
                            <button id="disconnectBtnScan" class="btn-danger" onclick="disconnect()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #e74c3c; color: white;">Disconnect</button>
                        </div>

                        <!-- Scanning Controls -->
                        <div class="control-section">
                            <h3>üé¨ Scanning</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Status</label>
                                <div class="scan-status idle" id="scanStatus">Idle</div>
                            </div>
                            <button id="startScanBtn" class="btn-success" onclick="startScan()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #2ecc71; color: white;">‚ñ∂Ô∏è Start Scan</button>
                            <button id="startPhase2Btn" onclick="startPhase2()" disabled style="display: none; width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #ff9800; color: white;">üîÑ Mulai Fase 2 (Belakang)</button>
                            <button id="stopScanBtn" class="btn-warning" onclick="stopCapture()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #f39c12; color: white;">‚è∏Ô∏è Stop Scan</button>
                            <button id="generateWatertightBtn" class="btn-primary" onclick="generateWatertight()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">üî∑ Generate Watertight</button>
                            <button id="exportSTLBtn" class="btn-primary" onclick="exportSTL()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">üíæ Export STL</button>
                            <button id="clearBtn" class="btn-danger" onclick="clearScan()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #e74c3c; color: white;">üóëÔ∏è Clear All</button>
                        </div>

                        <!-- Scan Info -->
                        <div class="control-section">
                            <h3>üìä Scan Info</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Frames Captured</label>
                                <div class="value" id="frameCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Total Points</label>
                                <div class="value" id="pointCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Mesh Vertices</label>
                                <div class="value" id="meshVertices">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Mesh Faces</label>
                                <div class="value" id="meshFaces">0</div>
                            </div>
                            <div class="scan-progress" style="margin-top: 15px;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase; display: block; margin-bottom: 8px;">Progress</label>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                                </div>
                            </div>
                        </div>

                        <!-- Settings -->
                        <div class="control-section">
                            <h3>‚öôÔ∏è Settings</h3>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Max Points per Frame</span>
                                    <span id="maxPointsValue">20000</span>
                                </label>
                                <input type="range" id="maxPointsSlider" min="1000" max="100000" value="20000" step="1000" onchange="document.getElementById('maxPointsValue').textContent = this.value">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Mesh Resolution</span>
                                    <span id="meshResolutionValue">0.05</span>
                                </label>
                                <input type="range" id="meshResolutionSlider" min="0.01" max="0.1" value="0.05" step="0.01" onchange="document.getElementById('meshResolutionValue').textContent = this.value">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Depth Range Min (m)</span>
                                    <span id="depthMinValue">0.5</span>
                                </label>
                                <input type="range" id="depthMinSlider" min="0.3" max="2.0" step="0.1" value="0.5" onchange="updateDepthMin(this.value)">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Depth Range Max (m)</span>
                                    <span id="depthMaxValue">4.0</span>
                                </label>
                                <input type="range" id="depthMaxSlider" min="1.0" max="8.0" step="0.5" value="4.0" onchange="updateDepthMax(this.value)">
                            </div>
                            <div style="margin-top: 15px; padding: 15px; background: #2c3e50; border-radius: 5px; border: 2px solid #667eea;">
                                <label style="display: flex; align-items: center; gap: 8px; font-weight: bold; color: #ecf0f1; font-size: 12px;">
                                    <input type="checkbox" id="enableMultiPhaseCheckbox" style="width: auto;" onchange="toggleMultiPhaseMode()">
                                    üîÑ Scan /reDua Fase (Depan & Belakang)
                                </label>
                                <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #95a5a6;">
                                    Fase 1: Scan depan (15 detik)<br>
                                    Fase 2: Scan belakang (15 detik)<br>
                                    Hasil: Objek 3D utuh dari kedua sisi
                                </p>
                            </div>
                            <div id="phaseInfo" style="display: none; margin-top: 10px; padding: 10px; background: #2c3e50; border-radius: 5px;">
                                <label style="font-weight: bold; color: #ecf0f1; font-size: 12px;">Fase Saat Ini:</label>
                                <span id="currentPhase" style="font-size: 1.1em; color: #f39c12;">-</span>
                            </div>
                        </div>

                        <!-- Position Control -->
                        <div class="control-section">
                            <h3>üìç Position Control</h3>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position X</span>
                                    <input type="number" id="positionXValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionX(this.value)">
                                </label>
                                <input type="range" id="positionXSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionX(this.value); document.getElementById('positionXValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('x', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('x', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position Y</span>
                                    <input type="number" id="positionYValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionY(this.value)">
                                </label>
                                <input type="range" id="positionYSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionY(this.value); document.getElementById('positionYValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('y', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('y', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position Z</span>
                                    <input type="number" id="positionZValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionZ(this.value)">
                                </label>
                                <input type="range" id="positionZSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionZ(this.value); document.getElementById('positionZValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('z', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('z', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <button onclick="resetObjectPosition()" style="width: 100%; padding: 10px; margin-top: 10px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                üîÑ Reset to Center
                            </button>
                            <div style="margin-top: 10px; padding: 10px; background: #2c3e50; border-radius: 5px;">
                                <label style="font-size: 0.9em; color: #95a5a6;">Current Position:</label>
                                <div id="currentPosition" style="font-size: 1.1em; font-weight: 600; color: #ecf0f1;">X: 0.00, Y: 0.00, Z: 0.00</div>
                            </div>
                        </div>

                        <!-- Debug Info -->
                        <div class="control-section">
                            <h3>üîç Debug Info</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Last Message</label>
                                <div style="font-size: 0.9em; color: #ecf0f1;" id="debugMessage">-</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Data Received</label>
                                <div class="value" id="debugDataCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Point Cloud Frames</label>
                                <div class="value" id="pointCloudFramesCount">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var socket = null;
        var connected = false;
        var currentMode = 'normal'; // 'normal' or 'scanning'

        // 3D Scanning variables
        var isScanning = false;
        var isCaptureActive = true; // New flag for auto-capture control
        var pointCloud = [];
        var mesh = null;
        var scene, camera, renderer;
        var viewerInitialized = false;
        var debugDataCount = 0;
        var frameCount = 0;
        var scanTimer = null;
        var scanStartTime = 0;
        var scanDuration = 6000; // Auto-stop after 6 seconds (5-7 detik untuk banyak frame)
        var dataReceivedDuringScan = 0;
        var pointCloudDataReceived = 0;
        var maxTotalPoints = 500000; // Limit to 500k points for high-quality scans
        var autoCaptureTimer = null;
        
        // Multi-phase scanning (depan dan belakang)
        var scanPhase = 0; // 0 = not started, 1 = depan (front), 2 = belakang (back)
        var pointCloudFront = []; // Point cloud from phase 1 (depan)
        var pointCloudBack = []; // Point cloud from phase 2 (belakang)
        var phaseDuration = 15000; // 15 seconds per phase
        var isMultiPhaseMode = false; // Enable/disable multi-phase mode
        
        // Point cloud processing
        var pointCloudProcessor = new PointCloudProcessor();
        var pointCloudFrames = [];
        var useICP = false; // Disabled by default - too CPU intensive!
        var useNoiseFilter = false; // Disabled by default - too CPU intensive!
        var kinectPosition = { x: 0, y: 0, z: 0 };

        // Throttling to prevent freeze
        var lastProcessTime = 0;
        var processingThrottle = 100; // Process max once every 100ms
        var renderThrottle = 50; // Render max once every 50ms
        var lastRenderTime = 0;

        // Depth camera visualization (Skanect-like)
        var depthCanvas = null;
        var depthCtx = null;
        var lastDepthRenderTime = 0;
        var depthFpsCounter = 0;
        var depthFpsInterval = null;
        var depthMin = 0.5; // Minimum depth in meters
        var depthMax = 4.0; // Maximum depth in meters

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            if (tab === 'normal') {
                document.querySelector('.tab:first-child').classList.add('active');
                document.getElementById('normalTab').classList.add('active');
                currentMode = 'normal';
                // Switch back to Color mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("Color");
                }
            } else {
                document.querySelector('.tab:last-child').classList.add('active');
                document.getElementById('scanningTab').classList.add('active');
                currentMode = 'scanning';

                console.log('üîµ Switched to 3D Scanning tab - AUTO-CAPTURE MODE (60 seconds)');
                console.log('üìå Auto-capture will run for 60 seconds (or until max points reached) then stop automatically');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());

                // Initialize depth canvas when switching to scanning tab
                initDepthCanvas();

                // Initialize 3D viewer if not already done
                if (!viewerInitialized) {
                    console.log('üîµ Initializing 3D viewer...');
                    initViewer();
                    viewerInitialized = true;
                }

                // Switch to PointCloud mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("PointCloud");
                    console.log('üì§ Switched to PointCloud mode via tab switch');

                    // Enable buttons
                    const startBtn = document.getElementById('startScanBtn');
                    const stopBtn = document.getElementById('stopScanBtn');
                    if (startBtn) startBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;

                    // Reset and start auto-capture with 15 second timer
                    isCaptureActive = true;
                    scanStartTime = Date.now();

                    // Update status
                    updateScanStatus('scanning', 'Auto-capturing for 60 seconds...');

                    // Auto-stop after scanDuration (60 seconds) OR when max points reached
                    if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
                    autoCaptureTimer = setTimeout(() => {
                        console.log('‚è±Ô∏è ' + (scanDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                        console.log('üìä Final point count:', pointCloud.length.toLocaleString());
                        stopCapture();
                    }, scanDuration);

                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode switch');
                        }
                    }, 100);
                }
            }
        }

        function updateStatus(isConnected) {
            connected = isConnected;
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const connectBtnScan = document.getElementById('connectBtnScan');
            const disconnectBtnScan = document.getElementById('disconnectBtnScan');
            const colorBtn = document.getElementById('colorBtn');
            const depthBtn = document.getElementById('depthBtn');
            const startScanBtn = document.getElementById('startScanBtn');

            if (isConnected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Terhubung ke server - Color Mode';
                if (connectBtn) connectBtn.disabled = true;
                if (disconnectBtn) disconnectBtn.disabled = false;
                if (connectBtnScan) connectBtnScan.disabled = true;
                if (disconnectBtnScan) disconnectBtnScan.disabled = false;
                if (colorBtn) colorBtn.disabled = false;
                if (depthBtn) depthBtn.disabled = false;
                // Set default mode to Color
                if (colorBtn) colorBtn.classList.add('active');
                if (depthBtn) depthBtn.classList.remove('active');
                if (startScanBtn) startScanBtn.disabled = false;
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Tidak terhubung';
                if (connectBtn) connectBtn.disabled = false;
                if (disconnectBtn) disconnectBtn.disabled = true;
                if (connectBtnScan) connectBtnScan.disabled = false;
                if (disconnectBtnScan) disconnectBtnScan.disabled = true;
                if (colorBtn) colorBtn.disabled = true;
                if (depthBtn) depthBtn.disabled = true;
                if (startScanBtn) startScanBtn.disabled = true;
            }
        }

        function connect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            console.log('Connecting to ws://127.0.0.1:8181...');
            socket = new WebSocket("ws://127.0.0.1:8181");

            socket.onopen = function() {
                console.log('Connected to server');
                updateStatus(true);
                // Set initial mode based on current tab
                if (currentMode === 'scanning') {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode on connect');
                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode on connect');
                        }
                    }, 100);
                } else {
                    socket.send("Color");
                    console.log('üì§ Sent Color mode on connect');
                }
            };

            socket.onclose = function() {
                console.log('Disconnected from server');
                updateStatus(false);
                document.getElementById('cameraImage').style.display = 'none';
                document.getElementById('placeholder').style.display = 'block';
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateStatus(false);
                alert('Error: Tidak dapat terhubung ke server. Pastikan server.exe sudah berjalan.');
            };

            socket.onmessage = function(event) {
                // Skeleton data or Point Cloud (JSON string)
                if (typeof event.data === "string") {
                    // Count data received during scan
                    if (isScanning) {
                        dataReceivedDuringScan++;
                    }
                    
                    try {
                        // Log raw data for debugging (show all)
                        console.log('üì• Received string data, length:', event.data.length, 'chars', isScanning ? '(during scan)' : '');
                        console.log('üì• Raw data:', event.data);
                        
                        var data = JSON.parse(event.data);
                        console.log('‚úÖ Parsed JSON successfully. Keys:', Object.keys(data));
                        console.log('üìã Full data structure:', {
                            hasMode: !!data.mode,
                            mode: data.mode,
                            hasData: !!data.data,
                            dataIsArray: Array.isArray(data.data),
                            dataLength: data.data ? data.data.length : 0,
                            hasSkeletons: !!data.skeletons,
                            width: data.width,
                            height: data.height
                        });
                        
                        // Check if it's point cloud data (server sends: {mode: "PointCloud", data: [...], width, height})
                        if (data.mode === 'PointCloud' && data.data && Array.isArray(data.data)) {
                            // Count point cloud data received
                            if (isScanning) {
                                pointCloudDataReceived++;
                            }
                            
                            // Create a new object in the format the rest of the JS expects
                            const pointCloudPayload = { points: data.data };

                            debugDataCount++;
                            const debugMsg = `Received ${pointCloudPayload.points.length} points (Mode: ${currentMode}, Scanning: ${isScanning})`;
                            console.log('‚úÖ‚úÖ‚úÖ Point cloud data received!', {
                                pointCount: pointCloudPayload.points.length,
                                width: data.width,
                                height: data.height,
                                currentMode: currentMode,
                                isScanning: isScanning,
                                firstPoint: pointCloudPayload.points.length > 0 ? pointCloudPayload.points[0] : 'no points',
                                totalPointCloudFrames: pointCloudDataReceived
                            });
                            
                            // Update debug UI
                            const debugMsgEl = document.getElementById('debugMessage');
                            const debugCountEl = document.getElementById('debugDataCount');
                            const pointCloudFramesEl = document.getElementById('pointCloudFramesCount');
                            if (debugMsgEl) debugMsgEl.textContent = debugMsg;
                            if (debugCountEl) debugCountEl.textContent = debugDataCount;
                            if (pointCloudFramesEl) pointCloudFramesEl.textContent = pointCloudDataReceived;
                            
                            // Visualize depth camera (Skanect-like) - always show real-time depth
                            if (currentMode === 'scanning') {
                                const depthData = {
                                    points: pointCloudPayload.points,
                                    width: data.width || 320,
                                    height: data.height || 240
                                };
                                visualizeDepth(depthData);
                            }

                            // üî• RADICAL SIMPLIFICATION: If we're in scanning tab, ALWAYS process point cloud data
                            // This bypasses all the complex isScanning flag logic that keeps failing
                            if (currentMode === 'scanning') {
                                // Check if we should still capture (auto-stop after limit or duration)
                                if (!isCaptureActive) {
                                    console.log('‚è∏Ô∏è Capture stopped - ignoring new data');
                                    return;
                                }

                                // Check if we've hit the point limit
                                if (pointCloud.length >= maxTotalPoints) {
                                    console.log('‚è∏Ô∏è Max points reached (' + maxTotalPoints.toLocaleString() + ') - stopping capture');
                                    stopCapture();
                                    return;
                                }

                                console.log('üîÑ AUTO-PROCESSING depth frame data (mesh mode)...');
                                console.log('üìä Received ' + pointCloudPayload.points.length + ' points');

                                // Process as mesh directly (seperti Skanect) - bukan point cloud
                                if (typeof DepthToMeshConverter !== 'undefined' && depthMeshConverter) {
                                    processDepthFrameAsMesh(pointCloudPayload, data.width, data.height);
                                } else {
                                    // Fallback to point cloud if converter not available
                                    processPointCloud(pointCloudPayload);
                                }

                                // Update scan info
                                const pointCountEl = document.getElementById('pointCount');
                                const frameCountEl = document.getElementById('frameCount');
                                if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
                                if (frameCountEl) frameCountEl.textContent = frameCount;
                            } else {
                                console.log('‚ö†Ô∏è Point cloud data received but not in scanning tab');
                                if (debugMsgEl) debugMsgEl.textContent = 'Data received but not in scanning tab';
                            }
                        } 
                        // Check if it's skeleton data (server sends: {skeletons: [...]})
                        else if (data.skeletons && Array.isArray(data.skeletons)) {
                            // Only process skeleton data in normal mode
                            if (currentMode === 'normal') {
                                document.getElementById('skeletonData').textContent = 
                                    JSON.stringify(data, null, 2);
                                console.log('Skeleton data received:', data);
                            } else {
                                // In scanning mode, ignore skeleton data (it's from old Color mode frames)
                                // But also try to force switch mode again if we keep receiving skeleton data
                                if (isScanning) {
                                    console.log('‚ö†Ô∏è Ignoring skeleton data in scanning mode - server mungkin belum switch mode');
                                    console.log('üîÑ Attempting to force switch to PointCloud mode again...');
                                    
                                    // Force switch again
                                    if (socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send("PointCloud");
                                        console.log('üì§ Re-sent PointCloud mode request');
                                    }
                                    
                                    const debugMsgEl = document.getElementById('debugMessage');
                                    if (debugMsgEl) debugMsgEl.textContent = 'Server masih mengirim skeleton data - mencoba switch mode lagi...';
                                }
                            }
                        } 
                        // Check if it's point cloud data but with empty array (mode active but no valid points)
                        else if (data.mode === 'PointCloud' && (!data.data || !Array.isArray(data.data))) {
                            console.warn('‚ö†Ô∏è PointCloud mode detected but data format invalid:', {
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                dataValue: data.data
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'PointCloud mode active but data format invalid';
                        }
                        // Unknown data format
                        else {
                            console.warn('‚ö†Ô∏è Unknown JSON data format received:', {
                                keys: Object.keys(data),
                                hasMode: !!data.mode,
                                mode: data.mode,
                                hasSkeletons: !!data.skeletons,
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                currentMode: currentMode,
                                fullData: JSON.stringify(data).substring(0, 200)
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'Unknown data format: ' + Object.keys(data).join(', ') + ' | Mode: ' + (data.mode || 'none');
                        }
                    } catch (e) {
                        console.error('‚ùå Error parsing JSON data:', e);
                        console.error('Raw data (first 200 chars):', event.data.substring(0, 200));
                        const debugMsgEl = document.getElementById('debugMessage');
                        if (debugMsgEl) debugMsgEl.textContent = 'Error parsing data: ' + e.message;
                    }
                }
                // Camera feed (Blob) - process in normal mode for both Color and Depth
                else if (event.data instanceof Blob && currentMode === 'normal') {
                    var url = URL.createObjectURL(event.data);
                    var img = document.getElementById('cameraImage');
                    img.src = url;
                    img.style.display = 'block';
                    document.getElementById('placeholder').style.display = 'none';
                    
                    // Revoke old URL to prevent memory leaks
                    if (img.dataset.oldUrl) {
                        URL.revokeObjectURL(img.dataset.oldUrl);
                    }
                    img.dataset.oldUrl = url;
                    
                    // Update status text based on current mode
                    const statusText = document.getElementById('statusText');
                    if (statusText) {
                        // Check if we're in depth mode by checking button state
                        const depthBtn = document.getElementById('depthBtn');
                        if (depthBtn && depthBtn.classList.contains('active')) {
                            statusText.textContent = 'Terhubung ke server - Depth Mode';
                        } else {
                            statusText.textContent = 'Terhubung ke server - Color Mode';
                        }
                    }
                }
            };
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
            updateStatus(false);
        }

        function setColorMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('Switched to Color mode');
                
                // Update button states
                const colorBtn = document.getElementById('colorBtn');
                const depthBtn = document.getElementById('depthBtn');
                if (colorBtn) colorBtn.classList.add('active');
                if (depthBtn) depthBtn.classList.remove('active');
                
                // Update status
                const statusText = document.getElementById('statusText');
                if (statusText) {
                    statusText.textContent = 'Terhubung ke server - Color Mode';
                }
            }
        }

        function setDepthMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Depth");
                console.log('Switched to Depth mode');
                
                // Update button states
                const colorBtn = document.getElementById('colorBtn');
                const depthBtn = document.getElementById('depthBtn');
                if (colorBtn) colorBtn.classList.remove('active');
                if (depthBtn) depthBtn.classList.add('active');
                
                // Update status
                const statusText = document.getElementById('statusText');
                if (statusText) {
                    statusText.textContent = 'Terhubung ke server - Depth Mode';
                }
            }
        }

        // ========== 3D Scanning Functions ==========
        
        // Initialize depth-to-mesh converter (untuk menghasilkan mesh utuh, bukan point cloud)
        let depthMeshConverter = null;
        let meshFrames = []; // Store depth frames for mesh generation
        
        // Initialize converter when page loads
        if (typeof DepthToMeshConverter !== 'undefined') {
            depthMeshConverter = new DepthToMeshConverter();
            console.log('‚úÖ Depth-to-Mesh converter initialized');
        } else {
            console.warn('‚ö†Ô∏è DepthToMeshConverter not loaded - mesh generation will use point cloud');
        }
        
        function initViewer() {
            const container = document.getElementById('viewer');
            if (!container) return;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Ukuran kanvas 3js: 400mm x 400mm (0.4m x 0.4m)
            const canvasSize = 0.4; // 400mm = 0.4m
            const maxObjectSize = 0.35; // 350mm = 0.35m (maksimal ukuran objek)
            
            // Add grid sesuai ukuran kanvas
            // Grid diposisikan di Y = 0 (di atas ground plane)
            const gridHelper = new THREE.GridHelper(canvasSize, 8); // Grid 400mm dengan 8 divisi
            gridHelper.position.y = 0; // Pastikan grid berada di Y = 0
            scene.add(gridHelper);
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(0.5); // Axes standar
            scene.add(axesHelper);
            
            // Hanya grid layout saja, tanpa kotak wireframe
            console.log('‚úÖ Grid layout created:', {
                canvasSize: canvasSize + 'm x ' + canvasSize + 'm (400mm x 400mm)',
                maxObjectSize: maxObjectSize + 'm (350mm)',
                divisions: 8
            });
            
            // Store canvas size globally untuk validasi objek
            window.canvasSize = canvasSize;
            window.maxObjectSize = maxObjectSize;
            
            // Simple orbit controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                    camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * 0.01);
                    camera.lookAt(0, 0, 0);
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const delta = e.deltaY * 0.001;
                camera.position.multiplyScalar(1 + delta);
            });
            
            animate();
        }
        
        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
        }

        // ==================== DEPTH VISUALIZATION (SKANECT STYLE) ====================
        // Initialize depth canvas for real-time depth visualization
        function initDepthCanvas() {
            depthCanvas = document.getElementById('depthCanvas');
            if (depthCanvas) {
                depthCtx = depthCanvas.getContext('2d');
                console.log('‚úÖ Depth canvas initialized');
                
                // Start FPS counter
                if (depthFpsInterval) clearInterval(depthFpsInterval);
                depthFpsInterval = setInterval(() => {
                    const fpsEl = document.getElementById('depthFps');
                    if (fpsEl) fpsEl.textContent = depthFpsCounter;
                    depthFpsCounter = 0;
                }, 1000);
            } else {
                console.warn('‚ö†Ô∏è Depth canvas not found');
            }
        }

        // Visualize depth data in real-time (Skanect-like style)
        function visualizeDepth(depthData) {
            // Throttle rendering to 30 FPS for performance
            const now = Date.now();
            if (now - lastDepthRenderTime < 33) return; // 33ms = ~30 FPS
            lastDepthRenderTime = now;

            // Initialize canvas if not done yet
            if (!depthCanvas || !depthCtx) {
                initDepthCanvas();
                if (!depthCanvas || !depthCtx) return; // Still not available
            }

            const { points, width, height } = depthData;
            if (!points || points.length === 0) return;

            // Update FPS counter
            depthFpsCounter++;

            // Update points count
            const pointsEl = document.getElementById('depthPoints');
            if (pointsEl) pointsEl.textContent = points.length.toLocaleString();

            // Create image data
            const imageData = depthCtx.createImageData(width, height);
            const pixels = imageData.data;

            // Create depth map
            const depthMap = [];
            for (let y = 0; y < height; y++) {
                depthMap[y] = new Array(width).fill(null);
            }

            // Fill depth map from point cloud
            const focalLength = 525.0;
            const centerX = width / 2;
            const centerY = height / 2;

            for (const point of points) {
                const z = Math.abs(point.z);
                if (z <= 0.001) continue;

                // Project to 2D
                const x2d = Math.round((point.x * focalLength / z) + centerX);
                const y2d = Math.round((-point.y * focalLength / z) + centerY);

                if (x2d >= 0 && x2d < width && y2d >= 0 && y2d < height) {
                    depthMap[y2d][x2d] = z;
                }
            }

            // Render with colors (GREEN = valid, RED = invalid, BLACK = no data)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const depth = depthMap[y][x];

                    if (depth === null) {
                        // No data - black
                        pixels[idx] = 20;
                        pixels[idx + 1] = 20;
                        pixels[idx + 2] = 20;
                        pixels[idx + 3] = 255;
                    } else if (depth >= depthMin && depth <= depthMax) {
                        // Valid depth - GREEN (like Skanect!)
                        pixels[idx] = 0;
                        pixels[idx + 1] = 255;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    } else {
                        // Invalid depth - RED (like Skanect!)
                        pixels[idx] = 255;
                        pixels[idx + 1] = 0;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    }
                }
            }

            depthCtx.putImageData(imageData, 0, 0);
        }

        // Update depth range settings
        function updateDepthMin(value) {
            depthMin = parseFloat(value);
            const valueEl = document.getElementById('depthMinValue');
            if (valueEl) valueEl.textContent = value;
        }

        function updateDepthMax(value) {
            depthMax = parseFloat(value);
            const valueEl = document.getElementById('depthMaxValue');
            if (valueEl) valueEl.textContent = value;
        }

        // Update mesh info display
        function updateMeshInfo(vertices, faces) {
            const verticesEl = document.getElementById('meshVertices');
            const facesEl = document.getElementById('meshFaces');
            const meshInfoEl = document.getElementById('meshInfo');
            
            if (verticesEl) verticesEl.textContent = vertices.toLocaleString();
            if (facesEl) facesEl.textContent = Math.floor(faces).toLocaleString();
            
            if (meshInfoEl) {
                if (vertices > 0) {
                    meshInfoEl.textContent = `${vertices.toLocaleString()} vertices, ${Math.floor(faces).toLocaleString()} faces`;
                } else {
                    meshInfoEl.textContent = 'No mesh loaded';
                }
            }
        }

        // Update scan status with proper class (Skanect-like)
        function updateScanStatus(statusClass, statusText) {
            const statusEl = document.getElementById('scanStatus');
            if (statusEl) {
                // Remove all status classes
                statusEl.classList.remove('idle', 'scanning', 'processing', 'ready');
                // Add new status class
                if (statusClass) {
                    statusEl.classList.add(statusClass);
                }
                // Update text
                statusEl.textContent = statusText;
            }
        }
        
        function processPointCloud(data) {
            // üî• CRITICAL: Check if capture is still active - stop processing if not
            if (!isCaptureActive) {
                console.log('‚è∏Ô∏è Capture stopped - ignoring point cloud data');
                return;
            }
            
            // üî• THROTTLING: Skip if processing too frequently (prevent freeze)
            const now = Date.now();
            if (now - lastProcessTime < processingThrottle) {
                console.log('‚è≠Ô∏è Skipping frame (throttle) - too fast');
                return;
            }
            lastProcessTime = now;

            if (!data || !data.points || !Array.isArray(data.points)) {
                console.warn('‚ö†Ô∏è Invalid point cloud data:', data);
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Error: Invalid point cloud data format';
                return;
            }

            // Log even if empty to help debugging
            console.log('üîç Processing', data.points.length, 'points (Frame #' + frameCount + ')');

            if (data.points.length === 0) {
                console.warn('‚ö†Ô∏è Received empty point cloud - mungkin objek tidak terdeteksi atau terlalu jauh/dekat');
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Warning: Empty point cloud - pastikan objek dalam range 0.85-4 meter';
                // Still increment frame count to show that we're receiving data
                frameCount++;
                updateStats();
                return;
            }
            
            const maxPoints = parseInt(document.getElementById('maxPointsSlider').value);
            let newPoints = data.points.slice(0, Math.min(data.points.length, maxPoints));
            
            if (newPoints.length === 0) {
                frameCount++;
                updateStats();
                return;
            }
            
            // Validate point structure
            const firstPoint = newPoints[0];
            if (!firstPoint || !firstPoint.hasOwnProperty('x') || !firstPoint.hasOwnProperty('y') || !firstPoint.hasOwnProperty('z')) {
                console.error('‚ùå Invalid point structure:', firstPoint);
                return;
            }
            
            // ICP dan Noise Filtering dihapus karena membuat objek tidak karuan
            // Langsung ke filtering colored objects
            
            // Update Kinect position estimate (for future tracking)
            if (pointCloud.length === 0) {
                kinectPosition = pointCloudProcessor.estimateKinectPosition(newPoints);
            }
            
            // Filter menggunakan depth camera untuk menangkap objek 3D anggota tubuh
            // Objek dekat (anggota tubuh) akan berwarna merah/oranye, background jauh akan abu-abu/hitam
            // Only apply filter if we have enough points to filter effectively
            let humanBodyPoints = newPoints;
            if (newPoints.length > 100) {
                try {
                    // Filter berdasarkan depth - seperti depth map dengan warna
                    // Objek dekat (0.85-2.5m) = anggota tubuh, background jauh (>2.5m) = dihilangkan
                    humanBodyPoints = filterDepthBasedBodyParts(newPoints);
                    // If filter removed too many points (>80%), use original points
                    if (humanBodyPoints.length < newPoints.length * 0.2) {
                        console.warn('‚ö†Ô∏è Filter too aggressive, using original points');
                        humanBodyPoints = newPoints;
                    }
                } catch (err) {
                    console.error('‚ùå Filter error, using original points:', err);
                    humanBodyPoints = newPoints;
                }
            }
            
            // CRITICAL: Remove duplicate/overlapping points to prevent layering
            // Use voxel-based deduplication for better results
            const beforeDedup = humanBodyPoints.length;
            humanBodyPoints = removeDuplicatePoints(humanBodyPoints, pointCloud);
            
            // Optional: Apply temporal filtering for additional stability (can be enabled)
            // This helps reduce noise and layering from frame-to-frame variations
            // humanBodyPoints = applyTemporalFiltering(humanBodyPoints, pointCloudFrames);
            
            console.log('üìä Deduplication: ' + beforeDedup + ' ‚Üí ' + humanBodyPoints.length + ' points');
            
            // Add filtered and deduplicated points to point cloud
            pointCloud.push(...humanBodyPoints);
            frameCount++;

            const addedCount = humanBodyPoints.length;
            const duplicatesRemoved = beforeDedup - addedCount;
            console.log('‚úÖ Added ' + addedCount + ' points (from ' + newPoints.length + ', duplicates removed: ' + duplicatesRemoved + '). Total: ' + pointCloud.length.toLocaleString());

            // Update display and stats (throttled)
            requestAnimationFrame(() => {
                const now = Date.now();
                if (now - lastRenderTime >= renderThrottle) {
                    updatePointCloudDisplay();
                    // Center model more frequently to keep it visible
                    setTimeout(() => centerModel(), 100);
                    lastRenderTime = now;
                }
                updateStats();
            });
            
            console.log('‚úÖ‚úÖ‚úÖ Successfully added', newPoints.length, 'points. Total:', pointCloud.length, 'points from', frameCount, 'frames');
            
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) {
                const duplicatesRemoved = newPoints.length - humanBodyPoints.length;
                debugMsgEl.textContent = `‚úÖ Added ${humanBodyPoints.length} points (removed ${duplicatesRemoved} duplicates/background). Total: ${pointCloud.length} points`;
            }
        }
        
        /**
         * Process depth frame as mesh directly (seperti Skanect)
         * Menghasilkan mesh utuh, bukan point cloud terpisah
         */
        function processDepthFrameAsMesh(payload, width, height) {
            if (!depthMeshConverter || !payload || !payload.points) {
                console.warn('‚ö†Ô∏è Cannot process as mesh - falling back to point cloud');
                processPointCloud(payload);
                return;
            }
            
            console.log('üî∑ Processing depth frame as mesh (utuh, bukan point cloud)...');
            
            // Store frame for accumulation
            meshFrames.push({
                points: payload.points,
                width: width || 320,
                height: height || 240
            });
            
            // Limit frames to prevent memory issues (keep last 10 frames)
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }
            
            // Generate mesh from accumulated frames
            // This creates a continuous surface, not separate points
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);
            
            if (geometry) {
                // Remove old mesh if exists
                const oldMesh = scene.getObjectByName('depthMesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Create mesh material with vertex colors
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // Create mesh object
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'depthMesh';
                
                // Posisikan mesh di atas grid (Y >= 0)
                const box = new THREE.Box3().setFromObject(mesh);
                if (!box.isEmpty()) {
                    const boxMin = box.min;
                    const yOffset = -boxMin.y; // Offset untuk memindahkan mesh ke Y = 0
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Pastikan mesh selalu berada di atas grid (Y >= 0)
                    const finalY = Math.max(0, yOffset);
                    mesh.position.set(
                        -center.x, // Center X
                        finalY, // Di atas grid (Y >= 0)
                        -center.z  // Center Z
                    );
                    mesh.updateMatrixWorld(); // Update matrix setelah positioning
                }
                
                // Add to scene
                scene.add(mesh);
                
                // Hide point cloud if mesh is shown
                const pointCloudObj = scene.getObjectByName('pointCloud');
                if (pointCloudObj) {
                    pointCloudObj.visible = false;
                }
                
                // Update stats
                const pointCountEl = document.getElementById('pointCount');
                if (pointCountEl) {
                    pointCountEl.textContent = geometry.attributes.position.count.toLocaleString() + ' vertices';
                }
                
                // Center camera
                setTimeout(() => centerModel(), 100);
                
                console.log('‚úÖ Mesh updated:', {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0
                });
            } else {
                console.warn('‚ö†Ô∏è Failed to generate mesh, falling back to point cloud');
                processPointCloud(payload);
            }
        }
        
        /**
         * Process depth frame as mesh directly (seperti Skanect)
         * Menghasilkan mesh utuh, bukan point cloud terpisah
         */
        function processDepthFrameAsMesh(payload, width, height) {
            if (!depthMeshConverter || !payload || !payload.points) {
                console.warn('‚ö†Ô∏è Cannot process as mesh - falling back to point cloud');
                processPointCloud(payload);
                return;
            }
            
            console.log('üî∑ Processing depth frame as mesh (utuh, bukan point cloud)...');
            
            // Store frame for accumulation
            meshFrames.push({
                points: payload.points,
                width: width || 320,
                height: height || 240
            });
            
            // Limit frames to prevent memory issues (keep last 10 frames)
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }
            
            // Generate mesh from accumulated frames
            // This creates a continuous surface, not separate points
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);
            
            if (geometry) {
                // Remove old mesh if exists
                const oldMesh = scene.getObjectByName('depthMesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Create mesh material with vertex colors
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // Create mesh object
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'depthMesh';
                
                // Validasi ukuran mesh: tidak boleh lebih besar dari 350mm (0.35m)
                const maxObjectSize = window.maxObjectSize || 0.35; // 350mm
                const box = new THREE.Box3().setFromObject(mesh);
                if (!box.isEmpty()) {
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    
                    let scaleFactor = 1.0;
                    if (maxDim > maxObjectSize) {
                        scaleFactor = maxObjectSize / maxDim;
                        console.warn('‚ö†Ô∏è Depth mesh terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm (scale: ' + scaleFactor.toFixed(3) + ')');
                        mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        // Recalculate box after scaling
                        box.setFromObject(mesh);
                    }
                    
                    const boxMin = box.min;
                    const yOffset = -boxMin.y; // Offset untuk memindahkan mesh ke Y = 0
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Pastikan mesh selalu berada di atas grid (Y >= 0)
                    const finalY = Math.max(0, yOffset);
                    mesh.position.set(
                        -center.x, // Center X
                        finalY, // Di atas grid (Y >= 0)
                        -center.z  // Center Z
                    );
                    mesh.updateMatrixWorld(); // Update matrix setelah positioning
                }
                
                // Add to scene
                scene.add(mesh);
                
                // Hide point cloud if mesh is shown
                const pointCloudObj = scene.getObjectByName('pointCloud');
                if (pointCloudObj) {
                    pointCloudObj.visible = false;
                }
                
                // Update stats
                const pointCountEl = document.getElementById('pointCount');
                if (pointCountEl) {
                    pointCountEl.textContent = geometry.attributes.position.count.toLocaleString() + ' vertices';
                }
                
                // Center camera
                setTimeout(() => centerModel(), 100);
                
                console.log('‚úÖ Mesh updated:', {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0
                });
            } else {
                console.warn('‚ö†Ô∏è Failed to generate mesh, falling back to point cloud');
                processPointCloud(payload);
            }
        }
        
        function updatePointCloudDisplay() {
            if (!scene) {
                console.warn('Scene not initialized');
                return;
            }
            
            const oldPointCloud = scene.getObjectByName('pointCloud');
            if (oldPointCloud) {
                scene.remove(oldPointCloud);
            }
            
            if (pointCloud.length === 0) {
                console.log('No points to display');
                return;
            }
            
            console.log('Updating point cloud display with', pointCloud.length, 'points');
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCloud.length * 3);
            const colors = new Float32Array(pointCloud.length * 3);
            
            // Calculate bounds for camera positioning
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < pointCloud.length; i++) {
                const point = pointCloud[i];
                const x = point.x || 0;
                const y = point.y || 0;
                const z = point.z || 0;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                colors[i * 3] = (point.r || 128) / 255;
                colors[i * 3 + 1] = (point.g || 128) / 255;
                colors[i * 3 + 2] = (point.b || 128) / 255;
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }
            
            console.log('Point cloud bounds:', {
                x: [minX, maxX],
                y: [minY, maxY],
                z: [minZ, maxZ]
            });
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.02, // Increased size for better visibility
                vertexColors: true,
                sizeAttenuation: false
            });
            
            const pointsObj = new THREE.Points(geometry, material);
            pointsObj.name = 'pointCloud';
            scene.add(pointsObj);
            
            // Validasi ukuran objek: tidak boleh lebih besar dari 350mm (0.35m)
            const maxObjectSize = window.maxObjectSize || 0.35; // 350mm
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);
            
            let scaleFactor = 1.0;
            if (maxDim > maxObjectSize) {
                scaleFactor = maxObjectSize / maxDim;
                console.warn('‚ö†Ô∏è Point cloud terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm (scale: ' + scaleFactor.toFixed(3) + ')');
                pointsObj.scale.set(scaleFactor, scaleFactor, scaleFactor);
            }
            
            // Posisikan objek di atas grid (Y = 0 atau sedikit di atas)
            // Hitung offset Y agar objek berada di atas grid, bukan mengambang
            const yOffset = -minY; // Offset untuk memindahkan objek ke Y = 0 (di atas grid)
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            
            // Apply position dengan offset agar objek di atas grid
            // Pastikan objek selalu berada di atas grid (Y >= 0)
            const finalY = Math.max(0, (window.objectPosition ? window.objectPosition.y : 0) + yOffset);
            pointsObj.position.set(
                (window.objectPosition ? window.objectPosition.x : 0) - centerX, // Center X
                finalY, // Di atas grid (Y >= 0)
                (window.objectPosition ? window.objectPosition.z : 0) - centerZ  // Center Z
            );
            pointsObj.updateMatrixWorld(); // Update matrix setelah positioning
            
            // Bounding box dihilangkan - objek pure di atas kanvas
            
            // Center and fit the point cloud immediately after adding
            // This ensures it's always visible
            setTimeout(() => {
                centerModel();
            }, 50);
        }
        
        /**
         * Bounding box dihilangkan - objek pure di atas kanvas tanpa kotak wireframe
         */
        function updateBoundingBox(minX, maxX, minY, maxY, minZ, maxZ) {
            // Bounding box dihilangkan sesuai permintaan user
            // Hapus bounding box jika ada
            if (!scene) return;
            const oldBoundingBox = scene.getObjectByName('boundingBox');
            if (oldBoundingBox) {
                scene.remove(oldBoundingBox);
            }
        }
        
        function startScan() {
            console.log('üîµüîµüîµ startScan() called - SIMPLIFIED MODE üîµüîµüîµ');

            if (!connected) {
                alert('Harus terhubung ke server terlebih dahulu!');
                console.error('‚ùå Cannot start scan: not connected');
                return;
            }

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif! Silakan hubungkan terlebih dahulu.');
                console.error('‚ùå Cannot start scan: WebSocket not open');
                return;
            }

            // Check if multi-phase mode is enabled
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox')?.checked || false;
            
            if (isMultiPhaseMode) {
                // Multi-phase mode: Phase 1 (depan)
                scanPhase = 1;
                pointCloudFront = [];
                pointCloudBack = [];
                pointCloud = []; // Reset current point cloud
                console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 1 (Depan/Front)');
                console.log('üìå Duration: 15 seconds');
            } else {
                // Normal mode: single scan
                scanPhase = 0;
                pointCloud = [];
                console.log('üöÄ Starting REAL-TIME CAPTURE (6 seconds or until ' + maxTotalPoints.toLocaleString() + ' points)...');
                console.log('üìå Mode: Simplified auto-capture');
                console.log('üìå Duration: 6 seconds (5-7 detik untuk banyak frame)');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());
            }

            // Reset data
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();

            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;

            // Auto-stop timer - different duration for multi-phase vs normal
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
            const currentDuration = isMultiPhaseMode ? phaseDuration : scanDuration;
            autoCaptureTimer = setTimeout(() => {
                console.log('‚è±Ô∏è ' + (currentDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                console.log('üìä Final point count:', pointCloud.length.toLocaleString());
                if (isMultiPhaseMode && scanPhase === 1) {
                    // Phase 1 complete, save to pointCloudFront
                    pointCloudFront = [...pointCloud];
                    console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                    stopCapture();
                    // Show button for Phase 2
                    document.getElementById('startPhase2Btn').style.display = 'inline-block';
                    document.getElementById('startPhase2Btn').disabled = false;
                    updateScanStatus('ready', 'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2"');
                } else {
                    stopCapture();
                }
            }, currentDuration);
            
            // Get settings
            // ICP dan Noise Filtering dihapus karena membuat objek tidak karuan
            useICP = false;
            useNoiseFilter = false;
            
            // Clear any existing timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = isMultiPhaseMode ? 'Scanning Fase 1...' : 'Scanning...';
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('clearBtn').disabled = false;
            updateScanStatus('scanning', isMultiPhaseMode ? 'Scanning Fase 1 (Depan)...' : 'Scanning...');
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            if (isMultiPhaseMode) {
                document.getElementById('currentPhase').textContent = 'Fase 1: Depan';
            }
            
            // Send PointCloud mode request directly and multiple times to ensure server receives it
            console.log('üîÑ Switching server mode to PointCloud...');
            
            // Send immediately
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request to server (attempt 1)');
            
            // Send multiple times with delays to ensure server processes it
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 2)');
                }
            }, 50);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 3)');
                }
            }, 150);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 4)');
                }
            }, 300);
            
            // Start progress bar update timer
            scanTimer = setInterval(() => {
                if (!isScanning) {
                    clearInterval(scanTimer);
                    return;
                }
                
                const elapsed = Date.now() - scanStartTime;
                const progress = Math.min(100, (elapsed / scanDuration) * 100);
                
                const progressFillEl = document.getElementById('progressFill');
                if (progressFillEl) {
                    progressFillEl.style.width = progress + '%';
                    progressFillEl.textContent = Math.round(progress) + '%';
                }
                
                // Auto-stop after scan duration
                if (elapsed >= scanDuration) {
                    console.log('‚è±Ô∏è Scan duration completed, stopping automatically...');
                    stopScan();
                }
            }, 50); // Update every 50ms for smooth progress bar
            
            // Update debug message
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) debugMsgEl.textContent = 'Waiting for PointCloud data from server...';
        }
        
        /**
         * Toggle multi-phase mode on/off
         */
        function toggleMultiPhaseMode() {
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox').checked;
            const phaseInfoEl = document.getElementById('phaseInfo');
            if (phaseInfoEl) {
                phaseInfoEl.style.display = isMultiPhaseMode ? 'block' : 'none';
            }
            
            if (isMultiPhaseMode) {
                console.log('üîÑ Multi-phase mode ENABLED');
                document.getElementById('currentPhase').textContent = 'Belum dimulai';
            } else {
                console.log('üîÑ Multi-phase mode DISABLED');
                scanPhase = 0;
            }
        }
        
        /**
         * Start Phase 2 (belakang/back) scanning
         */
        function startPhase2() {
            if (!connected || !socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif!');
                return;
            }
            
            if (pointCloudFront.length === 0) {
                alert('Fase 1 belum selesai atau tidak ada data!');
                return;
            }
            
            console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 2 (Belakang/Back)');
            console.log('üìå Duration: 15 seconds');
            console.log('üìå Phase 1 points: ' + pointCloudFront.length.toLocaleString());
            
            // Set phase 2
            scanPhase = 2;
            pointCloudBack = [];
            pointCloud = []; // Reset current point cloud for phase 2
            
            // Reset counters
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();
            
            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;
            
            // Auto-stop after phaseDuration (15 seconds)
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
            autoCaptureTimer = setTimeout(() => {
                console.log('‚è±Ô∏è Phase 2 (15 seconds) elapsed - auto-stopping capture');
                pointCloudBack = [...pointCloud];
                console.log('‚úÖ Phase 2 (Belakang) complete: ' + pointCloudBack.length.toLocaleString() + ' points');
                
                // Merge both phases
                mergePhasePointClouds();
                
                stopCapture();
            }, phaseDuration);
            
            // Update UI
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = 'Scanning Fase 2...';
            document.getElementById('stopScanBtn').disabled = false;
            updateScanStatus('scanning', 'Scanning Fase 2 (Belakang)...');
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            document.getElementById('currentPhase').textContent = 'Fase 2: Belakang';
            
            // Send PointCloud mode request
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request for Phase 2');
        }
        
        /**
         * Merge point clouds from Phase 1 (depan) and Phase 2 (belakang)
         * Uses ICP alignment for accurate registration
         * Combines both point clouds into one complete 3D object
         */
        function mergePhasePointClouds() {
            console.log('üîó Merging point clouds from Phase 1 and Phase 2 with ICP alignment...');
            console.log('üìä Phase 1 (Depan): ' + pointCloudFront.length.toLocaleString() + ' points');
            console.log('üìä Phase 2 (Belakang): ' + pointCloudBack.length.toLocaleString() + ' points');
            
            if (pointCloudFront.length === 0 && pointCloudBack.length === 0) {
                console.warn('‚ö†Ô∏è No points to merge!');
                return;
            }
            
            // If only one phase has data, use it directly
            if (pointCloudFront.length === 0) {
                pointCloud = [...pointCloudBack];
                console.log('‚ö†Ô∏è Only Phase 2 data available');
            } else if (pointCloudBack.length === 0) {
                pointCloud = [...pointCloudFront];
                console.log('‚ö†Ô∏è Only Phase 1 data available');
            } else {
                // Both phases have data - perform ICP alignment
                console.log('üîÑ Performing ICP alignment for multi-phase registration...');
                
                // Step 1: Initial alignment - rotate back point cloud 180¬∞ around Y-axis
                // This assumes the object was rotated 180¬∞ between phases
                const rotatedBack = pointCloudBack.map(p => ({
                    x: -p.x,  // Flip X (rotate 180¬∞ around Y)
                    y: p.y,   // Keep Y (vertical axis)
                    z: -p.z,  // Flip Z (rotate 180¬∞ around Y)
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                console.log('‚úÖ Applied initial 180¬∞ rotation to Phase 2');
                
                // Step 2: Center both point clouds for better alignment
                const frontCenter = calculateCentroid(pointCloudFront);
                const backCenter = calculateCentroid(rotatedBack);
                
                const centeredFront = pointCloudFront.map(p => ({
                    x: p.x - frontCenter.x,
                    y: p.y - frontCenter.y,
                    z: p.z - frontCenter.z,
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                const centeredBack = rotatedBack.map(p => ({
                    x: p.x - backCenter.x,
                    y: p.y - backCenter.y,
                    z: p.z - backCenter.z,
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                // Step 3: Perform ICP alignment
                console.log('üîÑ Running ICP algorithm...');
                const icpResult = pointCloudProcessor.icpAlign(
                    centeredBack,
                    centeredFront,
                    50,  // maxIterations
                    0.01  // tolerance (1cm)
                );
                
                if (icpResult.transform) {
                    console.log('‚úÖ ICP alignment successful');
                    
                    // Step 4: Apply ICP transform and restore original positions
                    const alignedBack = icpResult.alignedPoints.map(p => ({
                        x: p.x + frontCenter.x, // Restore to front center position
                        y: p.y + frontCenter.y,
                        z: p.z + frontCenter.z,
                        r: p.r,
                        g: p.g,
                        b: p.b
                    }));
                    
                    // Step 5: Merge aligned point clouds with overlap removal
                    pointCloud = mergeWithOverlapRemoval(pointCloudFront, alignedBack, 0.02); // 2cm overlap threshold
                    
                    console.log('‚úÖ Merged with ICP: ' + pointCloud.length.toLocaleString() + ' points (removed ' + 
                        (pointCloudFront.length + pointCloudBack.length - pointCloud.length).toLocaleString() + ' duplicates)');
                } else {
                    console.warn('‚ö†Ô∏è ICP alignment failed, using simple merge');
                    // Fallback: simple merge with initial rotation
                    pointCloud = [...pointCloudFront, ...rotatedBack];
                }
            }
            
            console.log('‚úÖ Final merged point cloud: ' + pointCloud.length.toLocaleString() + ' points total');
            
            // Update display
            updatePointCloudDisplay();
            centerModel();
            
            // Update UI
            updateScanStatus('ready', 
                'Scan selesai! ' + pointCloud.length.toLocaleString() + ' points (Depan: ' + 
                pointCloudFront.length.toLocaleString() + ', Belakang: ' + 
                pointCloudBack.length.toLocaleString() + ')');
            document.getElementById('pointCount').textContent = pointCloud.length.toLocaleString();
            document.getElementById('generateWatertightBtn').disabled = false;
            document.getElementById('exportSTLBtn').disabled = false;
            document.getElementById('currentPhase').textContent = 'Selesai - Objek 3D Utuh';
        }
        
        /**
         * Calculate centroid of point cloud
         */
        function calculateCentroid(points) {
            if (points.length === 0) return { x: 0, y: 0, z: 0 };
            
            let sumX = 0, sumY = 0, sumZ = 0;
            for (const p of points) {
                sumX += p.x;
                sumY += p.y;
                sumZ += p.z;
            }
            
            return {
                x: sumX / points.length,
                y: sumY / points.length,
                z: sumZ / points.length
            };
        }
        
        /**
         * Merge two point clouds with overlap removal using voxel-based deduplication
         */
        function mergeWithOverlapRemoval(points1, points2, voxelSize = 0.02) {
            const merged = [...points1];
            const voxelMap = new Map();
            
            // Add points1 to voxel map
            points1.forEach(p => {
                const gx = Math.floor(p.x / voxelSize);
                const gy = Math.floor(p.y / voxelSize);
                const gz = Math.floor(p.z / voxelSize);
                const key = `${gx},${gy},${gz}`;
                voxelMap.set(key, true);
            });
            
            // Add points2 only if voxel is empty
            points2.forEach(p => {
                const gx = Math.floor(p.x / voxelSize);
                const gy = Math.floor(p.y / voxelSize);
                const gz = Math.floor(p.z / voxelSize);
                const key = `${gx},${gy},${gz}`;
                
                if (!voxelMap.has(key)) {
                    merged.push(p);
                    voxelMap.set(key, true);
                }
            });
            
            return merged;
        }
        
        function stopCapture() {
            console.log('üõë Stopping capture...');
            isCaptureActive = false;
            isScanning = false;

            // Clear timers
            if (autoCaptureTimer) {
                clearTimeout(autoCaptureTimer);
                autoCaptureTimer = null;
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop point cloud data');
            }

            // Handle multi-phase mode
            if (isMultiPhaseMode && scanPhase === 1) {
                // Phase 1 complete - save to pointCloudFront
                pointCloudFront = [...pointCloud];
                console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                
                // Update UI for Phase 2
                document.getElementById('startPhase2Btn').style.display = 'inline-block';
                document.getElementById('startPhase2Btn').disabled = false;
                updateScanStatus('ready', 
                    'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2" (' + 
                    pointCloudFront.length.toLocaleString() + ' points)');
                document.getElementById('currentPhase').textContent = 'Fase 1 selesai - Menunggu Fase 2';
                
                // Reset UI buttons
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
                document.getElementById('stopScanBtn').disabled = true;
                
                return; // Don't enable mesh/export yet - wait for Phase 2
            } else if (isMultiPhaseMode && scanPhase === 2) {
                // Phase 2 complete - already merged in timeout handler
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
                document.getElementById('stopScanBtn').disabled = true;
                return;
            }

            // Normal mode or both phases complete
            // Update UI
            updateScanStatus('ready', pointCloud.length > 0 ?
                'Capture stopped - ' + pointCloud.length.toLocaleString() + ' points collected' :
                'Capture stopped - No data');

            // Enable buttons if we have points
            if (pointCloud.length > 0) {
                document.getElementById('generateWatertightBtn').disabled = false;
                document.getElementById('exportSTLBtn').disabled = false; // Enable export even without mesh
                console.log('‚úÖ Capture stopped. Total: ' + pointCloud.length.toLocaleString() + ' points from ' + frameCount + ' frames');

                // Auto-center the point cloud
                centerModel();
            }
            
            // Reset UI buttons
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
            document.getElementById('stopScanBtn').disabled = true;
        }

        function stopScan() {
            if (!isScanning) return; // Already stopped

            console.log('üõë Stopping scan...');
            isScanning = false;
            stopCapture();
            
            // Clear timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'Mulai Scan';
            updateScanStatus('ready', pointCloud.length > 0 ? 'Selesai - Siap untuk Generate Watertight' : 'Selesai - Tidak ada data');
            
            // Set progress to 100%
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '100%';
                progressFillEl.textContent = '100%';
            }
            
            // Log statistics
            console.log('üìä Scan Statistics:', {
                totalDataReceived: dataReceivedDuringScan,
                pointCloudDataReceived: pointCloudDataReceived,
                skeletonDataReceived: dataReceivedDuringScan - pointCloudDataReceived,
                pointsCollected: pointCloud.length,
                framesProcessed: frameCount
            });
            
            // Enable generate mesh button if we have points
            if (pointCloud.length > 0) {
                document.getElementById('generateWatertightBtn').disabled = false;
                console.log('‚úÖ Scan completed with', pointCloud.length, 'points from', frameCount, 'frames');
            } else {
                console.warn('‚ö†Ô∏è Scan completed but no points collected');
                
                // Provide detailed error message based on what we received
                let errorMsg = 'Scanning selesai tapi tidak ada data yang terkumpul.\n\n';
                
                if (dataReceivedDuringScan === 0) {
                    errorMsg += '‚ùå MASALAH: Server TIDAK mengirim data sama sekali!\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Pastikan server.exe berjalan\n';
                    errorMsg += '2. Restart server.exe\n';
                    errorMsg += '3. Cek apakah Kinect terhubung dan terdeteksi\n';
                    errorMsg += '4. Tampilkan console server untuk lihat error:\n';
                    errorMsg += '   - Edit source/Program.cs line 26\n';
                    errorMsg += '   - Ganti CONSOLE_HIDE menjadi CONSOLE_SHOW\n';
                    errorMsg += '   - Recompile server\n';
                } else if (pointCloudDataReceived === 0) {
                    errorMsg += '‚ùå MASALAH: Server mengirim data tapi BUKAN point cloud!\n\n';
                    errorMsg += 'Server mengirim ' + (dataReceivedDuringScan - pointCloudDataReceived) + ' skeleton data.\n';
                    errorMsg += 'Server TIDAK switch ke PointCloud mode.\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Restart server.exe\n';
                    errorMsg += '2. Pastikan server support PointCloud mode\n';
                    errorMsg += '3. Cek console server untuk error\n';
                } else {
                    errorMsg += '‚ö†Ô∏è Server mengirim ' + pointCloudDataReceived + ' frame point cloud, tapi semua kosong.\n\n';
                    errorMsg += 'Pastikan:\n';
                    errorMsg += '- Objek berada dalam range 0.85-4 meter dari Kinect\n';
                    errorMsg += '- Objek cukup besar dan jelas\n';
                    errorMsg += '- Lighting cukup\n';
                    errorMsg += '- Objek tidak transparan atau reflektif\n';
                }
                
                alert(errorMsg);
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched back to Color mode');
            }
        }
        
        function generateWatertight() {
            if (pointCloud.length === 0) {
                alert('Tidak ada point cloud untuk di-generate mesh! Silakan lakukan scanning terlebih dahulu.');
                return;
            }

            if (pointCloud.length < 3) {
                alert('Point cloud terlalu sedikit! Minimal 3 points diperlukan untuk membuat mesh.');
                return;
            }

            console.log('üîß Generating mesh from', pointCloud.length.toLocaleString(), 'points...');

            // CRITICAL: Stop receiving data during mesh generation to prevent connection errors
            const wasCaptureActive = isCaptureActive;
            isCaptureActive = false;
            
            // Switch to Color mode to stop point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop data during mesh generation');
            }

            // CRITICAL: Downsample if too many points (prevent freeze)
            let meshPoints = pointCloud;
            const maxMeshPoints = 100000; // Increased for better quality mesh

            if (pointCloud.length > maxMeshPoints) {
                console.log('‚ö†Ô∏è Too many points (' + pointCloud.length.toLocaleString() + ') - downsampling to ' + maxMeshPoints.toLocaleString());
                // Use uniform sampling instead of skip factor for better quality
                const step = pointCloud.length / maxMeshPoints;
                meshPoints = [];
                for (let i = 0; i < pointCloud.length; i += step) {
                    const idx = Math.floor(i);
                    if (idx < pointCloud.length) {
                        meshPoints.push(pointCloud[idx]);
                    }
                }
                console.log('‚úÖ Downsampled to ' + meshPoints.length.toLocaleString() + ' points using uniform sampling');

                // Don't show alert for better UX
            }

            // Apply aggressive background filter to mesh points - HILANGKAN SEMUA BACKGROUND
            console.log('üîç Filtering background from mesh points (aggressive mode - hilangkan semua background)...');
            const beforeFilter = meshPoints.length;
            // Gunakan filter depth-based untuk menghilangkan background
            meshPoints = filterDepthBasedBodyParts(meshPoints);
            console.log('‚úÖ Background filter: ' + beforeFilter + ' ‚Üí ' + meshPoints.length + ' points (background dihilangkan)');
            
            if (meshPoints.length < 100) {
                console.warn('‚ö†Ô∏è Too few points after filtering, using less aggressive filter');
                // Tetap gunakan depth-based filter (tapi dengan range lebih luas)
                const lessAggressiveFiltered = meshPoints.filter(p => {
                    const dist = Math.abs(p.z || 0);
                    return dist >= 0.85 && dist <= 3.0; // Range lebih luas
                });
                if (lessAggressiveFiltered.length > 50) {
                    meshPoints = lessAggressiveFiltered;
                }
            }

            document.getElementById('generateWatertightBtn').disabled = true;
            document.getElementById('generateWatertightBtn').textContent = 'Generating Watertight... (' + meshPoints.length.toLocaleString() + ' pts)';
            updateScanStatus('processing', 'Generating watertight mesh from ' + meshPoints.length.toLocaleString() + ' points...');

            // Use Web Worker-like approach with chunked processing to prevent freeze
            const processMeshAsync = () => {
                try {
                    console.log('üîß Starting mesh creation (chunked async)...');
                    const startTime = Date.now();
                    
                    // Process mesh in chunks using requestIdleCallback or setTimeout
                    let progress = 0;
                    
                    const updateProgress = (p) => {
                        progress = p;
                        const progressPercent = Math.round(p * 100);
                        updateScanStatus('processing', 
                            'Generating watertight mesh... ' + progressPercent + '%');
                    };
                    
                    // Use setTimeout to break up work
                    setTimeout(() => {
                        updateProgress(0.2);
                        
                        setTimeout(() => {
                            updateProgress(0.5);
                            
                            setTimeout(() => {
                                updateProgress(0.8);
                                
                                setTimeout(() => {
                                    try {
                                        updateProgress(0.9);
                                        
                                        // Create watertight mesh (this is the heavy operation)
                                        // Watertight mesh mengisi lubang dan membuat objek utuh
                                        mesh = createWatertightMesh(meshPoints);
                                        
                                        updateProgress(1.0);
                                        
                                        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
                                        console.log('‚úÖ Watertight mesh generation completed in ' + elapsedTime + ' seconds');

                                        const oldMesh = scene.getObjectByName('mesh');
                                        if (oldMesh) {
                                            scene.remove(oldMesh);
                                        }

                                        // Also hide point cloud when showing mesh
                                        const oldPointCloud = scene.getObjectByName('pointCloud');
                                        if (oldPointCloud) {
                                            oldPointCloud.visible = false;
                                        }

                                        if (mesh) {
                                            mesh.name = 'mesh';
                                            scene.add(mesh);
                                            console.log('‚úÖ Mesh added to scene successfully');

                                            // Calculate bounds from meshPoints untuk positioning
                                            let meshMinX = Infinity, meshMaxX = -Infinity;
                                            let meshMinY = Infinity, meshMaxY = -Infinity;
                                            let meshMinZ = Infinity, meshMaxZ = -Infinity;
                                            
                                            for (let i = 0; i < meshPoints.length; i++) {
                                                const p = meshPoints[i];
                                                meshMinX = Math.min(meshMinX, p.x || 0);
                                                meshMaxX = Math.max(meshMaxX, p.x || 0);
                                                meshMinY = Math.min(meshMinY, p.y || 0);
                                                meshMaxY = Math.max(meshMaxY, p.y || 0);
                                                meshMinZ = Math.min(meshMinZ, p.z || 0);
                                                meshMaxZ = Math.max(meshMaxZ, p.z || 0);
                                            }
                                            
                                            // Posisikan mesh di atas grid (Y = 0 atau sedikit di atas)
                                            // Center X dan Z, posisikan Y di atas grid
                                            const meshCenterX = (meshMinX + meshMaxX) / 2;
                                            const meshCenterZ = (meshMinZ + meshMaxZ) / 2;
                                            const meshYOffset = -meshMinY; // Offset untuk memindahkan mesh ke Y = 0 (di atas grid)
                                            
                                            // Apply position dengan offset agar mesh di atas grid
                                            // Pastikan mesh selalu berada di atas grid (Y >= 0)
                                            const finalY = Math.max(0, (window.objectPosition ? window.objectPosition.y : 0) + meshYOffset);
                                            mesh.position.set(
                                                (window.objectPosition ? window.objectPosition.x : 0) - meshCenterX, // Center X
                                                finalY, // Di atas grid (Y >= 0)
                                                (window.objectPosition ? window.objectPosition.z : 0) - meshCenterZ  // Center Z
                                            );

                                            // Force update matrix before centering
                                            mesh.updateMatrixWorld();
                                            
                                            // Bounding box dihilangkan - objek pure di atas kanvas
                                            
                                            // Auto-center the mesh with delay to ensure it's rendered
                                            setTimeout(() => {
                                                centerModel();
                                                // Center again after a short delay to ensure it's correct
                                                setTimeout(() => centerModel(), 200);
                                            }, 100);

                                            // Update mesh info
                                            if (mesh && mesh.geometry) {
                                                const vertexCount = mesh.geometry.attributes.position.count;
                                                const faceCount = mesh.geometry.index ? mesh.geometry.index.count / 3 : 0;
                                                updateMeshInfo(vertexCount, faceCount);
                                            }

                                            // Update UI
                                            updateScanStatus('ready', 'Watertight mesh generated successfully in ' + elapsedTime + 's');
                                            document.getElementById('exportSTLBtn').disabled = false;

                                            alert('‚úÖ Watertight mesh berhasil dibuat!\n\n' +
                                                  'Points: ' + meshPoints.length.toLocaleString() + '\n' +
                                                  'Time: ' + elapsedTime + ' seconds\n\n' +
                                                  'Lubang telah diisi dan objek menjadi utuh.\n' +
                                                  'Background telah di-filter dari mesh.\n' +
                                                  'Objek telah diposisikan di tengah-atas kanvas.');
                                        } else {
                                            console.error('‚ùå Failed to generate watertight mesh');
                                            updateScanStatus('ready', 'Failed to generate watertight mesh');
                                            alert('Gagal membuat watertight mesh. Coba sesuaikan Mesh Resolution atau scan ulang dengan lebih banyak points.');
                                        }

                                        document.getElementById('generateWatertightBtn').disabled = false;
                                        document.getElementById('generateWatertightBtn').textContent = 'Generate Watertight';
                                        
                                        // Restore capture state if it was active
                                        if (wasCaptureActive) {
                                            console.log('‚ö†Ô∏è Note: Capture was active before mesh generation');
                                        }
                                        
                                    } catch (error) {
                                        console.error('‚ùå Error in mesh creation:', error);
                                        throw error;
                                    }
                                }, 50);
                            }, 50);
                        }, 50);
                    }, 50);
                    
                } catch (error) {
                    console.error('‚ùå Error generating watertight mesh:', error);
                    console.error('Stack trace:', error.stack);
                    alert('Error saat membuat watertight mesh: ' + error.message + '\n\nCek console (F12) untuk detail.');
                    document.getElementById('generateWatertightBtn').disabled = false;
                    document.getElementById('generateWatertightBtn').textContent = 'Generate Watertight';
                    updateScanStatus('ready', 'Error generating watertight mesh');
                }
            };

            // Use setTimeout to prevent UI blocking (give browser time to update UI first)
            setTimeout(processMeshAsync, 100);
        }

        /**
         * Membuat watertight mesh dari point cloud
         * Watertight mesh mengisi lubang dengan cara yang lebih konservatif untuk menghindari hasil tidak karuan
         */
        function createWatertightMesh(points) {
            if (points.length < 3) {
                alert('Tidak cukup points untuk membuat watertight mesh!');
                return null;
            }
            
            console.log('üîß Creating watertight mesh from', points.length, 'points with conservative hole filling...');
            
            // Gunakan resolution yang lebih besar untuk mesh yang lebih stabil
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            // Gunakan resolution yang sedikit lebih besar untuk stabilitas
            const stableResolution = Math.max(resolution, 0.08); // Minimum 8cm untuk stabilitas
            
            // Limit points untuk mencegah freeze, tapi jangan terlalu banyak downsampling
            let pointsForMesh = points;
            if (points.length > 30000) {
                console.log('‚ö†Ô∏è Too many points for mesh (' + points.length + '), downsampling to 30000');
                const skip = Math.ceil(points.length / 30000);
                pointsForMesh = [];
                for (let i = 0; i < points.length; i += skip) {
                    pointsForMesh.push(points[i]);
                }
            }
            
            // Buat mesh dengan resolution yang lebih stabil (tidak terlalu agresif)
            // Gunakan createImprovedMesh tapi dengan parameter yang lebih konservatif
            console.log('üîß Creating mesh with stable resolution:', stableResolution);
            const meshData = pointCloudProcessor.createImprovedMesh(pointsForMesh, stableResolution);
            
            // Jika tidak ada faces, gunakan fallback
            if (!meshData || !meshData.faces || meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }
            
            // Validasi mesh data
            if (!meshData.vertices || meshData.vertices.length === 0) {
                console.warn('‚ö†Ô∏è No vertices generated, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }
            
            // Buat geometry dari mesh data
            const geometry = new THREE.BufferGeometry();
            const vertices = meshData.vertices;
            const faces = meshData.faces;
            
            // Validasi vertices dan faces
            if (vertices.length < 3 || faces.length === 0) {
                console.warn('‚ö†Ô∏è Invalid mesh data, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }
            
            // Set positions dengan validasi
            const positions = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                if (vertices[i] && vertices[i].length >= 3) {
                    positions[i * 3] = vertices[i][0] || 0;
                    positions[i * 3 + 1] = vertices[i][1] || 0;
                    positions[i * 3 + 2] = vertices[i][2] || 0;
                } else {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                }
            }
            
            // Set indices dengan validasi
            const validFaces = [];
            for (let i = 0; i < faces.length; i++) {
                if (faces[i] && faces[i].length >= 3) {
                    const v0 = faces[i][0];
                    const v1 = faces[i][1];
                    const v2 = faces[i][2];
                    // Validasi indices
                    if (v0 >= 0 && v0 < vertices.length &&
                        v1 >= 0 && v1 < vertices.length &&
                        v2 >= 0 && v2 < vertices.length &&
                        v0 !== v1 && v1 !== v2 && v0 !== v2) {
                        validFaces.push([v0, v1, v2]);
                    }
                }
            }
            
            if (validFaces.length === 0) {
                console.warn('‚ö†Ô∏è No valid faces after validation, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }
            
            const indices = new Uint32Array(validFaces.length * 3);
            for (let i = 0; i < validFaces.length; i++) {
                indices[i * 3] = validFaces[i][0];
                indices[i * 3 + 1] = validFaces[i][1];
                indices[i * 3 + 2] = validFaces[i][2];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            
            // Compute normals untuk smooth shading (hanya sekali, tidak berulang)
            try {
                geometry.computeVertexNormals();
            } catch (err) {
                console.warn('‚ö†Ô∏è Error computing normals:', err);
            }
            
            // Validasi geometry sebelum membuat mesh
            try {
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
            } catch (err) {
                console.warn('‚ö†Ô∏è Error computing bounds:', err);
                return createMeshFromPointCloud(points);
            }
            
            // Buat material dengan warna dari point cloud
            const material = new THREE.MeshPhongMaterial({
                color: 0x888888,
                side: THREE.DoubleSide,
                flatShading: false,
                transparent: false
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            console.log('‚úÖ Watertight mesh created with', validFaces.length, 'valid faces from', vertices.length, 'vertices');
            
            return mesh;
        }
        
        /**
         * Fallback function untuk membuat mesh sederhana
         */
        function createMeshFromPointCloud(points) {
            if (points.length < 3) {
                alert('Tidak cukup points untuk membuat mesh!');
                return null;
            }
            
            console.log('üîß Creating mesh from', points.length, 'points with improved reconstruction...');
            
            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            // But limit points to prevent freeze
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            
            // Further limit points for mesh generation to prevent freeze
            let pointsForMesh = points;
            if (points.length > 20000) {
                console.log('‚ö†Ô∏è Too many points for mesh (' + points.length + '), downsampling to 20000');
                const skip = Math.ceil(points.length / 20000);
                pointsForMesh = [];
                for (let i = 0; i < points.length; i += skip) {
                    pointsForMesh.push(points[i]);
                }
            }
            
            const meshData = pointCloudProcessor.createImprovedMesh(pointsForMesh, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, using fallback');
                // Fallback: create simple mesh
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(points.length * 3);
                const colors = new Float32Array(points.length * 3);
                
                for (let i = 0; i < points.length; i++) {
                    positions[i * 3] = points[i].x;
                    positions[i * 3 + 1] = points[i].y;
                    positions[i * 3 + 2] = points[i].z;
                    
                    colors[i * 3] = (points[i].r || 128) / 255;
                    colors[i * 3 + 1] = (points[i].g || 128) / 255;
                    colors[i * 3 + 2] = (points[i].b || 128) / 255;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Simple sequential triangulation as fallback
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false // Smooth shading for better appearance
                });
                
                return new THREE.Mesh(geometry, material);
            }
            
            // Create geometry from improved mesh data
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            // Map original points to mesh vertices to preserve colors
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Find closest original point for color
                let closestIdx = 0;
                let minDist = Infinity;
                for (let j = 0; j < points.length; j++) {
                    const dist = Math.hypot(
                        points[j].x - v[0],
                        points[j].y - v[1],
                        points[j].z - v[2]
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = j;
                    }
                }
                
                colors[i * 3] = (points[closestIdx].r || 128) / 255;
                colors[i * 3 + 1] = (points[closestIdx].g || 128) / 255;
                colors[i * 3 + 2] = (points[closestIdx].b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices from faces
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            
            // Compute normals for smooth shading (this helps fix broken/rough surfaces)
            geometry.computeVertexNormals();
            
            // Compute normals for smooth shading
            geometry.computeVertexNormals();
            
            // Apply light smoothing to fix broken surfaces (without causing freeze)
            const positions = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const vertexCount = positions.count;
            
            // Create vertex neighbor map for smoothing
            const neighbors = new Array(vertexCount).fill(null).map(() => []);
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                if (!neighbors[i1].includes(i2)) neighbors[i1].push(i2);
                if (!neighbors[i1].includes(i3)) neighbors[i1].push(i3);
                if (!neighbors[i2].includes(i1)) neighbors[i2].push(i1);
                if (!neighbors[i2].includes(i3)) neighbors[i2].push(i3);
                if (!neighbors[i3].includes(i1)) neighbors[i3].push(i1);
                if (!neighbors[i3].includes(i2)) neighbors[i3].push(i2);
            }
            
            // Apply light Laplacian smoothing (only 1 iteration to prevent freeze)
            // But only smooth vertices that have enough neighbors (to preserve shape)
            const smoothingFactor = 0.15; // Light smoothing to preserve detail
            const newPositions = new Float32Array(positions.array.length);
            
            for (let i = 0; i < vertexCount; i++) {
                const x = positions.array[i * 3];
                const y = positions.array[i * 3 + 1];
                const z = positions.array[i * 3 + 2];
                
                // Only smooth if vertex has enough neighbors (at least 3)
                if (neighbors[i].length >= 3) {
                    // Average with neighbors
                    let avgX = 0, avgY = 0, avgZ = 0;
                    neighbors[i].forEach(nIdx => {
                        avgX += positions.array[nIdx * 3];
                        avgY += positions.array[nIdx * 3 + 1];
                        avgZ += positions.array[nIdx * 3 + 2];
                    });
                    avgX /= neighbors[i].length;
                    avgY /= neighbors[i].length;
                    avgZ /= neighbors[i].length;
                    
                    // Blend original with averaged position (preserve shape)
                    newPositions[i * 3] = x * (1 - smoothingFactor) + avgX * smoothingFactor;
                    newPositions[i * 3 + 1] = y * (1 - smoothingFactor) + avgY * smoothingFactor;
                    newPositions[i * 3 + 2] = z * (1 - smoothingFactor) + avgZ * smoothingFactor;
                } else {
                    // Keep original position for vertices with few neighbors (boundary/edge vertices)
                    newPositions[i * 3] = x;
                    newPositions[i * 3 + 1] = y;
                    newPositions[i * 3 + 2] = z;
                }
            }
            
            positions.array.set(newPositions);
            
            // Recompute normals after smoothing
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            
            // Repair mesh: remove duplicate faces and fix normals
            geometry = repairMeshGeometry(geometry);
            
            // Final pass: ensure mesh is watertight by checking for unpaired edges
            geometry = ensureWatertightMesh(geometry, positions, vertexCount);
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false // Smooth shading for better appearance
            });
            
            const finalVertexCount = meshData.vertices.length;
            console.log('‚úÖ Mesh created with', meshData.faces.length, 'faces,', finalVertexCount, 'vertices');
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Repair mesh: remove duplicate faces and ensure proper orientation
         */
        function repairMeshGeometry(geometry) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const positions = geometry.attributes.position.array;
            const faceSet = new Set();
            const newIndices = [];
            
            // Remove duplicate faces
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                // Create sorted key
                const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                
                if (!faceSet.has(triKey)) {
                    faceSet.add(triKey);
                    
                    // Use original orientation (assume it's correct)
                    newIndices.push(i1, i2, i3);
                }
            }
            
            // Update geometry with cleaned indices
            geometry.setIndex(newIndices);
            geometry.computeVertexNormals();
            
            console.log('‚úÖ Mesh repaired: removed', (indices.length - newIndices.length) / 3, 'duplicate faces');
            
            return geometry;
        }
        
        /**
         * Ensure mesh is watertight by filling remaining holes
         */
        function ensureWatertightMesh(geometry, positions, vertexCount) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const edgeMap = new Map();
            
            // Count edge occurrences
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                const edges = [
                    [i1, i2],
                    [i2, i3],
                    [i3, i1]
                ];
                
                edges.forEach(edge => {
                    const edgeKey = edge.sort((a, b) => a - b).join(',');
                    if (!edgeMap.has(edgeKey)) {
                        edgeMap.set(edgeKey, 0);
                    }
                    edgeMap.set(edgeKey, edgeMap.get(edgeKey) + 1);
                });
            }
            
            // Find boundary edges (appear only once)
            const boundaryEdges = [];
            edgeMap.forEach((count, edgeKey) => {
                if (count === 1) {
                    const [i1, i2] = edgeKey.split(',').map(Number);
                    boundaryEdges.push([i1, i2]);
                }
            });
            
            if (boundaryEdges.length === 0) {
                console.log('‚úÖ Mesh is watertight (no boundary edges)');
                return geometry;
            }
            
            console.log('üîß Found', boundaryEdges.length, 'boundary edges, attempting to close...');
            
            // Try to close small holes by finding nearby points
            const newIndices = Array.from(indices);
            const faceSet = new Set();
            
            // Rebuild face set
            for (let i = 0; i < indices.length; i += 3) {
                const tri = [indices[i], indices[i + 1], indices[i + 2]].sort((a, b) => a - b);
                faceSet.add(tri.join(','));
            }
            
            // Process boundary edges (limit for performance)
            let closed = 0;
            for (const [i1, i2] of boundaryEdges.slice(0, 1000)) { // Limit to 1000 for performance
                const p1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
                const p2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
                
                // Find closest point to form triangle
                let bestPoint = -1;
                let bestDist = Infinity;
                const edgeLength = p1.distanceTo(p2);
                
                for (let i = 0; i < vertexCount; i++) {
                    if (i === i1 || i === i2) continue;
                    
                    const p3 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const dist1 = p1.distanceTo(p3);
                    const dist2 = p2.distanceTo(p3);
                    
                    // Check if triangle is reasonable
                    if (dist1 < edgeLength * 2 && dist2 < edgeLength * 2) {
                        const avgDist = (dist1 + dist2) / 2;
                        if (avgDist < bestDist) {
                            bestDist = avgDist;
                            bestPoint = i;
                        }
                    }
                }
                
                // Create triangle if good candidate found
                if (bestPoint !== -1 && bestDist < edgeLength * 1.5) {
                    const tri = [i1, i2, bestPoint].sort((a, b) => a - b);
                    const faceKey = tri.join(',');
                    
                    if (!faceSet.has(faceKey)) {
                        faceSet.add(faceKey);
                        newIndices.push(tri[0], tri[1], tri[2]);
                        closed++;
                    }
                }
            }
            
            if (closed > 0) {
                geometry.setIndex(newIndices);
                geometry.computeVertexNormals();
                console.log('‚úÖ Closed', closed, 'holes in mesh');
            }
            
            return geometry;
        }
        
        function createTriangulation(points) {
            console.log('üîß Creating improved triangulation for ' + points.length.toLocaleString() + ' points...');

            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            const meshData = pointCloudProcessor.createImprovedMesh(points, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces from improved mesh, using fallback');
                // Fallback: simple sequential triangulation
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                return new Uint32Array(indices);
            }
            
            // Convert faces to indices array
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            console.log('‚úÖ Created ' + (indices.length / 3).toLocaleString() + ' triangles using improved mesh generation');
            
            return indices;
        }
        
        function exportSTL() {
            console.log('üíæ Exporting STL file...');

            let geometryToExport = null;
            let exportSource = '';

            // Check if we have mesh, otherwise create temporary mesh from point cloud
            if (mesh && mesh.geometry) {
                geometryToExport = mesh.geometry;
                exportSource = 'mesh';
                console.log('üì¶ Exporting from existing mesh');
            } else if (pointCloud.length > 0) {
                console.log('üì¶ No mesh found - creating temporary mesh from point cloud for export...');
                exportSource = 'pointcloud';

                // Create temporary simple mesh from point cloud
                const tempMesh = createSimpleMeshForExport(pointCloud);
                if (tempMesh && tempMesh.geometry) {
                    geometryToExport = tempMesh.geometry;
                    console.log('‚úÖ Temporary mesh created for export');
                } else {
                    // If mesh creation fails, try to export as point cloud directly
                    // Convert point cloud to simple STL format (point-based)
                    console.log('‚ö†Ô∏è Mesh creation failed, exporting point cloud as simple STL...');
                    try {
                        const stlString = convertPointCloudToSTL(pointCloud);
                        const blob = new Blob([stlString], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        a.download = 'kinect-scan-pointcloud-' + timestamp + '.stl';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log('‚úÖ Point cloud STL exported successfully:', a.download);
                        alert('File STL berhasil di-export dari point cloud: ' + a.download + '\n\nCatatan: File ini menggunakan triangulasi sederhana. Untuk hasil lebih baik, generate mesh terlebih dahulu.');
                        return;
                    } catch (error) {
                        alert('Gagal membuat mesh untuk export. Coba generate mesh terlebih dahulu atau pastikan ada cukup points.');
                        return;
                    }
                }
            } else {
                alert('Tidak ada data untuk di-export! Lakukan scanning terlebih dahulu.');
                return;
            }

            if (!geometryToExport) {
                alert('Gagal mengakses geometry untuk export.');
                return;
            }

            try {
                const stlString = convertToSTL(geometryToExport);
                const blob = new Blob([stlString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = 'kinect-scan-' + timestamp + '.stl';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('‚úÖ STL file exported successfully:', a.download);
                alert('File STL berhasil di-export: ' + a.download);
            } catch (error) {
                console.error('‚ùå Error exporting STL:', error);
                alert('Error saat mengekspor STL: ' + error.message);
            }
        }
        
        /**
         * Convert point cloud directly to STL format (fallback when mesh generation fails)
         * Creates simple triangles from nearby points
         */
        function convertPointCloudToSTL(points) {
            if (points.length < 3) {
                return 'solid kinect_scan\nendsolid kinect_scan\n';
            }
            
            console.log('üîß Converting point cloud to STL (simple triangulation)...');
            
            // Use simple spatial hashing for triangulation
            const maxDistance = 0.1; // 10cm max distance for connecting points
            const hashSize = 0.05; // 5cm grid cells
            const spatialHash = {};
            
            // Build spatial hash
            points.forEach((p, i) => {
                const hx = Math.floor(p.x / hashSize);
                const hy = Math.floor(p.y / hashSize);
                const hz = Math.floor(p.z / hashSize);
                const key = `${hx},${hy},${hz}`;
                if (!spatialHash[key]) spatialHash[key] = [];
                spatialHash[key].push(i);
            });
            
            const triangles = [];
            const processed = new Set();
            
            // Generate triangles from nearby points
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const hx = Math.floor(p1.x / hashSize);
                const hy = Math.floor(p1.y / hashSize);
                const hz = Math.floor(p1.z / hashSize);
                
                // Check neighboring cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const key = `${hx+dx},${hy+dy},${hz+dz}`;
                            if (!spatialHash[key]) continue;
                            
                            spatialHash[key].forEach(j => {
                                if (j <= i) return;
                                const p2 = points[j];
                                const dist12 = Math.hypot(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                                if (dist12 > maxDistance) return;
                                
                                // Find third point
                                for (let dx2 = -1; dx2 <= 1; dx2++) {
                                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                                        for (let dz2 = -1; dz2 <= 1; dz2++) {
                                            const key2 = `${hx+dx2},${hy+dy2},${hz+dz2}`;
                                            if (!spatialHash[key2]) continue;
                                            
                                            spatialHash[key2].forEach(k => {
                                                if (k === i || k === j) return;
                                                const p3 = points[k];
                                                const dist13 = Math.hypot(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                                                const dist23 = Math.hypot(p3.x - p2.x, p3.y - p2.y, p3.z - p2.z);
                                                
                                                if (dist13 <= maxDistance && dist23 <= maxDistance) {
                                                    const triKey = [i, j, k].sort().join(',');
                                                    if (!processed.has(triKey)) {
                                                        processed.add(triKey);
                                                        triangles.push([i, j, k]);
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // Convert to STL format
            let stl = 'solid kinect_scan\n';
            
            triangles.forEach(tri => {
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];
                
                // Calculate normal
                const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                
                // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                const scale = 1000; // Scale dari meter ke mm
                const p1Scaled = { x: p1.x * scale, y: p1.y * scale, z: p1.z * scale };
                const p2Scaled = { x: p2.x * scale, y: p2.y * scale, z: p2.z * scale };
                const p3Scaled = { x: p3.x * scale, y: p3.y * scale, z: p3.z * scale };
                
                stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                stl += `    outer loop\n`;
                stl += `      vertex ${p1Scaled.x.toFixed(6)} ${p1Scaled.y.toFixed(6)} ${p1Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p2Scaled.x.toFixed(6)} ${p2Scaled.y.toFixed(6)} ${p2Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p3Scaled.x.toFixed(6)} ${p3Scaled.y.toFixed(6)} ${p3Scaled.z.toFixed(6)}\n`;
                stl += `    endloop\n`;
                stl += `  endfacet\n`;
            });
            
            stl += 'endsolid kinect_scan\n';
            console.log('‚úÖ Converted', triangles.length, 'triangles to STL');
            return stl;
        }
        
        /**
         * Convert Three.js geometry to STL format with validation
         * Ensures mesh is valid and properly formatted
         */
        function convertToSTL(geometry) {
            console.log('üîß Converting geometry to STL format...');
            
            // Validate and repair geometry before export
            geometry = validateAndRepairGeometry(geometry);
            
            let stl = 'solid kinect_scan\n';
            const positions = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;
            
            let validTriangles = 0;
            let invalidTriangles = 0;
            
            if (indices) {
                // Indexed geometry - more efficient
                const triangleSet = new Set(); // Track unique triangles
                
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i];
                    const i2 = indices[i + 1];
                    const i3 = indices[i + 2];
                    
                    // Validate indices
                    if (i1 === i2 || i2 === i3 || i1 === i3) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    // Check for duplicate triangles
                    const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue; // Skip duplicate triangles
                    }
                    triangleSet.add(triKey);
                    
                    const idx1 = i1 * 3;
                    const idx2 = i2 * 3;
                    const idx3 = i3 * 3;
                    
                    // Validate array bounds
                    if (idx1 + 2 >= positions.length || idx2 + 2 >= positions.length || idx3 + 2 >= positions.length) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    const v1 = new THREE.Vector3(positions[idx1], positions[idx1 + 1], positions[idx1 + 2]);
                    const v2 = new THREE.Vector3(positions[idx2], positions[idx2 + 1], positions[idx2 + 2]);
                    const v3 = new THREE.Vector3(positions[idx3], positions[idx3 + 1], positions[idx3 + 2]);
                    
                    // Check for degenerate triangles (zero area)
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    normal.normalize();
                    
                    // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                    // STL biasanya dalam mm, jadi scale up 1000x
                    const scale = 1000; // Scale dari meter ke mm
                    const v1Scaled = new THREE.Vector3(v1.x * scale, v1.y * scale, v1.z * scale);
                    const v2Scaled = new THREE.Vector3(v2.x * scale, v2.y * scale, v2.z * scale);
                    const v3Scaled = new THREE.Vector3(v3.x * scale, v3.y * scale, v3.z * scale);
                    
                    // Write triangle to STL (dalam mm)
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1Scaled.x.toFixed(6)} ${v1Scaled.y.toFixed(6)} ${v1Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2Scaled.x.toFixed(6)} ${v2Scaled.y.toFixed(6)} ${v2Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3Scaled.x.toFixed(6)} ${v3Scaled.y.toFixed(6)} ${v3Scaled.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            } else {
                // Non-indexed geometry
                const vertexCount = positions.length / 3;
                const triangleSet = new Set();
                
                for (let i = 0; i < vertexCount - 2; i += 3) {
                    const v1 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const v2 = new THREE.Vector3(positions[(i + 1) * 3], positions[(i + 1) * 3 + 1], positions[(i + 1) * 3 + 2]);
                    const v3 = new THREE.Vector3(positions[(i + 2) * 3], positions[(i + 2) * 3 + 1], positions[(i + 2) * 3 + 2]);
                    
                    // Check for duplicate triangles
                    const triKey = `${i},${i+1},${i+2}`;
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue;
                    }
                    triangleSet.add(triKey);
                    
                    // Check for degenerate triangles
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    normal.normalize();
                    
                    // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                    const scale = 1000; // Scale dari meter ke mm
                    const v1Scaled = new THREE.Vector3(v1.x * scale, v1.y * scale, v1.z * scale);
                    const v2Scaled = new THREE.Vector3(v2.x * scale, v2.y * scale, v2.z * scale);
                    const v3Scaled = new THREE.Vector3(v3.x * scale, v3.y * scale, v3.z * scale);
                    
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1Scaled.x.toFixed(6)} ${v1Scaled.y.toFixed(6)} ${v1Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2Scaled.x.toFixed(6)} ${v2Scaled.y.toFixed(6)} ${v2Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3Scaled.x.toFixed(6)} ${v3Scaled.y.toFixed(6)} ${v3Scaled.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            }
            
            stl += 'endsolid kinect_scan\n';
            
            console.log('‚úÖ STL conversion complete:', validTriangles, 'valid triangles,', invalidTriangles, 'invalid triangles skipped');
            
            if (validTriangles === 0) {
                console.error('‚ùå No valid triangles in geometry!');
                return null;
            }
            
            return stl;
        }
        
        /**
         * Validate and repair geometry before STL export
         * Ensures mesh is watertight and properly formed
         */
        function validateAndRepairGeometry(geometry) {
            console.log('üîß Validating and repairing geometry...');
            
            if (!geometry.index) {
                console.log('‚ö†Ô∏è Geometry is not indexed, computing index...');
                // Try to merge vertices if BufferGeometryUtils is available
                if (typeof THREE.BufferGeometryUtils !== 'undefined') {
                    geometry = THREE.BufferGeometryUtils.mergeVertices(geometry, 0.001);
                }
                geometry.computeVertexNormals();
                return geometry;
            }
            
            // Remove duplicate vertices
            const positions = geometry.attributes.position.array;
            const indices = geometry.index.array;
            const vertexCount = positions.length / 3;
            
            // Recompute normals to ensure consistency
            geometry.computeVertexNormals();
            
            // Ensure bounding sphere is computed
            if (!geometry.boundingSphere) {
                geometry.computeBoundingSphere();
            }
            
            console.log('‚úÖ Geometry validated:', vertexCount, 'vertices,', indices.length / 3, 'triangles');
            
            return geometry;
        }
        
        function clearScan() {
            // Reset multi-phase data
            scanPhase = 0;
            pointCloudFront = [];
            pointCloudBack = [];
            isMultiPhaseMode = false;
            if (document.getElementById('enableMultiPhaseCheckbox')) {
                document.getElementById('enableMultiPhaseCheckbox').checked = false;
            }
            if (document.getElementById('phaseInfo')) {
                document.getElementById('phaseInfo').style.display = 'none';
            }
            if (document.getElementById('startPhase2Btn')) {
                document.getElementById('startPhase2Btn').style.display = 'none';
                document.getElementById('startPhase2Btn').disabled = true;
            }
            
            // Stop scanning if active
            if (isScanning) {
                stopScan();
            }
            
            pointCloud = [];
            pointCloudFrames = [];
            meshFrames = []; // Clear mesh frames
            mesh = null;
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            kinectPosition = { x: 0, y: 0, z: 0 };
            
            // Remove depth mesh and bounding box if exists
            if (scene) {
                const depthMesh = scene.getObjectByName('depthMesh');
                if (depthMesh) {
                    scene.remove(depthMesh);
                }
                
                // Remove bounding box
                const boundingBox = scene.getObjectByName('boundingBox');
                if (boundingBox) {
                    scene.remove(boundingBox);
                }
            }
            
            if (scene) {
                const oldPointCloud = scene.getObjectByName('pointCloud');
                if (oldPointCloud) {
                    scene.remove(oldPointCloud);
                }
                
                const oldMesh = scene.getObjectByName('mesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Remove bounding box
                const oldBoundingBox = scene.getObjectByName('boundingBox');
                if (oldBoundingBox) {
                    scene.remove(oldBoundingBox);
                }
            }
            
            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('exportSTLBtn').disabled = true;
            updateScanStatus('idle', 'Tidak aktif');
            const debugMsgEl = document.getElementById('debugMessage');
            const debugCountEl = document.getElementById('debugDataCount');
            if (debugMsgEl) debugMsgEl.textContent = '-';
            if (debugCountEl) debugCountEl.textContent = '0';
            
            // Reset progress bar
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '0%';
                progressFillEl.textContent = '0%';
            }
            
            updateStats();
        }
        
        function updateStats() {
            const pointCountEl = document.getElementById('pointCount');
            const frameCountEl = document.getElementById('frameCount');
            const progressFillEl = document.getElementById('progressFill');
            
            // Update point count
            if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
            
            // Update frame count (actual number of frames captured)
            if (frameCountEl) frameCountEl.textContent = frameCount.toLocaleString();
            
            // Update progress bar (based on point count, max 200k points = 100%)
            if (progressFillEl) {
                const maxPoints = maxTotalPoints; // Maximum expected points for a good scan
                const progress = Math.min(100, (pointCloud.length / maxPoints) * 100);
                progressFillEl.style.width = progress + '%';
                progressFillEl.textContent = Math.round(progress) + '%';
            }
        }
        
        /**
         * Calculate principal component analysis (PCA) to find main orientation
         * Returns rotation quaternion to align object upright
         */
        function calculateOrientationAlignment(points) {
            if (points.length < 3) return null;
            
            // Calculate bounding box to find longest dimension
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < points.length; i++) {
                minX = Math.min(minX, points[i].x);
                maxX = Math.max(maxX, points[i].x);
                minY = Math.min(minY, points[i].y);
                maxY = Math.max(maxY, points[i].y);
                minZ = Math.min(minZ, points[i].z);
                maxZ = Math.max(maxZ, points[i].z);
            }
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            
            // Find longest dimension
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            // For human body, Y (height) should typically be longest
            // If it's not, rotate to make the longest dimension vertical
            const rotation = new THREE.Quaternion();
            
            // Only rotate if Y is not the longest (object is tilted)
            if (maxSize === sizeX && sizeX > sizeY * 1.2) {
                // Longest is X, rotate 90 degrees around Z to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
                console.log('üîÑ Rotating: X-axis is longest, rotating 90¬∞ around Z');
            } else if (maxSize === sizeZ && sizeZ > sizeY * 1.2) {
                // Longest is Z, rotate 90 degrees around X to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                console.log('üîÑ Rotating: Z-axis is longest, rotating 90¬∞ around X');
            }
            // If Y is already longest or close, no rotation needed
            
            return rotation;
        }
        
        /**
         * Apply rotation to align object upright (horizontal/tegak)
         */
        function alignObjectUpright(obj, points) {
            if (!obj || !points || points.length < 3) return;
            
            // Calculate orientation alignment
            const rotation = calculateOrientationAlignment(points);
            if (!rotation) return;
            
            // Check if rotation is needed (quaternion is not identity)
            if (rotation.x === 0 && rotation.y === 0 && rotation.z === 0 && rotation.w === 1) {
                return; // No rotation needed
            }
            
            // Apply rotation to object
            // Store original rotation if not already stored
            if (!obj.userData.originalRotation) {
                obj.userData.originalRotation = obj.quaternion.clone();
            }
            
            // Apply rotation
            obj.quaternion.copy(rotation);
            
            console.log('üîÑ Object rotated to upright orientation');
        }
        
        function centerModel() {
            if (!scene || !camera) return;
            
            // Get all objects that should be centered (point cloud or mesh)
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');
            
            const objectsToCenter = [];
            if (pointCloudObj && pointCloudObj.visible) objectsToCenter.push(pointCloudObj);
            if (meshObj && meshObj.visible) objectsToCenter.push(meshObj);
            
            if (objectsToCenter.length === 0) return;
            
            // Get points for orientation calculation
            let pointsForAlignment = [];
            if (pointCloudObj && pointCloud.length > 0) {
                pointsForAlignment = pointCloud;
            } else if (meshObj && meshObj.geometry) {
                // Extract points from mesh geometry
                const positions = meshObj.geometry.attributes.position;
                if (positions) {
                    for (let i = 0; i < positions.count; i++) {
                        pointsForAlignment.push({
                            x: positions.getX(i),
                            y: positions.getY(i),
                            z: positions.getZ(i)
                        });
                    }
                }
            }
            
            // DISABLED: Auto-rotation to preserve original landscape orientation
            // Uncomment below to enable auto-rotation if needed
            // if (pointsForAlignment.length > 0) {
            //     objectsToCenter.forEach(obj => {
            //         alignObjectUpright(obj, pointsForAlignment);
            //     });
            // }
            
            // Calculate bounding box of all objects
            const box = new THREE.Box3();
            objectsToCenter.forEach(obj => {
                obj.updateMatrixWorld();
                box.expandByObject(obj);
            });
            
            if (box.isEmpty()) return;
            
            // Calculate center and size
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Validasi ukuran objek: tidak boleh lebih besar dari 350mm (0.35m)
            const maxObjectSize = window.maxObjectSize || 0.35; // 350mm
            let scaleFactor = 1.0;
            
            if (maxDim > maxObjectSize) {
                scaleFactor = maxObjectSize / maxDim;
                console.warn('‚ö†Ô∏è Objek terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm (scale: ' + scaleFactor.toFixed(3) + ')');
                
                // Apply scale to all objects
                objectsToCenter.forEach(obj => {
                    if (!obj.userData.originalScale) {
                        obj.userData.originalScale = obj.scale.clone();
                    }
                    obj.scale.set(
                        obj.userData.originalScale.x * scaleFactor,
                        obj.userData.originalScale.y * scaleFactor,
                        obj.userData.originalScale.z * scaleFactor
                    );
                });
                
                // Recalculate box after scaling
                box.setFromObject(objectsToCenter[0]);
                const newSize = box.getSize(new THREE.Vector3());
                const newMaxDim = Math.max(newSize.x, newSize.y, newSize.z);
                console.log('‚úÖ Objek di-scale:', {
                    original: (maxDim * 1000).toFixed(0) + 'mm',
                    scaled: (newMaxDim * 1000).toFixed(0) + 'mm',
                    scaleFactor: scaleFactor.toFixed(3)
                });
            }
            
            // Posisikan objek di atas grid (Y = 0 atau sedikit di atas)
            // Hitung offset Y agar objek berada di atas grid, bukan mengambang
            const boxMin = box.min;
            // Pastikan objek berada di atas grid (Y >= 0)
            // Jika objek memiliki bagian negatif, geser ke atas
            const yOffset = -boxMin.y; // Offset untuk memindahkan objek ke Y = 0 (di atas grid)
            
            // Center all objects at origin (but preserve manual position offset)
            // X dan Z di-center, Y diposisikan di atas grid
            const offset = center.clone().negate();
            offset.y = yOffset; // Set Y offset agar objek di atas grid
            
            objectsToCenter.forEach(obj => {
                // Apply centering offset, then add manual position
                // Pastikan objek selalu di atas grid (Y >= 0)
                const finalY = Math.max(0, offset.y + (window.objectPosition ? window.objectPosition.y : 0));
                obj.position.set(
                    offset.x + (window.objectPosition ? window.objectPosition.x : 0),
                    finalY, // Pastikan Y >= 0 (di atas grid)
                    offset.z + (window.objectPosition ? window.objectPosition.z : 0)
                );
                obj.updateMatrixWorld(); // Update matrix setelah positioning
            });
            
            // Fit camera to view the object properly
            if (maxDim > 0) {
                // Get canvas dimensions
                const container = document.getElementById('viewer');
                const width = container ? container.clientWidth : 800;
                const height = container ? container.clientHeight : 600;
                
                // Calculate distance needed to fit object in view
                // Use FOV and object size to calculate optimal distance
                const fov = camera.fov * (Math.PI / 180); // Convert to radians
                const distance = Math.max(
                    maxDim / (2 * Math.tan(fov / 2)), // Fit width
                    maxDim / (2 * Math.tan(fov / 2) * (height / width)) // Fit height
                );
                
                // Add some padding (20% extra space around object)
                const distanceWithPadding = distance * 1.2;
                
                // Position camera to view the centered object
                // Objek sudah di-center di origin (0, 0, 0) dan di atas grid (Y >= 0)
                // Posisikan camera di depan dan sedikit di atas untuk melihat objek dengan jelas
                const cameraY = Math.max(0, size.y * 0.3); // Slight offset upward (30% of height), minimal Y = 0
                camera.position.set(0, cameraY, distanceWithPadding);
                camera.lookAt(0, Math.max(0, size.y * 0.1), 0); // Look at sedikit di atas grid (10% dari tinggi objek)
                camera.updateProjectionMatrix();
                
                console.log('üì∑ Camera positioned:', {
                    position: camera.position,
                    lookAt: new THREE.Vector3(0, Math.max(0, size.y * 0.1), 0),
                    objectSize: size,
                    distance: distanceWithPadding
                });
            }
            
            console.log('‚úÖ Model centered, aligned upright, and fitted to view. Size:', size, 'Center:', center);
        }
        
        /**
         * Create a simple mesh from point cloud for STL export
         * Uses improved triangulation to create a proper mesh
         */
        function createSimpleMeshForExport(points) {
            if (points.length < 3) {
                console.warn('Not enough points for mesh export');
                return null;
            }
            
            console.log('üîß Creating simple mesh for export from', points.length, 'points...');
            
            // Downsample if too many points for performance (use uniform sampling for better quality)
            let meshPoints = points;
            const maxPoints = 150000; // Increased limit for high-quality export
            
            if (points.length > maxPoints) {
                // Use uniform sampling instead of skip factor for better quality
                const step = points.length / maxPoints;
                meshPoints = [];
                for (let i = 0; i < points.length; i += step) {
                    const idx = Math.floor(i);
                    if (idx < points.length) {
                        meshPoints.push(points[idx]);
                    }
                }
                console.log('üìâ Downsampled to', meshPoints.length, 'points for export (uniform sampling)');
            }
            
            // Use improved mesh generation from pointcloud processor
            // Use finer resolution for better quality mesh
            const baseResolution = parseFloat(document.getElementById('meshResolutionSlider')?.value || 0.05);
            const resolution = Math.max(0.02, baseResolution * 0.8); // Finer resolution for export
            console.log('üîß Generating mesh with resolution:', resolution);
            
            const meshData = pointCloudProcessor.createImprovedMesh(meshPoints, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, trying with coarser resolution...');
                // Try with coarser resolution
                const coarserMesh = pointCloudProcessor.createImprovedMesh(meshPoints, resolution * 2);
                if (coarserMesh.faces.length > 0) {
                    Object.assign(meshData, coarserMesh);
                    console.log('‚úÖ Generated mesh with coarser resolution');
                } else {
                    console.warn('‚ö†Ô∏è Still no faces, using fallback triangulation');
                    // Fallback: simple sequential triangulation (last resort)
                    const fallbackFaces = [];
                    for (let i = 0; i < Math.min(meshPoints.length - 2, 10000); i += 3) {
                        if (i + 2 < meshPoints.length) {
                            fallbackFaces.push([i, i + 1, i + 2]);
                        }
                    }
                    meshData.faces = fallbackFaces;
                }
            }
            
            console.log('‚úÖ Mesh data generated:', meshData.vertices.length, 'vertices,', meshData.faces.length, 'faces');
            
            // Create Three.js geometry
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Use original point colors if available
                const origPoint = meshPoints[i];
                colors[i * 3] = (origPoint.r || 128) / 255;
                colors[i * 3 + 1] = (origPoint.g || 128) / 255;
                colors[i * 3 + 2] = (origPoint.b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Filter point cloud to keep only human body, remove background
         * Uses simpler depth-based filtering - keeps points in typical human range
         * and removes outliers that are too far from the main cluster
         */
        function filterHumanBodyOnly(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m - Kinect optimal range for humans)
            const depthFiltered = points.filter(p => {
                // Z is typically the distance from Kinect (forward direction)
                // Use absolute value to handle negative Z
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No points in human depth range, using all points');
                return points;
            }
            
            console.log('üìä After depth filter:', depthFiltered.length, 'points');
            
            // Step 2: Remove outliers using statistical filtering
            // Find the main cluster by removing points that are too far from the center
            
            // Calculate center of mass
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Calculate median distance (more robust than mean)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            
            // Keep points within 2x median distance (this keeps the main body, removes far background)
            const threshold = medianDist * 2.5; // More lenient threshold
            const filtered = depthFiltered.filter((p, i) => {
                return distances[i] <= threshold;
            });
            
            console.log('‚úÖ Human body filter:', points.length, '‚Üí', filtered.length, 'points (removed', (points.length - filtered.length), 'background points)');
            
            // If filter removed too many points (>70%), return depth-filtered only
            if (filtered.length < points.length * 0.3) {
                console.warn('‚ö†Ô∏è Filter too aggressive, using depth-filtered points only');
                return depthFiltered;
            }
            
            return filtered;
        }
        
        /**
         * Filter menggunakan depth camera untuk menangkap objek 3D anggota tubuh
         * Seperti depth map: objek dekat (anggota tubuh) berwarna merah/oranye, background jauh abu-abu/hitam
         * Menggunakan depth-based filtering untuk memisahkan anggota tubuh dari background
         */
        function filterDepthBasedBodyParts(points) {
            if (points.length === 0) return points;
            
            console.log('üì∑ Filtering body parts using depth camera from', points.length, 'points...');
            
            // Step 1: Filter by depth range untuk anggota tubuh (0.85m to 2.5m - optimal untuk anggota tubuh)
            // Background biasanya lebih jauh dari 2.5m - HILANGKAN SEMUA BACKGROUND
            const bodyPartsFiltered = points.filter(p => {
                const dist = Math.abs(p.z);
                // Range optimal untuk anggota tubuh: 0.85m - 2.5m
                // Background biasanya > 2.5m, jadi dihilangkan SEMUA
                // Juga filter berdasarkan Y position - background biasanya di bawah atau terlalu tinggi
                const yPos = p.y || 0;
                // Hanya ambil objek di range Y yang wajar untuk anggota tubuh (tidak terlalu rendah/tidak terlalu tinggi)
                return dist >= 0.85 && dist <= 2.5 && yPos >= -1.0 && yPos <= 1.5;
            });
            
            if (bodyPartsFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No points in body parts depth range, using all points');
                return points;
            }
            
            console.log('üìä After depth-based body parts filter:', bodyPartsFiltered.length, 'points');
            
            // Step 2: Apply color mapping berdasarkan depth (seperti depth map)
            // Objek dekat (anggota tubuh) akan memiliki warna lebih cerah (merah/oranye)
            // Background jauh akan lebih gelap (abu-abu/hitam) - sudah dihilangkan di step 1
            // Untuk visualisasi, kita bisa map depth ke warna, tapi untuk filtering cukup depth saja
            
            // Step 3: Remove outliers menggunakan clustering
            if (bodyPartsFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No body parts found, using all points');
                return points;
            }
            
            // Calculate center of mass untuk clustering
            let centerX = 0, centerY = 0, centerZ = 0;
            bodyPartsFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= bodyPartsFiltered.length;
            centerY /= bodyPartsFiltered.length;
            centerZ /= bodyPartsFiltered.length;
            
            // Calculate distances from center untuk remove outliers
            const distances = bodyPartsFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Calculate median distance
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            
            // Keep points within 2.5x median distance (main cluster = anggota tubuh)
            const threshold = medianDist * 2.5;
            const filtered = bodyPartsFiltered.filter((p, i) => {
                return distances[i] <= threshold;
            });
            
            console.log('‚úÖ Depth-based body parts filter:', points.length, '‚Üí', filtered.length, 'points (removed', (points.length - filtered.length), 'background points)');
            
            // If filter removed too many points (>70%), return depth-filtered only
            if (filtered.length < points.length * 0.3) {
                console.warn('‚ö†Ô∏è Filter too aggressive, using depth-filtered points only');
                return bodyPartsFiltered;
            }
            
            return filtered;
        }
        
        /**
         * Remove duplicate/overlapping points to prevent layering
         * Uses voxel-based approach for better deduplication
         * This ensures each voxel (3D cell) contains only one point
         */
        function removeDuplicatePoints(newPoints, existingPoints) {
            if (newPoints.length === 0) return newPoints;
            
            console.log('üîç Removing duplicate points using voxel-based deduplication...');
            
            // Use voxel-based approach: each voxel can only contain one point
            // This is more effective than distance-based for preventing layering
            const voxelSize = 0.02; // 2cm voxels - smaller for better precision
            const voxelMap = new Map();
            
            // Build voxel map from existing points
            existingPoints.forEach((p, idx) => {
                const vx = Math.floor(p.x / voxelSize);
                const vy = Math.floor(p.y / voxelSize);
                const vz = Math.floor(p.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Store only one point per voxel (the first one)
                if (!voxelMap.has(voxelKey)) {
                    voxelMap.set(voxelKey, p);
                }
            });
            
            // Filter new points: keep only if voxel is empty
            const filtered = [];
            const newVoxelMap = new Map();
            
            for (const point of newPoints) {
                const vx = Math.floor(point.x / voxelSize);
                const vy = Math.floor(point.y / voxelSize);
                const vz = Math.floor(point.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Check if voxel is already occupied
                const existingInVoxel = voxelMap.get(voxelKey);
                const newInVoxel = newVoxelMap.get(voxelKey);
                
                if (!existingInVoxel && !newInVoxel) {
                    // Voxel is empty, add point
                    filtered.push(point);
                    newVoxelMap.set(voxelKey, point);
                } else {
                    // Voxel is occupied, check if this point is better (closer to voxel center)
                    const voxelCenterX = (vx + 0.5) * voxelSize;
                    const voxelCenterY = (vy + 0.5) * voxelSize;
                    const voxelCenterZ = (vz + 0.5) * voxelSize;
                    
                    const pointDist = Math.hypot(
                        point.x - voxelCenterX,
                        point.y - voxelCenterY,
                        point.z - voxelCenterZ
                    );
                    
                    // Replace if this point is closer to voxel center
                    if (existingInVoxel) {
                        const existingDist = Math.hypot(
                            existingInVoxel.x - voxelCenterX,
                            existingInVoxel.y - voxelCenterY,
                            existingInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < existingDist) {
                            // Replace existing point in voxel
                            voxelMap.set(voxelKey, point);
                            // Note: we can't remove from existingPoints array, but this prevents future duplicates
                        }
                    } else if (newInVoxel) {
                        const newDist = Math.hypot(
                            newInVoxel.x - voxelCenterX,
                            newInVoxel.y - voxelCenterY,
                            newInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < newDist) {
                            // Replace in new points
                            const idx = filtered.indexOf(newInVoxel);
                            if (idx !== -1) {
                                filtered[idx] = point;
                                newVoxelMap.set(voxelKey, point);
                            }
                        }
                    }
                }
            }
            
            console.log('‚úÖ Voxel deduplication: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points (removed ' + (newPoints.length - filtered.length) + ' duplicates)');
            
            return filtered;
        }
        
        /**
         * Alternative: Temporal filtering to reduce layering
         * Only keeps points that are stable across frames
         */
        function applyTemporalFiltering(newPoints, pointCloudFrames) {
            if (pointCloudFrames.length < 2) return newPoints;
            
            console.log('üîç Applying temporal filtering to reduce noise...');
            
            // Build spatial hash for recent frames
            const cellSize = 0.03; // 3cm cells
            const frameGrids = [];
            
            // Get last 3 frames for temporal consistency
            const recentFrames = pointCloudFrames.slice(-3);
            
            recentFrames.forEach(frame => {
                const grid = new Map();
                frame.forEach((p, idx) => {
                    const gx = Math.floor(p.x / cellSize);
                    const gy = Math.floor(p.y / cellSize);
                    const gz = Math.floor(p.z / cellSize);
                    const key = `${gx},${gy},${gz}`;
                    
                    if (!grid.has(key)) {
                        grid.set(key, []);
                    }
                    grid.get(key).push(p);
                });
                frameGrids.push(grid);
            });
            
            // Keep points that appear in multiple frames (more stable)
            const filtered = newPoints.filter(point => {
                const gx = Math.floor(point.x / cellSize);
                const gy = Math.floor(point.y / cellSize);
                const gz = Math.floor(point.z / cellSize);
                
                let matchCount = 0;
                
                frameGrids.forEach(grid => {
                    // Check neighboring cells
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const key = `${gx + dx},${gy + dy},${gz + dz}`;
                                const cellPoints = grid.get(key) || [];
                                
                                for (const otherPoint of cellPoints) {
                                    const dist = Math.hypot(
                                        point.x - otherPoint.x,
                                        point.y - otherPoint.y,
                                        point.z - otherPoint.z
                                    );
                                    
                                    if (dist < cellSize) {
                                        matchCount++;
                                        return; // Found match in this frame
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Keep if appears in at least 1 other frame (temporal consistency)
                return matchCount >= 1;
            });
            
            console.log('‚úÖ Temporal filter: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points');
            
            return filtered;
        }
        
        /**
         * Aggressive filter for mesh generation - removes background more aggressively
         * Uses tighter clustering to ensure only human body remains
         */
        function filterHumanBodyOnlyAggressive(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Aggressive filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m)
            const depthFiltered = points.filter(p => {
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                return points;
            }
            
            // Step 2: Find the main cluster using tighter threshold
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Use tighter threshold for aggressive filtering (1.8x instead of 2.5x)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            const threshold = medianDist * 1.8; // Tighter threshold for mesh
            
            // Also filter by Y position - human body is typically in middle-upper Y range
            // Remove points that are too low (likely floor) or too high (likely ceiling)
            const yValues = depthFiltered.map(p => p.y);
            const sortedY = [...yValues].sort((a, b) => a - b);
            const minY = sortedY[Math.floor(sortedY.length * 0.1)]; // 10th percentile
            const maxY = sortedY[Math.floor(sortedY.length * 0.9)]; // 90th percentile
            
            const filtered = depthFiltered.filter((p, i) => {
                // Check distance from center
                if (distances[i] > threshold) return false;
                // Check Y position (remove floor and ceiling)
                if (p.y < minY || p.y > maxY) return false;
                return true;
            });
            
            console.log('‚úÖ Aggressive filter:', points.length, '‚Üí', filtered.length, 'points');
            
            return filtered;
        }

        // Object position control variables - MUST be global
        window.objectPosition = { x: 0, y: 0, z: 0 };
        
        /**
         * Update object position in the scene
         * Applies position to both point cloud and mesh
         */
        window.updateObjectPosition = function() {
            if (!scene) {
                console.warn('Scene not initialized, cannot update position');
                return;
            }
            
            console.log('üìç Updating object position to:', window.objectPosition);
            
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');
            
            let updated = false;
            
            // Apply position to point cloud
            if (pointCloudObj) {
                pointCloudObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated point cloud position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Point cloud not found in scene');
            }
            
            // Apply position to mesh
            if (meshObj) {
                meshObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated mesh position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Mesh not found in scene');
            }
            
            // Apply position to bounding box
            // Bounding box dihilangkan - tidak perlu update position
            
            if (!updated) {
                console.warn('‚ö†Ô∏è No object found to update position (point cloud or mesh). Make sure you have scanned or generated mesh first.');
            }
            
            // Update display
            const posDisplay = document.getElementById('currentPosition');
            if (posDisplay) {
                posDisplay.textContent = `X: ${window.objectPosition.x.toFixed(2)}, Y: ${window.objectPosition.y.toFixed(2)}, Z: ${window.objectPosition.z.toFixed(2)}`;
            }
        };
        
        /**
         * Adjust position by increment
         */
        window.adjustPosition = function(axis, increment) {
            console.log(`üîß Adjusting position ${axis} by ${increment}`);
            window.objectPosition[axis] += increment;
            window.objectPosition[axis] = Math.max(-5, Math.min(5, window.objectPosition[axis])); // Clamp to -5 to 5
            
            // Update sliders and input fields
            const axisUpper = axis.toUpperCase();
            const slider = document.getElementById(`position${axisUpper}Slider`);
            const input = document.getElementById(`position${axisUpper}Value`);
            if (slider) {
                slider.value = window.objectPosition[axis];
                console.log(`Updated slider ${axis} to ${window.objectPosition[axis]}`);
            }
            if (input) {
                input.value = window.objectPosition[axis].toFixed(1);
                console.log(`Updated input ${axis} to ${window.objectPosition[axis]}`);
            }
            
            window.updateObjectPosition();
        };
        
        /**
         * Update position X
         */
        window.updatePositionX = function(value) {
            console.log('üîß Updating position X to:', value);
            window.objectPosition.x = parseFloat(value) || 0;
            window.objectPosition.x = Math.max(-5, Math.min(5, window.objectPosition.x));
            const slider = document.getElementById('positionXSlider');
            if (slider) {
                slider.value = window.objectPosition.x;
                console.log('Updated X slider to:', window.objectPosition.x);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Y
         */
        window.updatePositionY = function(value) {
            console.log('üîß Updating position Y to:', value);
            window.objectPosition.y = parseFloat(value) || 0;
            window.objectPosition.y = Math.max(-5, Math.min(5, window.objectPosition.y));
            const slider = document.getElementById('positionYSlider');
            if (slider) {
                slider.value = window.objectPosition.y;
                console.log('Updated Y slider to:', window.objectPosition.y);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Z
         */
        window.updatePositionZ = function(value) {
            console.log('üîß Updating position Z to:', value);
            window.objectPosition.z = parseFloat(value) || 0;
            window.objectPosition.z = Math.max(-5, Math.min(5, window.objectPosition.z));
            const slider = document.getElementById('positionZSlider');
            if (slider) {
                slider.value = window.objectPosition.z;
                console.log('Updated Z slider to:', window.objectPosition.z);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Reset object position to center
         */
        window.resetObjectPosition = function() {
            console.log('üîÑ Resetting object position to center');
            window.objectPosition = { x: 0, y: 0, z: 0 };
            
            // Update all sliders and inputs
            ['X', 'Y', 'Z'].forEach(axis => {
                const slider = document.getElementById(`position${axis}Slider`);
                const input = document.getElementById(`position${axis}Value`);
                if (slider) slider.value = 0;
                if (input) input.value = '0.0';
            });
            
            window.updateObjectPosition();
            centerModel(); // Also recenter the view
        };
        
        // Settings sliders
        document.addEventListener('DOMContentLoaded', function() {
            const maxPointsSlider = document.getElementById('maxPointsSlider');
            const meshResolutionSlider = document.getElementById('meshResolutionSlider');
            
            if (maxPointsSlider) {
                maxPointsSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('maxPointsValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            if (meshResolutionSlider) {
                meshResolutionSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('meshResolutionValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            // Position control sliders - CRITICAL: Must be set up here
            const positionXSlider = document.getElementById('positionXSlider');
            const positionYSlider = document.getElementById('positionYSlider');
            const positionZSlider = document.getElementById('positionZSlider');
            
            if (positionXSlider) {
                positionXSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.x = value;
                    const input = document.getElementById('positionXValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position X slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position X slider not found');
            }
            
            if (positionYSlider) {
                positionYSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.y = value;
                    const input = document.getElementById('positionYValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Y slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Y slider not found');
            }
            
            if (positionZSlider) {
                positionZSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.z = value;
                    const input = document.getElementById('positionZValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Z slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Z slider not found');
            }
        });

        // Auto-connect on page load
        window.addEventListener('load', function() {
            console.log('üîµ Page loaded, auto-connecting...');
            connect();
        });

        // Periodic state check for debugging
        setInterval(() => {
            if (currentMode === 'scanning') {
                const scanBtn = document.getElementById('startScanBtn');
                const hasScanningClass = scanBtn ? scanBtn.classList.contains('scanning') : false;
                if (hasScanningClass && !isScanning) {
                    console.warn('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INCONSISTENT STATE DETECTED!');
                    console.warn('Button says "Scanning..." but isScanning = false');
                    console.warn('Forcing isScanning = true...');
                    isScanning = true;
                    window.isScanning = true;
                }
            }
        }, 1000); // Check every second

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            disconnect();
        });
    </script>
</body>
</html>


