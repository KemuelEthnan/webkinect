<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Kinect - Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/PLYLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="pointcloud-processor.js"></script>
    <script src="depth-to-mesh.js"></script>
    <script src="ball-pivoting-mesh.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 1.1em;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #44ff44;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        button.active {
            background: linear-gradient(135deg, #44ff44 0%, #00cc00 100%);
            box-shadow: 0 5px 15px rgba(68, 255, 68, 0.4);
        }

        button.scanning {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            animation: pulse-button 1s infinite;
        }

        @keyframes pulse-button {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .video-container {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            position: relative;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cameraImage {
            max-width: 100%;
            max-height: 600px;
            display: block;
        }

        .placeholder {
            color: #888;
            font-size: 1.2em;
        }

        .data-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .data-panel h2 {
            margin-bottom: 15px;
            color: #667eea;
        }

        #skeletonData {
            background: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .info p {
            margin: 5px 0;
        }

        /* 3D Scanning Styles - Skanect-like Layout */
        #scanningTab {
            height: calc(100vh - 200px);
            overflow: hidden;
        }

        .scanning-container {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            grid-template-rows: 1fr;
            height: 100%;
            gap: 0;
            background: #2c3e50;
        }

        /* Left Panel - Depth Camera */
        .depth-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .panel-header {
            padding: 15px;
            background: #2c3e50;
            font-weight: 600;
            color: #ecf0f1;
            border-bottom: 2px solid #667eea;
        }

        .depth-viewer {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #depthCanvas {
            width: 280px;
            height: 210px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: #1a1a1a;
        }

        .depth-legend {
            margin-top: 15px;
            font-size: 12px;
            display: flex;
            gap: 15px;
            color: #ecf0f1;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
        }

        .depth-stats {
            margin-top: 20px;
            font-size: 12px;
            text-align: center;
            color: #95a5a6;
        }

        /* Center Panel - 3D Viewer */
        .viewer-panel {
            background: #1a1a1a;
            position: relative;
        }

        #viewer {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 0;
            overflow: hidden;
            margin-bottom: 0;
        }

        .viewer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            color: #ecf0f1;
            z-index: 10;
        }

        .viewer-overlay .title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

        /* Right Panel - Controls */
        .control-panel {
            background: #34495e;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #2c3e50;
            overflow-y: auto;
        }

        .control-section {
            padding: 20px;
            border-bottom: 1px solid #2c3e50;
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 14px;
            text-transform: uppercase;
        }

        .control-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.3em;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .info-item label {
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #333;
            font-size: 1.1em;
        }

        .info-item .value {
            font-size: 18px;
            font-weight: 700;
            color: #ecf0f1;
        }

        .scan-progress {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .scan-status {
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            color: white;
        }

        .scan-status.idle {
            background: #95a5a6;
        }

        .scan-status.scanning {
            background: #f39c12;
            animation: pulse-bg 1s infinite;
        }

        .scan-status.processing {
            background: #3498db;
        }

        .scan-status.ready {
            background: #2ecc71;
        }

        @keyframes pulse-bg {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .slider-control {
            margin-bottom: 15px;
        }

        .slider-control label {
            font-size: 12px;
            color: #95a5a6;
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2c3e50;
            outline: none;
            -webkit-appearance: none;
            margin: 10px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        @media (max-width: 1200px) {
            .scanning-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Web Kinect Example</h1>
            <div class="status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Menghubungkan ke server...</span>
            </div>
        </div>

        <div class="content">
            <div class="info">
                <p><strong>Catatan:</strong> Pastikan server Kinect sudah berjalan di <code>ws://127.0.0.1:8181</code></p>
                <p>Server dapat dijalankan dengan menjalankan <code>bin/server.exe</code></p>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('normal')">üéÆ Normal Mode</button>
                <button class="tab" onclick="switchTab('scanning')">üì∑ 3D Scanning</button>
            </div>

            <!-- Normal Mode Tab -->
            <div id="normalTab" class="tab-content active">
                <div class="controls">
                    <button id="connectBtn" onclick="connect()">Hubungkan</button>
                    <button id="disconnectBtn" onclick="disconnect()" disabled>Putuskan Koneksi</button>
                    <button id="showBothBtn" onclick="showBothStreams()" disabled>Tampilkan Color & Depth</button>
                    <button id="colorBtn" onclick="setColorMode()" disabled>Hanya Color</button>
                    <button id="depthBtn" onclick="setDepthMode()" disabled>Hanya Depth</button>
                </div>

                <div class="info" style="background: #e8f5e9; border-left: 4px solid #4caf50;">
                    <p><strong>üí° Fitur Baru:</strong> Klik "Tampilkan Color & Depth" untuk melihat kedua stream secara bersamaan (side-by-side)</p>
                </div>

                <div id="dualStreamContainer" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div class="video-container" style="margin-bottom: 0;">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 16px; border-radius: 5px; font-weight: 600; z-index: 10;">üìπ Color Camera</div>
                            <img id="colorImage" style="display: none; max-width: 100%; max-height: 400px;" alt="Color Camera">
                            <div class="placeholder" id="colorPlaceholder">Menunggu data color...</div>
                        </div>
                        <div class="video-container" style="margin-bottom: 0;">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(118, 75, 162, 0.9); color: white; padding: 8px 16px; border-radius: 5px; font-weight: 600; z-index: 10;">üåä Depth Camera</div>
                            <img id="depthImage" style="display: none; max-width: 100%; max-height: 400px;" alt="Depth Camera">
                            <div class="placeholder" id="depthPlaceholder">Menunggu data depth...</div>
                        </div>
                    </div>
                </div>

                <div id="singleStreamContainer" class="video-container">
                    <img id="cameraImage" style="display: none;" alt="Kinect Camera Feed">
                    <div class="placeholder" id="placeholder">Tidak ada data kamera</div>
                </div>

                <div class="data-panel">
                    <h2>üìä Skeleton Data</h2>
                    <div id="skeletonData">Menunggu data skeleton...</div>
                </div>
            </div>

            <!-- 3D Scanning Tab - Skanect-like Layout -->
            <div id="scanningTab" class="tab-content">
                <div class="scanning-container">
                    <!-- Left Panel: Depth Camera View -->
                    <div class="depth-panel">
                        <div class="panel-header">üì∑ Depth Camera (Real-time)</div>
                        <div class="depth-viewer">
                            <canvas id="depthCanvas" width="320" height="240"></canvas>
                            <div class="depth-legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #00ff00;"></div>
                                    <span>Valid (0.5-4m)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #ff0000;"></div>
                                    <span>Invalid</span>
                                </div>
                            </div>
                            <div class="depth-stats">
                                <div>FPS: <span id="depthFps">0</span></div>
                                <div>Points: <span id="depthPoints">0</span></div>
                            </div>
                        </div>
                    </div>

                    <!-- Center Panel: 3D Viewer -->
                    <div class="viewer-panel">
                        <div id="viewer"></div>
                        <div class="viewer-overlay">
                            <div class="title">3D Mesh Viewer</div>
                            <div style="font-size: 12px; line-height: 1.6;">
                                üñ±Ô∏è Drag to rotate<br>
                                üìú Scroll to zoom<br>
                                <span id="meshInfo">No mesh loaded</span>
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel: Controls -->
                    <div class="control-panel">
                        <!-- Connection -->
                        <div class="control-section">
                            <h3>üîå Connection</h3>
                            <button id="connectBtnScan" class="btn-primary" onclick="connect()" style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">Connect to Kinect</button>
                            <button id="disconnectBtnScan" class="btn-danger" onclick="disconnect()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #e74c3c; color: white;">Disconnect</button>
                        </div>

                        <!-- Scanning Controls -->
                        <div class="control-section">
                            <h3>üé¨ Scanning</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Status</label>
                                <div class="scan-status idle" id="scanStatus">Idle</div>
                            </div>
                            <button id="startScanBtn" class="btn-success" onclick="startScan()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #2ecc71; color: white;">üé• Start Record</button>
                            <button id="startPhase2Btn" onclick="startPhase2()" disabled style="display: none; width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #ff9800; color: white;">üîÑ Mulai Fase 2 (Belakang)</button>
                            <button id="stopScanBtn" class="btn-warning" onclick="stopCapture()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #f39c12; color: white;">‚èπÔ∏è Stop Record</button>
                            <button id="removeBgBtn" class="btn-primary" onclick="removeBackground()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">üé® Remove BG</button>
                            <!-- Mesh Generation Method Selection -->
                            <div style="background: rgba(0,0,0,0.05); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <label style="font-size: 13px; font-weight: 600; margin-bottom: 8px; display: block;">Mesh Generation Method:</label>
                                <select id="meshMethod" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 8px;">
                                    <option value="watertight">Watertight (Fast, Local)</option>
                                    <option value="ballpivoting">Ball Pivoting (High Quality, Server)</option>
                                </select>
                                <small style="color: #666; font-size: 11px;">
                                    <span id="meshMethodDesc">Fast processing, good quality</span>
                                </small>
                            </div>
                            <button id="generateMeshBtn" class="btn-primary" onclick="generateMesh()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">üî∑ Generate Mesh</button>
                            <button id="exportSTLBtn" class="btn-primary" onclick="exportSTL()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">üíæ Export STL</button>
                            <button id="clearBtn" class="btn-danger" onclick="clearScan()" disabled style="width: 100%; padding: 12px; margin-bottom: 10px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; background: #e74c3c; color: white;">üóëÔ∏è Clear All</button>
                        </div>

                        <!-- Scan Info -->
                        <div class="control-section">
                            <h3>üìä Scan Info</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Frames Captured</label>
                                <div class="value" id="frameCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Total Points</label>
                                <div class="value" id="pointCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Mesh Vertices</label>
                                <div class="value" id="meshVertices">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Mesh Faces</label>
                                <div class="value" id="meshFaces">0</div>
                            </div>
                            <div class="scan-progress" style="margin-top: 15px;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase; display: block; margin-bottom: 8px;">Progress</label>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                                </div>
                            </div>
                        </div>

                        <!-- Settings -->
                        <div class="control-section">
                            <h3>‚öôÔ∏è Settings</h3>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Max Points per Frame</span>
                                    <span id="maxPointsValue">50000</span>
                                </label>
                                <input type="range" id="maxPointsSlider" min="1000" max="200000" value="50000" step="1000" onchange="document.getElementById('maxPointsValue').textContent = this.value">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Mesh Resolution</span>
                                    <span id="meshResolutionValue">0.02</span>
                                </label>
                                <input type="range" id="meshResolutionSlider" min="0.005" max="0.1" value="0.02" step="0.005" onchange="document.getElementById('meshResolutionValue').textContent = this.value">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Depth Range Min (m)</span>
                                    <span id="depthMinValue">0.5</span>
                                </label>
                                <input type="range" id="depthMinSlider" min="0.3" max="2.0" step="0.1" value="0.5" onchange="updateDepthMin(this.value)">
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Depth Range Max (m)</span>
                                    <span id="depthMaxValue">4.0</span>
                                </label>
                                <input type="range" id="depthMaxSlider" min="1.0" max="8.0" step="0.5" value="4.0" onchange="updateDepthMax(this.value)">
                            </div>
                            <div style="margin-top: 15px; padding: 15px; background: #2c3e50; border-radius: 5px; border: 2px solid #667eea;">
                                <label style="display: flex; align-items: center; gap: 8px; font-weight: bold; color: #ecf0f1; font-size: 12px;">
                                    <input type="checkbox" id="enableMultiPhaseCheckbox" style="width: auto;" onchange="toggleMultiPhaseMode()">
                                    üîÑ Scan /reDua Fase (Depan & Belakang)
                                </label>
                                <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #95a5a6;">
                                    Fase 1: Scan depan (15 detik)<br>
                                    Fase 2: Scan belakang (15 detik)<br>
                                    Hasil: Objek 3D utuh dari kedua sisi
                                </p>
                            </div>
                            <div id="phaseInfo" style="display: none; margin-top: 10px; padding: 10px; background: #2c3e50; border-radius: 5px;">
                                <label style="font-weight: bold; color: #ecf0f1; font-size: 12px;">Fase Saat Ini:</label>
                                <span id="currentPhase" style="font-size: 1.1em; color: #f39c12;">-</span>
                            </div>
                        </div>

                        <!-- Size Control -->
                        <div class="control-section">
                            <h3>üìè Size Control</h3>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Object Scale</span>
                                    <span id="objectScaleValue">1.00x</span>
                                </label>
                                <input type="range" id="objectScaleSlider" min="0.1" max="3.0" value="1.0" step="0.05" oninput="updateObjectScale(this.value)">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustScale(-0.1)" style="flex: 1; padding: 8px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer; font-weight: 600;">‚ûñ Smaller</button>
                                    <button onclick="resetScale()" style="flex: 1; padding: 8px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">‚Ü∫ Reset</button>
                                    <button onclick="adjustScale(0.1)" style="flex: 1; padding: 8px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer; font-weight: 600;">‚ûï Bigger</button>
                                </div>
                            </div>
                            <div class="info-item" style="background: #1e2a3a; color: #ecf0f1; margin-top: 10px;">
                                <label style="color: #95a5a6; font-size: 11px;">üí° TIP</label>
                                <div style="font-size: 11px; color: #95a5a6;">
                                    Adjust object size (0.1x - 3.0x)<br>
                                    ‚úÖ Applied to STL export<br>
                                    ‚úÖ Real size change, not just visual
                                </div>
                            </div>
                        </div>

                        <!-- Position Control -->
                        <div class="control-section">
                            <h3>üìç Position Control</h3>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position X</span>
                                    <input type="number" id="positionXValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionX(this.value)">
                                </label>
                                <input type="range" id="positionXSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionX(this.value); document.getElementById('positionXValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('x', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('x', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position Y</span>
                                    <input type="number" id="positionYValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionY(this.value)">
                                </label>
                                <input type="range" id="positionYSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionY(this.value); document.getElementById('positionYValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('y', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('y', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <div class="slider-control">
                                <label style="color: #95a5a6; font-size: 12px;">
                                    <span>Position Z</span>
                                    <input type="number" id="positionZValue" value="0" step="0.1" style="width: 80px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; padding: 4px;" onchange="updatePositionZ(this.value)">
                                </label>
                                <input type="range" id="positionZSlider" min="-5" max="5" value="0" step="0.1" onchange="updatePositionZ(this.value); document.getElementById('positionZValue').value = this.value">
                                <div style="display: flex; gap: 5px; margin-top: 5px;">
                                    <button onclick="adjustPosition('z', -0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">-</button>
                                    <button onclick="adjustPosition('z', 0.1)" style="flex: 1; padding: 5px; background: #2c3e50; color: #ecf0f1; border: 1px solid #667eea; border-radius: 4px; cursor: pointer;">+</button>
                                </div>
                            </div>
                            <button onclick="resetObjectPosition()" style="width: 100%; padding: 10px; margin-top: 10px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                üîÑ Reset to Center
                            </button>
                            <div style="margin-top: 10px; padding: 10px; background: #2c3e50; border-radius: 5px;">
                                <label style="font-size: 0.9em; color: #95a5a6;">Current Position:</label>
                                <div id="currentPosition" style="font-size: 1.1em; font-weight: 600; color: #ecf0f1;">X: 0.00, Y: 0.00, Z: 0.00</div>
                            </div>
                        </div>

                        <!-- Debug Info -->
                        <div class="control-section">
                            <h3>üîç Debug Info</h3>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Last Message</label>
                                <div style="font-size: 0.9em; color: #ecf0f1;" id="debugMessage">-</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Data Received</label>
                                <div class="value" id="debugDataCount">0</div>
                            </div>
                            <div class="info-item" style="background: #2c3e50; color: #ecf0f1;">
                                <label style="color: #95a5a6; font-size: 11px; text-transform: uppercase;">Point Cloud Frames</label>
                                <div class="value" id="pointCloudFramesCount">0</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var socket = null;
        var connected = false;
        var currentMode = 'normal'; // 'normal' or 'scanning'

        // 3D Scanning variables
        var isScanning = false;
        var isCaptureActive = true; // New flag for auto-capture control
        var pointCloud = [];
        var mesh = null;
        var scene, camera, renderer;
        var viewerInitialized = false;
        var debugDataCount = 0;
        var frameCount = 0;
        var scanTimer = null;
        var scanStartTime = 0;
        var scanDuration = 45000; // Auto-stop after 45 seconds - cukup untuk scan 360 derajat
        var dataReceivedDuringScan = 0;
        var pointCloudDataReceived = 0;
        var maxTotalPoints = 2000000; // Limit to 2M points for ultra high-quality scans
        var autoCaptureTimer = null;
        var manualRecordMode = false; // Auto-stop mode yang lebih reliable
        
        // Multi-phase scanning (depan dan belakang)
        var scanPhase = 0; // 0 = not started, 1 = depan (front), 2 = belakang (back)
        var pointCloudFront = []; // Point cloud from phase 1 (depan)
        var pointCloudBack = []; // Point cloud from phase 2 (belakang)
        var phaseDuration = 15000; // 15 seconds per phase
        var isMultiPhaseMode = false; // Enable/disable multi-phase mode
        
        // Point cloud processing
        var pointCloudProcessor = new PointCloudProcessor();
        var pointCloudFrames = [];
        var useICP = false; // Disabled by default - too CPU intensive!
        var useNoiseFilter = false; // Disabled by default - too CPU intensive!
        var kinectPosition = { x: 0, y: 0, z: 0 };
        // Simpan transformasi terakhir (centering + scaling) agar ekspor sama dengan tampilan
        var lastTransformParams = null;

        // Throttling to prevent freeze
        var lastProcessTime = 0;
        var processingThrottle = 100; // Process max once every 100ms
        var renderThrottle = 50; // Render max once every 50ms
        var lastRenderTime = 0;

        // Depth camera visualization (Skanect-like)
        var depthCanvas = null;
        var depthCtx = null;
        var lastDepthRenderTime = 0;
        var depthFpsCounter = 0;
        var depthFpsInterval = null;
        var depthMin = 0.5; // Minimum depth in meters
        var depthMax = 4.0; // Maximum depth in meters

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            if (tab === 'normal') {
                document.querySelector('.tab:first-child').classList.add('active');
                document.getElementById('normalTab').classList.add('active');
                currentMode = 'normal';
                // Switch back to Color mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("Color");
                }
            } else {
                document.querySelector('.tab:last-child').classList.add('active');
                document.getElementById('scanningTab').classList.add('active');
                currentMode = 'scanning';

                console.log('üîµ Switched to 3D Scanning tab - AUTO-CAPTURE MODE (60 seconds)');
                console.log('üìå Auto-capture will run for 60 seconds (or until max points reached) then stop automatically');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());

                // Initialize depth canvas when switching to scanning tab
                initDepthCanvas();

                // Initialize 3D viewer if not already done
                if (!viewerInitialized) {
                    console.log('üîµ Initializing 3D viewer...');
                    initViewer();
                    viewerInitialized = true;
                }

                // Switch to PointCloud mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("PointCloud");
                    console.log('üì§ Switched to PointCloud mode via tab switch');

                    // Enable buttons
                    const startBtn = document.getElementById('startScanBtn');
                    const stopBtn = document.getElementById('stopScanBtn');
                    if (startBtn) startBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;

                    // Reset and start auto-capture with 15 second timer
                    isCaptureActive = true;
                    scanStartTime = Date.now();

                    // Update status
                    updateScanStatus('scanning', 'Auto-capturing for 60 seconds...');

                    // Auto-stop after scanDuration (60 seconds) OR when max points reached
                    if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
                    autoCaptureTimer = setTimeout(() => {
                        console.log('‚è±Ô∏è ' + (scanDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                        console.log('üìä Final point count:', pointCloud.length.toLocaleString());
                        stopCapture();
                    }, scanDuration);

                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode switch');
                        }
                    }, 100);
                }
            }
        }

        function updateStatus(isConnected) {
            connected = isConnected;
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const connectBtnScan = document.getElementById('connectBtnScan');
            const disconnectBtnScan = document.getElementById('disconnectBtnScan');
            const colorBtn = document.getElementById('colorBtn');
            const depthBtn = document.getElementById('depthBtn');
            const startScanBtn = document.getElementById('startScanBtn');

            if (isConnected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Terhubung ke server - Color Mode';
                if (connectBtn) connectBtn.disabled = true;
                if (disconnectBtn) disconnectBtn.disabled = false;
                if (connectBtnScan) connectBtnScan.disabled = true;
                if (disconnectBtnScan) disconnectBtnScan.disabled = false;
                if (colorBtn) colorBtn.disabled = false;
                if (depthBtn) depthBtn.disabled = false;
                // Set default mode to Color
                if (colorBtn) colorBtn.classList.add('active');
                if (depthBtn) depthBtn.classList.remove('active');
                if (startScanBtn) startScanBtn.disabled = false;
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Tidak terhubung';
                if (connectBtn) connectBtn.disabled = false;
                if (disconnectBtn) disconnectBtn.disabled = true;
                if (connectBtnScan) connectBtnScan.disabled = false;
                if (disconnectBtnScan) disconnectBtnScan.disabled = true;
                if (colorBtn) colorBtn.disabled = true;
                if (depthBtn) depthBtn.disabled = true;
                if (startScanBtn) startScanBtn.disabled = true;
            }
        }

        function connect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            console.log('Connecting to ws://127.0.0.1:8181...');
            socket = new WebSocket("ws://127.0.0.1:8181");

            socket.onopen = function() {
                console.log('Connected to server');
                updateStatus(true);
                // Set initial mode based on current tab
                if (currentMode === 'scanning') {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode on connect');
                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode on connect');
                        }
                    }, 100);
                } else {
                    socket.send("Color");
                    console.log('üì§ Sent Color mode on connect');
                }
            };

            socket.onclose = function() {
                console.log('Disconnected from server');
                updateStatus(false);
                document.getElementById('cameraImage').style.display = 'none';
                document.getElementById('placeholder').style.display = 'block';
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateStatus(false);
                alert('Error: Tidak dapat terhubung ke server. Pastikan server.exe sudah berjalan.');
            };

            socket.onmessage = function(event) {
                // Skeleton data or Point Cloud (JSON string)
                if (typeof event.data === "string") {
                    // Count data received during scan
                    if (isScanning) {
                        dataReceivedDuringScan++;
                    }
                    
                    try {
                        // Log raw data for debugging (show all)
                        console.log('üì• Received string data, length:', event.data.length, 'chars', isScanning ? '(during scan)' : '');
                        console.log('üì• Raw data:', event.data);
                        
                        var data = JSON.parse(event.data);
                        console.log('‚úÖ Parsed JSON successfully. Keys:', Object.keys(data));
                        console.log('üìã Full data structure:', {
                            hasMode: !!data.mode,
                            mode: data.mode,
                            hasData: !!data.data,
                            dataIsArray: Array.isArray(data.data),
                            dataLength: data.data ? data.data.length : 0,
                            hasSkeletons: !!data.skeletons,
                            width: data.width,
                            height: data.height
                        });
                        
                        // Check if it's point cloud data (server sends: {mode: "PointCloud", data: [...], width, height})
                        if (data.mode === 'PointCloud' && data.data && Array.isArray(data.data)) {
                            // Count point cloud data received
                            if (isScanning) {
                                pointCloudDataReceived++;
                            }
                            
                            // Create a new object in the format the rest of the JS expects
                            const pointCloudPayload = { points: data.data };

                            debugDataCount++;
                            const debugMsg = `Received ${pointCloudPayload.points.length} points (Mode: ${currentMode}, Scanning: ${isScanning})`;
                            console.log('‚úÖ‚úÖ‚úÖ Point cloud data received!', {
                                pointCount: pointCloudPayload.points.length,
                                width: data.width,
                                height: data.height,
                                currentMode: currentMode,
                                isScanning: isScanning,
                                firstPoint: pointCloudPayload.points.length > 0 ? pointCloudPayload.points[0] : 'no points',
                                totalPointCloudFrames: pointCloudDataReceived
                            });
                            
                            // Update debug UI
                            const debugMsgEl = document.getElementById('debugMessage');
                            const debugCountEl = document.getElementById('debugDataCount');
                            const pointCloudFramesEl = document.getElementById('pointCloudFramesCount');
                            if (debugMsgEl) debugMsgEl.textContent = debugMsg;
                            if (debugCountEl) debugCountEl.textContent = debugDataCount;
                            if (pointCloudFramesEl) pointCloudFramesEl.textContent = pointCloudDataReceived;
                            
                            // Visualize depth camera (Skanect-like) - always show real-time depth
                            if (currentMode === 'scanning') {
                                const depthData = {
                                    points: pointCloudPayload.points,
                                    width: data.width || 320,
                                    height: data.height || 240
                                };
                                visualizeDepth(depthData);
                            }

                            // üî• RADICAL SIMPLIFICATION: If we're in scanning tab, ALWAYS process point cloud data
                            // This bypasses all the complex isScanning flag logic that keeps failing
                            if (currentMode === 'scanning') {
                                // Check if we should still capture (auto-stop after limit or duration)
                                if (!isCaptureActive) {
                                    console.log('‚è∏Ô∏è Capture stopped - ignoring new data');
                                    return;
                                }

                                // Check if we've hit the point limit
                                if (pointCloud.length >= maxTotalPoints) {
                                    console.log('‚è∏Ô∏è Max points reached (' + maxTotalPoints.toLocaleString() + ') - stopping capture');
                                    stopCapture();
                                    return;
                                }

                                console.log('üîÑ AUTO-PROCESSING depth frame data (mesh mode)...');
                                console.log('üìä Received ' + pointCloudPayload.points.length + ' points');

                                // Process as mesh directly (seperti Skanect) - bukan point cloud
                                if (typeof DepthToMeshConverter !== 'undefined' && depthMeshConverter) {
                                    processDepthFrameAsMesh(pointCloudPayload, data.width, data.height);
                                } else {
                                    // Fallback to point cloud if converter not available
                                    processPointCloud(pointCloudPayload);
                                }

                                // Update scan info
                                const pointCountEl = document.getElementById('pointCount');
                                const frameCountEl = document.getElementById('frameCount');
                                if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
                                if (frameCountEl) frameCountEl.textContent = frameCount;
                            } else {
                                console.log('‚ö†Ô∏è Point cloud data received but not in scanning tab');
                                if (debugMsgEl) debugMsgEl.textContent = 'Data received but not in scanning tab';
                            }
                        } 
                        // Check if it's skeleton data (server sends: {skeletons: [...]})
                        else if (data.skeletons && Array.isArray(data.skeletons)) {
                            // Only process skeleton data in normal mode
                            if (currentMode === 'normal') {
                                document.getElementById('skeletonData').textContent = 
                                    JSON.stringify(data, null, 2);
                                console.log('Skeleton data received:', data);
                            } else {
                                // In scanning mode, ignore skeleton data (it's from old Color mode frames)
                                // But also try to force switch mode again if we keep receiving skeleton data
                                if (isScanning) {
                                    console.log('‚ö†Ô∏è Ignoring skeleton data in scanning mode - server mungkin belum switch mode');
                                    console.log('üîÑ Attempting to force switch to PointCloud mode again...');
                                    
                                    // Force switch again
                                    if (socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send("PointCloud");
                                        console.log('üì§ Re-sent PointCloud mode request');
                                    }
                                    
                                    const debugMsgEl = document.getElementById('debugMessage');
                                    if (debugMsgEl) debugMsgEl.textContent = 'Server masih mengirim skeleton data - mencoba switch mode lagi...';
                                }
                            }
                        } 
                        // Check if it's point cloud data but with empty array (mode active but no valid points)
                        else if (data.mode === 'PointCloud' && (!data.data || !Array.isArray(data.data))) {
                            console.warn('‚ö†Ô∏è PointCloud mode detected but data format invalid:', {
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                dataValue: data.data
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'PointCloud mode active but data format invalid';
                        }
                        // Unknown data format
                        else {
                            console.warn('‚ö†Ô∏è Unknown JSON data format received:', {
                                keys: Object.keys(data),
                                hasMode: !!data.mode,
                                mode: data.mode,
                                hasSkeletons: !!data.skeletons,
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                currentMode: currentMode,
                                fullData: JSON.stringify(data).substring(0, 200)
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'Unknown data format: ' + Object.keys(data).join(', ') + ' | Mode: ' + (data.mode || 'none');
                        }
                    } catch (e) {
                        console.error('‚ùå Error parsing JSON data:', e);
                        console.error('Raw data (first 200 chars):', event.data.substring(0, 200));
                        const debugMsgEl = document.getElementById('debugMessage');
                        if (debugMsgEl) debugMsgEl.textContent = 'Error parsing data: ' + e.message;
                    }
                }
                // Camera feed (Blob) - process in normal mode for both Color and Depth
                else if (event.data instanceof Blob && currentMode === 'normal') {
                    var url = URL.createObjectURL(event.data);
                    var img = document.getElementById('cameraImage');
                    img.src = url;
                    img.style.display = 'block';
                    document.getElementById('placeholder').style.display = 'none';
                    
                    // Revoke old URL to prevent memory leaks
                    if (img.dataset.oldUrl) {
                        URL.revokeObjectURL(img.dataset.oldUrl);
                    }
                    img.dataset.oldUrl = url;
                    
                    // Update status text based on current mode
                    const statusText = document.getElementById('statusText');
                    if (statusText) {
                        // Check if we're in depth mode by checking button state
                        const depthBtn = document.getElementById('depthBtn');
                        if (depthBtn && depthBtn.classList.contains('active')) {
                            statusText.textContent = 'Terhubung ke server - Depth Mode';
                        } else {
                            statusText.textContent = 'Terhubung ke server - Color Mode';
                        }
                    }
                }
            };
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
            updateStatus(false);
        }

        function setColorMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('Switched to Color mode');
                
                // Update button states
                const colorBtn = document.getElementById('colorBtn');
                const depthBtn = document.getElementById('depthBtn');
                if (colorBtn) colorBtn.classList.add('active');
                if (depthBtn) depthBtn.classList.remove('active');
                
                // Update status
                const statusText = document.getElementById('statusText');
                if (statusText) {
                    statusText.textContent = 'Terhubung ke server - Color Mode';
                }
            }
        }

        function setDepthMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Depth");
                console.log('Switched to Depth mode');
                
                // Update button states
                const colorBtn = document.getElementById('colorBtn');
                const depthBtn = document.getElementById('depthBtn');
                if (colorBtn) colorBtn.classList.remove('active');
                if (depthBtn) depthBtn.classList.add('active');
                
                // Update status
                const statusText = document.getElementById('statusText');
                if (statusText) {
                    statusText.textContent = 'Terhubung ke server - Depth Mode';
                }
            }
        }

        // ========== 3D Scanning Functions ==========
        
        // Initialize depth-to-mesh converter (untuk menghasilkan mesh utuh, bukan point cloud)
        let depthMeshConverter = null;
        let meshFrames = []; // Store depth frames for mesh generation
        
        // Initialize converter when page loads
        if (typeof DepthToMeshConverter !== 'undefined') {
            depthMeshConverter = new DepthToMeshConverter();
            console.log('‚úÖ Depth-to-Mesh converter initialized');
        } else {
            console.warn('‚ö†Ô∏è DepthToMeshConverter not loaded - mesh generation will use point cloud');
        }
        
        function initViewer() {
            const container = document.getElementById('viewer');
            if (!container) return;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Ukuran kanvas 3js: 400mm x 400mm (0.4m x 0.4m)
            const canvasSize = 0.4; // 400mm = 0.4m
            const maxObjectSize = 0.35; // 350mm = 0.35m (maksimal ukuran objek)
            
            // Add grid sesuai ukuran kanvas
            // Grid diposisikan di Y = 0 (di atas ground plane)
            const gridHelper = new THREE.GridHelper(canvasSize, 8); // Grid 400mm dengan 8 divisi
            gridHelper.position.y = 0; // Pastikan grid berada di Y = 0
            scene.add(gridHelper);
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(0.5); // Axes standar
            scene.add(axesHelper);
            
            // Hanya grid layout saja, tanpa kotak wireframe
            console.log('‚úÖ Grid layout created:', {
                canvasSize: canvasSize + 'm x ' + canvasSize + 'm (400mm x 400mm)',
                maxObjectSize: maxObjectSize + 'm (350mm)',
                divisions: 8
            });
            
            // Store canvas size globally untuk validasi objek
            window.canvasSize = canvasSize;
            window.maxObjectSize = maxObjectSize;
            
            // Simple orbit controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                    camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * 0.01);
                    camera.lookAt(0, 0, 0);
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const delta = e.deltaY * 0.001;
                camera.position.multiplyScalar(1 + delta);
            });
            
            animate();
        }
        
        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
        }

        // ==================== DEPTH VISUALIZATION (SKANECT STYLE) ====================
        // Initialize depth canvas for real-time depth visualization
        function initDepthCanvas() {
            depthCanvas = document.getElementById('depthCanvas');
            if (depthCanvas) {
                depthCtx = depthCanvas.getContext('2d');
                console.log('‚úÖ Depth canvas initialized');
                
                // Start FPS counter
                if (depthFpsInterval) clearInterval(depthFpsInterval);
                depthFpsInterval = setInterval(() => {
                    const fpsEl = document.getElementById('depthFps');
                    if (fpsEl) fpsEl.textContent = depthFpsCounter;
                    depthFpsCounter = 0;
                }, 1000);
            } else {
                console.warn('‚ö†Ô∏è Depth canvas not found');
            }
        }

        // Visualize depth data in real-time (Skanect-like style)
        function visualizeDepth(depthData) {
            // Throttle rendering to 30 FPS for performance
            const now = Date.now();
            if (now - lastDepthRenderTime < 33) return; // 33ms = ~30 FPS
            lastDepthRenderTime = now;

            // Initialize canvas if not done yet
            if (!depthCanvas || !depthCtx) {
                initDepthCanvas();
                if (!depthCanvas || !depthCtx) return; // Still not available
            }

            const { points, width, height } = depthData;
            if (!points || points.length === 0) return;

            // Update FPS counter
            depthFpsCounter++;

            // Update points count
            const pointsEl = document.getElementById('depthPoints');
            if (pointsEl) pointsEl.textContent = points.length.toLocaleString();

            // Create image data
            const imageData = depthCtx.createImageData(width, height);
            const pixels = imageData.data;

            // Create depth map
            const depthMap = [];
            for (let y = 0; y < height; y++) {
                depthMap[y] = new Array(width).fill(null);
            }

            // Fill depth map from point cloud
            const focalLength = 525.0;
            const centerX = width / 2;
            const centerY = height / 2;

            for (const point of points) {
                const z = Math.abs(point.z);
                if (z <= 0.001) continue;

                // Project to 2D
                const x2d = Math.round((point.x * focalLength / z) + centerX);
                const y2d = Math.round((-point.y * focalLength / z) + centerY);

                if (x2d >= 0 && x2d < width && y2d >= 0 && y2d < height) {
                    depthMap[y2d][x2d] = z;
                }
            }

            // Render with colors (GREEN = valid, RED = invalid, BLACK = no data)
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const depth = depthMap[y][x];

                    if (depth === null) {
                        // No data - black
                        pixels[idx] = 20;
                        pixels[idx + 1] = 20;
                        pixels[idx + 2] = 20;
                        pixels[idx + 3] = 255;
                    } else if (depth >= depthMin && depth <= depthMax) {
                        // Valid depth - GREEN (like Skanect!)
                        pixels[idx] = 0;
                        pixels[idx + 1] = 255;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    } else {
                        // Invalid depth - RED (like Skanect!)
                        pixels[idx] = 255;
                        pixels[idx + 1] = 0;
                        pixels[idx + 2] = 0;
                        pixels[idx + 3] = 255;
                    }
                }
            }

            depthCtx.putImageData(imageData, 0, 0);
        }

        // Update depth range settings
        function updateDepthMin(value) {
            depthMin = parseFloat(value);
            const valueEl = document.getElementById('depthMinValue');
            if (valueEl) valueEl.textContent = value;
        }

        function updateDepthMax(value) {
            depthMax = parseFloat(value);
            const valueEl = document.getElementById('depthMaxValue');
            if (valueEl) valueEl.textContent = value;
        }

        // Update mesh info display
        function updateMeshInfo(vertices, faces) {
            const verticesEl = document.getElementById('meshVertices');
            const facesEl = document.getElementById('meshFaces');
            const meshInfoEl = document.getElementById('meshInfo');
            
            if (verticesEl) verticesEl.textContent = vertices.toLocaleString();
            if (facesEl) facesEl.textContent = Math.floor(faces).toLocaleString();
            
            if (meshInfoEl) {
                if (vertices > 0) {
                    meshInfoEl.textContent = `${vertices.toLocaleString()} vertices, ${Math.floor(faces).toLocaleString()} faces`;
                } else {
                    meshInfoEl.textContent = 'No mesh loaded';
                }
            }
        }

        // Update scan status with proper class (Skanect-like)
        function updateScanStatus(statusClass, statusText) {
            const statusEl = document.getElementById('scanStatus');
            if (statusEl) {
                // Remove all status classes
                statusEl.classList.remove('idle', 'scanning', 'processing', 'ready');
                // Add new status class
                if (statusClass) {
                    statusEl.classList.add(statusClass);
                }
                // Update text
                statusEl.textContent = statusText;
            }
        }
        
        function processPointCloud(data) {
            // üî• CRITICAL: Check if capture is still active - stop processing if not
            if (!isCaptureActive) {
                console.log('‚è∏Ô∏è Capture stopped - ignoring point cloud data');
                return;
            }
            
            // üî• THROTTLING: Skip if processing too frequently (prevent freeze)
            const now = Date.now();
            if (now - lastProcessTime < processingThrottle) {
                console.log('‚è≠Ô∏è Skipping frame (throttle) - too fast');
                return;
            }
            lastProcessTime = now;

            if (!data || !data.points || !Array.isArray(data.points)) {
                console.warn('‚ö†Ô∏è Invalid point cloud data:', data);
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Error: Invalid point cloud data format';
                return;
            }

            // Log even if empty to help debugging
            console.log('üîç Processing', data.points.length, 'points (Frame #' + frameCount + ')');

            if (data.points.length === 0) {
                console.warn('‚ö†Ô∏è Received empty point cloud - mungkin objek tidak terdeteksi atau terlalu jauh/dekat');
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Warning: Empty point cloud - pastikan objek dalam range 0.85-4 meter';
                // Still increment frame count to show that we're receiving data
                frameCount++;
                updateStats();
                return;
            }
            
            const maxPoints = parseInt(document.getElementById('maxPointsSlider').value);
            let newPoints = data.points.slice(0, Math.min(data.points.length, maxPoints));
            
            if (newPoints.length === 0) {
                frameCount++;
                updateStats();
                return;
            }
            
            // Validate point structure
            const firstPoint = newPoints[0];
            if (!firstPoint || !firstPoint.hasOwnProperty('x') || !firstPoint.hasOwnProperty('y') || !firstPoint.hasOwnProperty('z')) {
                console.error('‚ùå Invalid point structure:', firstPoint);
                return;
            }
            
            // Smart ICP Alignment for 360¬∞ scans
            // Strategy: Use ICP only when we have enough reference points and only every N frames
            // This balances quality (proper alignment) with performance (not too CPU intensive)

            // Update Kinect position estimate (for future tracking)
            if (pointCloud.length === 0) {
                kinectPosition = pointCloudProcessor.estimateKinectPosition(newPoints);
            }

            // Filter menggunakan depth camera untuk menangkap objek 3D anggota tubuh
            // Objek dekat (anggota tubuh) akan berwarna merah/oranye, background jauh akan abu-abu/hitam
            // Only apply filter if we have enough points to filter effectively
            let humanBodyPoints = newPoints;
            if (newPoints.length > 100) {
                try {
                    // Filter berdasarkan depth - seperti depth map dengan warna
                    // Objek dekat (0.5-3.5m) = objek target, background sangat jauh (>3.5m) = dihilangkan
                    humanBodyPoints = filterDepthBasedBodyParts(newPoints);
                    // If filter removed too many points (>90%), use original points
                    // Threshold lebih tinggi untuk mempertahankan lebih banyak points
                    if (humanBodyPoints.length < newPoints.length * 0.1) {
                        console.warn('‚ö†Ô∏è Filter too aggressive, using original points');
                        humanBodyPoints = newPoints;
                    }
                } catch (err) {
                    console.error('‚ùå Filter error, using original points:', err);
                    humanBodyPoints = newPoints;
                }
            }

            // ICP Alignment DISABLED - menyebabkan duplikasi parah untuk 360¬∞ scans
            // Strategi yang lebih baik: aggressive voxel-based deduplication
            // ICP hanya cocok untuk multi-phase scan, bukan continuous 360¬∞ scan

            // CRITICAL: Remove duplicate/overlapping points to prevent layering
            // Use voxel-based deduplication for better results
            const beforeDedup = humanBodyPoints.length;
            humanBodyPoints = removeDuplicatePoints(humanBodyPoints, pointCloud);

            console.log('üìä Deduplication: ' + beforeDedup + ' ‚Üí ' + humanBodyPoints.length + ' points');

            // Add filtered and deduplicated points to point cloud
            pointCloud.push(...humanBodyPoints);
            frameCount++;

            const addedCount = humanBodyPoints.length;
            const duplicatesRemoved = beforeDedup - addedCount;
            console.log('‚úÖ Added ' + addedCount + ' points (from ' + newPoints.length + ', duplicates removed: ' + duplicatesRemoved + '). Total: ' + pointCloud.length.toLocaleString());

            // Update display and stats (throttled)
            requestAnimationFrame(() => {
                const now = Date.now();
                if (now - lastRenderTime >= renderThrottle) {
                    updatePointCloudDisplay();
                    // Center model more frequently to keep it visible
                    setTimeout(() => centerModel(), 100);
                    lastRenderTime = now;
                }
                updateStats();
            });
            
            console.log('‚úÖ‚úÖ‚úÖ Successfully added', newPoints.length, 'points. Total:', pointCloud.length, 'points from', frameCount, 'frames');
            
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) {
                const duplicatesRemoved = newPoints.length - humanBodyPoints.length;
                debugMsgEl.textContent = `‚úÖ Added ${humanBodyPoints.length} points (removed ${duplicatesRemoved} duplicates/background). Total: ${pointCloud.length} points`;
            }
        }
        
        /**
         * Process depth frame as mesh directly (seperti Skanect)
         * Menghasilkan mesh utuh, bukan point cloud terpisah
         */
        function processDepthFrameAsMesh(payload, width, height) {
            if (!depthMeshConverter || !payload || !payload.points) {
                console.warn('‚ö†Ô∏è Cannot process as mesh - falling back to point cloud');
                processPointCloud(payload);
                return;
            }
            
            console.log('üî∑ Processing depth frame as mesh (utuh, bukan point cloud)...');
            
            // Store frame for accumulation
            meshFrames.push({
                points: payload.points,
                width: width || 320,
                height: height || 240
            });
            
            // Limit frames to prevent memory issues (keep last 10 frames)
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }
            
            // Generate mesh from accumulated frames
            // This creates a continuous surface, not separate points
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);
            
            if (geometry) {
                // Remove old mesh if exists
                const oldMesh = scene.getObjectByName('depthMesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Create mesh material with vertex colors
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // Create mesh object
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'depthMesh';
                
                // Posisikan mesh di atas grid (Y >= 0)
                const box = new THREE.Box3().setFromObject(mesh);
                if (!box.isEmpty()) {
                    const boxMin = box.min;
                    const yOffset = -boxMin.y; // Offset untuk memindahkan mesh ke Y = 0
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Pastikan mesh selalu berada di atas grid (Y >= 0)
                    const finalY = Math.max(0, yOffset);
                    mesh.position.set(
                        -center.x, // Center X
                        finalY, // Di atas grid (Y >= 0)
                        -center.z  // Center Z
                    );
                    mesh.updateMatrixWorld(); // Update matrix setelah positioning
                }
                
                // Add to scene
                scene.add(mesh);
                
                // Hide point cloud if mesh is shown
                const pointCloudObj = scene.getObjectByName('pointCloud');
                if (pointCloudObj) {
                    pointCloudObj.visible = false;
                }
                
                // Update stats
                const pointCountEl = document.getElementById('pointCount');
                if (pointCountEl) {
                    pointCountEl.textContent = geometry.attributes.position.count.toLocaleString() + ' vertices';
                }
                
                // Center camera
                setTimeout(() => centerModel(), 100);
                
                console.log('‚úÖ Mesh updated:', {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0
                });
            } else {
                console.warn('‚ö†Ô∏è Failed to generate mesh, falling back to point cloud');
                processPointCloud(payload);
            }
        }
        
        /**
         * Process depth frame as mesh directly (seperti Skanect)
         * Menghasilkan mesh utuh, bukan point cloud terpisah
         */
        function processDepthFrameAsMesh(payload, width, height) {
            if (!depthMeshConverter || !payload || !payload.points) {
                console.warn('‚ö†Ô∏è Cannot process as mesh - falling back to point cloud');
                processPointCloud(payload);
                return;
            }
            
            console.log('üî∑ Processing depth frame as mesh (utuh, bukan point cloud)...');
            
            // Store frame for accumulation
            meshFrames.push({
                points: payload.points,
                width: width || 320,
                height: height || 240
            });
            
            // Limit frames to prevent memory issues (keep last 10 frames)
            if (meshFrames.length > 10) {
                meshFrames.shift();
            }
            
            // Generate mesh from accumulated frames
            // This creates a continuous surface, not separate points
            const geometry = depthMeshConverter.mergeDepthFrames(meshFrames);
            
            if (geometry) {
                // Remove old mesh if exists
                const oldMesh = scene.getObjectByName('depthMesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Create mesh material with vertex colors
                const material = new THREE.MeshStandardMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false
                });
                
                // Create mesh object
                const mesh = new THREE.Mesh(geometry, material);
                mesh.name = 'depthMesh';
                
                // Validasi ukuran mesh: tidak boleh lebih besar dari 350mm (0.35m)
                const maxObjectSize = window.maxObjectSize || 0.35; // 350mm
                const box = new THREE.Box3().setFromObject(mesh);
                if (!box.isEmpty()) {
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    
                    let scaleFactor = 1.0;
                    if (maxDim > maxObjectSize) {
                        scaleFactor = maxObjectSize / maxDim;
                        console.warn('‚ö†Ô∏è Depth mesh terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm (scale: ' + scaleFactor.toFixed(3) + ')');
                        mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                        // Recalculate box after scaling
                        box.setFromObject(mesh);
                    }
                    
                    const boxMin = box.min;
                    const yOffset = -boxMin.y; // Offset untuk memindahkan mesh ke Y = 0
                    const center = box.getCenter(new THREE.Vector3());
                    
                    // Pastikan mesh selalu berada di atas grid (Y >= 0)
                    const finalY = Math.max(0, yOffset);
                    mesh.position.set(
                        -center.x, // Center X
                        finalY, // Di atas grid (Y >= 0)
                        -center.z  // Center Z
                    );
                    mesh.updateMatrixWorld(); // Update matrix setelah positioning
                }
                
                // Add to scene
                scene.add(mesh);
                
                // Hide point cloud if mesh is shown
                const pointCloudObj = scene.getObjectByName('pointCloud');
                if (pointCloudObj) {
                    pointCloudObj.visible = false;
                }
                
                // Update stats
                const pointCountEl = document.getElementById('pointCount');
                if (pointCountEl) {
                    pointCountEl.textContent = geometry.attributes.position.count.toLocaleString() + ' vertices';
                }
                
                // Center camera
                setTimeout(() => centerModel(), 100);
                
                console.log('‚úÖ Mesh updated:', {
                    vertices: geometry.attributes.position.count,
                    faces: geometry.index ? geometry.index.count / 3 : 0
                });
            } else {
                console.warn('‚ö†Ô∏è Failed to generate mesh, falling back to point cloud');
                processPointCloud(payload);
            }
        }
        
        function updatePointCloudDisplay() {
            if (!scene) {
                console.warn('Scene not initialized');
                return;
            }

            const oldPointCloud = scene.getObjectByName('pointCloud');
            if (oldPointCloud) {
                scene.remove(oldPointCloud);
            }

            if (pointCloud.length === 0) {
                console.log('No points to display');
                return;
            }

            console.log('Updating point cloud display with', pointCloud.length, 'points');

            // PASS 1: Calculate raw bounds and center from Kinect coordinates
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            for (let i = 0; i < pointCloud.length; i++) {
                const point = pointCloud[i];
                const x = point.x || 0;
                const y = point.y || 0;
                const z = point.z || 0;

                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }

            console.log('Point cloud RAW bounds (Kinect coordinates):', {
                x: [minX, maxX],
                y: [minY, maxY],
                z: [minZ, maxZ]
            });

            // Calculate center and size
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);

            // Calculate scale factor to fit within canvas (max 350mm)
            const canvasSize = window.canvasSize || 0.4; // 400mm canvas
            const maxObjectSize = window.maxObjectSize || 0.35; // 350mm max object
            let scaleFactor = 1.0;

            if (maxDim > maxObjectSize) {
                scaleFactor = maxObjectSize / maxDim;
                console.warn('‚ö†Ô∏è Point cloud terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm (scale: ' + scaleFactor.toFixed(3) + ')');
            }

            // Simpan parameter transformasi untuk dipakai ulang (export STL dll)
            lastTransformParams = {
                centerX,
                centerY,
                centerZ,
                minY,
                scaleFactor
            };

            console.log('üìä Transformation params:', {
                center: [centerX, centerY, centerZ],
                size: [sizeX, sizeY, sizeZ],
                scaleFactor: scaleFactor
            });

            // PASS 2: Transform coordinates to canvas space
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCloud.length * 3);
            const colors = new Float32Array(pointCloud.length * 3);

            // Track transformed bounds for verification
            let transformedMinY = Infinity;
            let transformedMaxY = -Infinity;

            for (let i = 0; i < pointCloud.length; i++) {
                const point = pointCloud[i];

                // Get raw Kinect coordinates
                const rawX = point.x || 0;
                const rawY = point.y || 0;
                const rawZ = point.z || 0;

                // Transform to canvas space:
                // 1. Translate to center at origin
                // 2. Apply scale factor
                // 3. Position so bottom of object is at Y=0 (on the canvas grid)
                const x = (rawX - centerX) * scaleFactor;
                const y = (rawY - minY) * scaleFactor; // minY becomes 0 (on grid)
                const z = (rawZ - centerZ) * scaleFactor;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                colors[i * 3] = (point.r || 128) / 255;
                colors[i * 3 + 1] = (point.g || 128) / 255;
                colors[i * 3 + 2] = (point.b || 128) / 255;

                transformedMinY = Math.min(transformedMinY, y);
                transformedMaxY = Math.max(transformedMaxY, y);
            }

            console.log('Point cloud TRANSFORMED bounds (Canvas coordinates):', {
                yRange: [transformedMinY, transformedMaxY],
                expectedHeight: (sizeY * scaleFactor).toFixed(3) + 'm'
            });

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.003, // Ukuran point yang sesuai untuk detail tinggi
                vertexColors: true,
                sizeAttenuation: true // Enable size attenuation for depth perception
            });

            const pointsObj = new THREE.Points(geometry, material);
            pointsObj.name = 'pointCloud';

            // Objek sudah di-transform, tidak perlu scaling atau positioning tambahan
            // Langsung add ke scene di posisi origin
            pointsObj.position.set(0, 0, 0);
            scene.add(pointsObj);

            console.log('‚úÖ Point cloud added to scene at origin (0,0,0)');
            console.log('üìè Object dimensions: ' +
                (sizeX * scaleFactor * 1000).toFixed(0) + 'mm x ' +
                (sizeY * scaleFactor * 1000).toFixed(0) + 'mm x ' +
                (sizeZ * scaleFactor * 1000).toFixed(0) + 'mm');

            // Posisikan kamera untuk melihat objek dengan baik
            // Objek berada di origin dengan tinggi (sizeY * scaleFactor)
            const objectHeight = sizeY * scaleFactor;
            const objectWidth = Math.max(sizeX * scaleFactor, sizeZ * scaleFactor);

            // Hitung jarak kamera optimal
            const fov = camera.fov * (Math.PI / 180);
            const distance = Math.max(objectWidth, objectHeight) / (2 * Math.tan(fov / 2)) * 1.5;

            // Posisikan kamera di depan objek, sedikit di atas untuk perspektif yang baik
            camera.position.set(0, objectHeight * 0.5, distance);
            camera.lookAt(0, objectHeight * 0.5, 0);
            camera.updateProjectionMatrix();

            console.log('üì∑ Camera positioned at:', camera.position, 'looking at:', new THREE.Vector3(0, objectHeight * 0.5, 0));
        }
        
        /**
         * Bounding box dihilangkan - objek pure di atas kanvas tanpa kotak wireframe
         */
        function updateBoundingBox(minX, maxX, minY, maxY, minZ, maxZ) {
            // Bounding box dihilangkan sesuai permintaan user
            // Hapus bounding box jika ada
            if (!scene) return;
            const oldBoundingBox = scene.getObjectByName('boundingBox');
            if (oldBoundingBox) {
                scene.remove(oldBoundingBox);
            }
        }
        
        function startScan() {
            console.log('üîµüîµüîµ startScan() called - SIMPLIFIED MODE üîµüîµüîµ');

            if (!connected) {
                alert('Harus terhubung ke server terlebih dahulu!');
                console.error('‚ùå Cannot start scan: not connected');
                return;
            }

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif! Silakan hubungkan terlebih dahulu.');
                console.error('‚ùå Cannot start scan: WebSocket not open');
                return;
            }

            // Check if multi-phase mode is enabled
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox')?.checked || false;
            
            if (isMultiPhaseMode) {
                // Multi-phase mode: Phase 1 (depan)
                scanPhase = 1;
                pointCloudFront = [];
                pointCloudBack = [];
                pointCloud = []; // Reset current point cloud
                console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 1 (Depan/Front)');
                console.log('üìå Duration: 45 seconds (or stop manually)');
            } else {
                // Normal mode: auto-stop 45 detik untuk scan 360 derajat
                scanPhase = 0;
                pointCloud = [];
                console.log('üé• Starting SCAN MODE untuk scan 360 derajat');
                console.log('üìå Duration: 45 seconds (cukup untuk scan 360¬∞)');
                console.log('üìå Bergerak 360¬∞ mengelilingi objek untuk menangkap semua sisi');
                console.log('üìå Scan akan otomatis berhenti setelah 45 detik');
                console.log('üìå Atau klik "Stop Record" untuk berhenti lebih awal');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());
            }

            // Reset data
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();

            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;
            currentMode = 'scanning'; // CRITICAL: Ensure currentMode is set for data processing

            // AUTO-STOP TIMER - 45 detik untuk scan 360 derajat
            // User bisa stop lebih awal dengan button Stop Record
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);

            const currentDuration = isMultiPhaseMode ? phaseDuration : scanDuration;

            if (currentDuration > 0) {
                autoCaptureTimer = setTimeout(() => {
                    console.log('‚è±Ô∏è ' + (currentDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                    console.log('üìä Final point count:', pointCloud.length.toLocaleString());

                    if (isMultiPhaseMode && scanPhase === 1) {
                        pointCloudFront = [...pointCloud];
                        console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                        stopCapture();
                        document.getElementById('startPhase2Btn').style.display = 'inline-block';
                        document.getElementById('startPhase2Btn').disabled = false;
                        updateScanStatus('ready', 'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2"');
                    } else {
                        stopCapture();
                    }
                }, currentDuration);

                console.log('‚è±Ô∏è Auto-stop timer set: ' + (currentDuration / 1000) + ' seconds');
            } else {
                console.warn('‚ö†Ô∏è No auto-stop timer (scanDuration = 0)');
            }
            
            // Get settings
            // ICP dan Noise Filtering dihapus karena membuat objek tidak karuan
            useICP = false;
            useNoiseFilter = false;
            
            // Clear any existing timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = isMultiPhaseMode ? 'üî¥ Scanning Fase 1...' : 'üî¥ Scanning (45s)...';
            document.getElementById('stopScanBtn').disabled = false;
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('clearBtn').disabled = false;
            updateScanStatus('scanning', isMultiPhaseMode ? 'Scanning Fase 1 (45 detik)...' : 'üé• Scanning 360¬∞ (45 detik) - Bergerak mengelilingi objek');
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            if (isMultiPhaseMode) {
                document.getElementById('currentPhase').textContent = 'Fase 1: Depan (45s)';
            }
            
            // Send PointCloud mode request directly and multiple times to ensure server receives it
            console.log('üîÑ Switching server mode to PointCloud...');
            
            // Send immediately
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request to server (attempt 1)');
            
            // Send multiple times with delays to ensure server processes it
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 2)');
                }
            }, 50);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 3)');
                }
            }, 150);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 4)');
                }
            }, 300);
            
            // Start progress bar update timer
            scanTimer = setInterval(() => {
                if (!isScanning) {
                    clearInterval(scanTimer);
                    return;
                }
                
                const elapsed = Date.now() - scanStartTime;
                const progress = Math.min(100, (elapsed / scanDuration) * 100);
                
                const progressFillEl = document.getElementById('progressFill');
                if (progressFillEl) {
                    progressFillEl.style.width = progress + '%';
                    progressFillEl.textContent = Math.round(progress) + '%';
                }
                
                // Auto-stop after scan duration
                if (elapsed >= scanDuration) {
                    console.log('‚è±Ô∏è Scan duration completed, stopping automatically...');
                    stopScan();
                }
            }, 50); // Update every 50ms for smooth progress bar
            
            // Update debug message
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) debugMsgEl.textContent = 'Waiting for PointCloud data from server...';
        }
        
        /**
         * Toggle multi-phase mode on/off
         */
        function toggleMultiPhaseMode() {
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox').checked;
            const phaseInfoEl = document.getElementById('phaseInfo');
            if (phaseInfoEl) {
                phaseInfoEl.style.display = isMultiPhaseMode ? 'block' : 'none';
            }
            
            if (isMultiPhaseMode) {
                console.log('üîÑ Multi-phase mode ENABLED');
                document.getElementById('currentPhase').textContent = 'Belum dimulai';
            } else {
                console.log('üîÑ Multi-phase mode DISABLED');
                scanPhase = 0;
            }
        }
        
        /**
         * Start Phase 2 (belakang/back) scanning
         */
        function startPhase2() {
            if (!connected || !socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif!');
                return;
            }
            
            if (pointCloudFront.length === 0) {
                alert('Fase 1 belum selesai atau tidak ada data!');
                return;
            }
            
            console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 2 (Belakang/Back)');
            console.log('üìå Duration: 15 seconds');
            console.log('üìå Phase 1 points: ' + pointCloudFront.length.toLocaleString());
            
            // Set phase 2
            scanPhase = 2;
            pointCloudBack = [];
            pointCloud = []; // Reset current point cloud for phase 2
            
            // Reset counters
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();
            
            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;
            
            // Auto-stop after phaseDuration (15 seconds)
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
            autoCaptureTimer = setTimeout(() => {
                console.log('‚è±Ô∏è Phase 2 (15 seconds) elapsed - auto-stopping capture');
                pointCloudBack = [...pointCloud];
                console.log('‚úÖ Phase 2 (Belakang) complete: ' + pointCloudBack.length.toLocaleString() + ' points');
                
                // Merge both phases
                mergePhasePointClouds();
                
                stopCapture();
            }, phaseDuration);
            
            // Update UI
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = 'Scanning Fase 2...';
            document.getElementById('stopScanBtn').disabled = false;
            updateScanStatus('scanning', 'Scanning Fase 2 (Belakang)...');
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            document.getElementById('currentPhase').textContent = 'Fase 2: Belakang';
            
            // Send PointCloud mode request
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request for Phase 2');
        }
        
        /**
         * Merge point clouds from Phase 1 (depan) and Phase 2 (belakang)
         * Uses ICP alignment for accurate registration
         * Combines both point clouds into one complete 3D object
         */
        function mergePhasePointClouds() {
            console.log('üîó Merging point clouds from Phase 1 and Phase 2 with ICP alignment...');
            console.log('üìä Phase 1 (Depan): ' + pointCloudFront.length.toLocaleString() + ' points');
            console.log('üìä Phase 2 (Belakang): ' + pointCloudBack.length.toLocaleString() + ' points');
            
            if (pointCloudFront.length === 0 && pointCloudBack.length === 0) {
                console.warn('‚ö†Ô∏è No points to merge!');
                return;
            }
            
            // If only one phase has data, use it directly
            if (pointCloudFront.length === 0) {
                pointCloud = [...pointCloudBack];
                console.log('‚ö†Ô∏è Only Phase 2 data available');
            } else if (pointCloudBack.length === 0) {
                pointCloud = [...pointCloudFront];
                console.log('‚ö†Ô∏è Only Phase 1 data available');
            } else {
                // Both phases have data - perform ICP alignment
                console.log('üîÑ Performing ICP alignment for multi-phase registration...');
                
                // Step 1: Initial alignment - rotate back point cloud 180¬∞ around Y-axis
                // This assumes the object was rotated 180¬∞ between phases
                const rotatedBack = pointCloudBack.map(p => ({
                    x: -p.x,  // Flip X (rotate 180¬∞ around Y)
                    y: p.y,   // Keep Y (vertical axis)
                    z: -p.z,  // Flip Z (rotate 180¬∞ around Y)
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                console.log('‚úÖ Applied initial 180¬∞ rotation to Phase 2');
                
                // Step 2: Center both point clouds for better alignment
                const frontCenter = calculateCentroid(pointCloudFront);
                const backCenter = calculateCentroid(rotatedBack);
                
                const centeredFront = pointCloudFront.map(p => ({
                    x: p.x - frontCenter.x,
                    y: p.y - frontCenter.y,
                    z: p.z - frontCenter.z,
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                const centeredBack = rotatedBack.map(p => ({
                    x: p.x - backCenter.x,
                    y: p.y - backCenter.y,
                    z: p.z - backCenter.z,
                    r: p.r,
                    g: p.g,
                    b: p.b
                }));
                
                // Step 3: Perform ICP alignment
                console.log('üîÑ Running ICP algorithm...');
                const icpResult = pointCloudProcessor.icpAlign(
                    centeredBack,
                    centeredFront,
                    50,  // maxIterations
                    0.01  // tolerance (1cm)
                );
                
                if (icpResult.transform) {
                    console.log('‚úÖ ICP alignment successful');
                    
                    // Step 4: Apply ICP transform and restore original positions
                    const alignedBack = icpResult.alignedPoints.map(p => ({
                        x: p.x + frontCenter.x, // Restore to front center position
                        y: p.y + frontCenter.y,
                        z: p.z + frontCenter.z,
                        r: p.r,
                        g: p.g,
                        b: p.b
                    }));
                    
                    // Step 5: Merge aligned point clouds with overlap removal
                    pointCloud = mergeWithOverlapRemoval(pointCloudFront, alignedBack, 0.02); // 2cm overlap threshold
                    
                    console.log('‚úÖ Merged with ICP: ' + pointCloud.length.toLocaleString() + ' points (removed ' + 
                        (pointCloudFront.length + pointCloudBack.length - pointCloud.length).toLocaleString() + ' duplicates)');
                } else {
                    console.warn('‚ö†Ô∏è ICP alignment failed, using simple merge');
                    // Fallback: simple merge with initial rotation
                    pointCloud = [...pointCloudFront, ...rotatedBack];
                }
            }
            
            console.log('‚úÖ Final merged point cloud: ' + pointCloud.length.toLocaleString() + ' points total');
            
            // Update display
            updatePointCloudDisplay();
            centerModel();
            
            // Update UI
            updateScanStatus('ready', 
                'Scan selesai! ' + pointCloud.length.toLocaleString() + ' points (Depan: ' + 
                pointCloudFront.length.toLocaleString() + ', Belakang: ' + 
                pointCloudBack.length.toLocaleString() + ')');
            document.getElementById('pointCount').textContent = pointCloud.length.toLocaleString();
            document.getElementById('removeBgBtn').disabled = false;
            document.getElementById('generateMeshBtn').disabled = false;
            document.getElementById('exportSTLBtn').disabled = false;
            document.getElementById('currentPhase').textContent = 'Selesai - Objek 3D Utuh';
        }
        
        /**
         * Calculate centroid of point cloud
         */
        function calculateCentroid(points) {
            if (points.length === 0) return { x: 0, y: 0, z: 0 };
            
            let sumX = 0, sumY = 0, sumZ = 0;
            for (const p of points) {
                sumX += p.x;
                sumY += p.y;
                sumZ += p.z;
            }
            
            return {
                x: sumX / points.length,
                y: sumY / points.length,
                z: sumZ / points.length
            };
        }
        
        /**
         * Merge two point clouds with overlap removal using voxel-based deduplication
         */
        function mergeWithOverlapRemoval(points1, points2, voxelSize = 0.01) {
            const merged = [...points1];
            const voxelMap = new Map();
            
            // Add points1 to voxel map
            points1.forEach(p => {
                const gx = Math.floor(p.x / voxelSize);
                const gy = Math.floor(p.y / voxelSize);
                const gz = Math.floor(p.z / voxelSize);
                const key = `${gx},${gy},${gz}`;
                voxelMap.set(key, true);
            });
            
            // Add points2 only if voxel is empty
            points2.forEach(p => {
                const gx = Math.floor(p.x / voxelSize);
                const gy = Math.floor(p.y / voxelSize);
                const gz = Math.floor(p.z / voxelSize);
                const key = `${gx},${gy},${gz}`;
                
                if (!voxelMap.has(key)) {
                    merged.push(p);
                    voxelMap.set(key, true);
                }
            });
            
            return merged;
        }
        
        function stopCapture() {
            console.log('‚èπÔ∏è Stopping scan...');
            isCaptureActive = false;
            isScanning = false;

            // Clear timers
            if (autoCaptureTimer) {
                clearTimeout(autoCaptureTimer);
                autoCaptureTimer = null;
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop point cloud data');
            }

            // Handle multi-phase mode
            if (isMultiPhaseMode && scanPhase === 1) {
                // Phase 1 complete - save to pointCloudFront
                pointCloudFront = [...pointCloud];
                console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                
                // Update UI for Phase 2
                document.getElementById('startPhase2Btn').style.display = 'inline-block';
                document.getElementById('startPhase2Btn').disabled = false;
                updateScanStatus('ready', 
                    'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2" (' + 
                    pointCloudFront.length.toLocaleString() + ' points)');
                document.getElementById('currentPhase').textContent = 'Fase 1 selesai - Menunggu Fase 2';
                
                // Reset UI buttons
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'üé• Start Record';
                document.getElementById('stopScanBtn').disabled = true;

                return; // Don't enable mesh/export yet - wait for Phase 2
            } else if (isMultiPhaseMode && scanPhase === 2) {
                // Phase 2 complete - already merged in timeout handler
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'üé• Start Record';
                document.getElementById('stopScanBtn').disabled = true;
                return;
            }

            // Normal mode or both phases complete
            // AUTO-REMOVE BACKGROUND after scan complete
            if (pointCloud.length > 0) {
                console.log('üîç AUTO-REMOVING BACKGROUND after scan...');
                const beforeClean = pointCloud.length;

                // Apply balanced filter to remove background
                const cleanedPoints = pointCloud.filter(p => {
                    const dist = Math.abs(p.z || 0);
                    const yPos = p.y || 0;
                    // Moderate filter: keep object, remove obvious background
                    // Z range: 0.5-3.0m (remove far background)
                    // Y range: -1.0-1.8m (remove floor/ceiling)
                    return dist >= 0.5 && dist <= 3.0 && yPos >= -1.0 && yPos <= 1.8;
                });

                // Only apply if we still have enough points (at least 30% retained)
                const retentionRate = cleanedPoints.length / beforeClean;
                if (retentionRate >= 0.3 && cleanedPoints.length >= 1000) {
                    pointCloud = cleanedPoints;
                    console.log('‚úÖ Background removed: ' + beforeClean.toLocaleString() + ' ‚Üí ' +
                        pointCloud.length.toLocaleString() + ' points (' +
                        (retentionRate * 100).toFixed(1) + '% retained)');

                    // Update display with cleaned point cloud
                    updatePointCloudDisplay();
                } else {
                    console.warn('‚ö†Ô∏è Background filter too aggressive (' + (retentionRate * 100).toFixed(1) + '%), keeping original points');
                }
            }

            // Update UI
            updateScanStatus('ready', pointCloud.length > 0 ?
                '‚úÖ Scan completed - ' + pointCloud.length.toLocaleString() + ' points (background removed)' :
                'Scan stopped - No data');

            // Enable buttons if we have points
            if (pointCloud.length > 0) {
                document.getElementById('removeBgBtn').disabled = false;
                document.getElementById('generateMeshBtn').disabled = false;
                document.getElementById('exportSTLBtn').disabled = false; // Enable export even without mesh
                document.getElementById('clearBtn').disabled = false; // Enable clear button
                console.log('‚úÖ Scan completed. Total: ' + pointCloud.length.toLocaleString() + ' points from ' + frameCount + ' frames');
                console.log('üìå Siap untuk Generate Watertight atau Export STL');

                // Auto-center the point cloud
                centerModel();
            } else {
                document.getElementById('clearBtn').disabled = true; // Disable clear if no data
            }

            // Reset UI buttons
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'üé• Start Record';
            document.getElementById('stopScanBtn').disabled = true;
        }

        function stopScan() {
            if (!isScanning) return; // Already stopped

            console.log('üõë Stopping scan...');
            isScanning = false;
            stopCapture();
            
            // Clear timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'Mulai Scan';
            updateScanStatus('ready', pointCloud.length > 0 ? 'Selesai - Siap untuk Generate Watertight' : 'Selesai - Tidak ada data');
            
            // Set progress to 100%
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '100%';
                progressFillEl.textContent = '100%';
            }
            
            // Log statistics
            console.log('üìä Scan Statistics:', {
                totalDataReceived: dataReceivedDuringScan,
                pointCloudDataReceived: pointCloudDataReceived,
                skeletonDataReceived: dataReceivedDuringScan - pointCloudDataReceived,
                pointsCollected: pointCloud.length,
                framesProcessed: frameCount
            });
            
            // Enable generate mesh button if we have points
            if (pointCloud.length > 0) {
                document.getElementById('removeBgBtn').disabled = false;
                document.getElementById('generateMeshBtn').disabled = false;
                console.log('‚úÖ Scan completed with', pointCloud.length, 'points from', frameCount, 'frames');
            } else {
                console.warn('‚ö†Ô∏è Scan completed but no points collected');
                
                // Provide detailed error message based on what we received
                let errorMsg = 'Scanning selesai tapi tidak ada data yang terkumpul.\n\n';
                
                if (dataReceivedDuringScan === 0) {
                    errorMsg += '‚ùå MASALAH: Server TIDAK mengirim data sama sekali!\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Pastikan server.exe berjalan\n';
                    errorMsg += '2. Restart server.exe\n';
                    errorMsg += '3. Cek apakah Kinect terhubung dan terdeteksi\n';
                    errorMsg += '4. Tampilkan console server untuk lihat error:\n';
                    errorMsg += '   - Edit source/Program.cs line 26\n';
                    errorMsg += '   - Ganti CONSOLE_HIDE menjadi CONSOLE_SHOW\n';
                    errorMsg += '   - Recompile server\n';
                } else if (pointCloudDataReceived === 0) {
                    errorMsg += '‚ùå MASALAH: Server mengirim data tapi BUKAN point cloud!\n\n';
                    errorMsg += 'Server mengirim ' + (dataReceivedDuringScan - pointCloudDataReceived) + ' skeleton data.\n';
                    errorMsg += 'Server TIDAK switch ke PointCloud mode.\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Restart server.exe\n';
                    errorMsg += '2. Pastikan server support PointCloud mode\n';
                    errorMsg += '3. Cek console server untuk error\n';
                } else {
                    errorMsg += '‚ö†Ô∏è Server mengirim ' + pointCloudDataReceived + ' frame point cloud, tapi semua kosong.\n\n';
                    errorMsg += 'Pastikan:\n';
                    errorMsg += '- Objek berada dalam range 0.85-4 meter dari Kinect\n';
                    errorMsg += '- Objek cukup besar dan jelas\n';
                    errorMsg += '- Lighting cukup\n';
                    errorMsg += '- Objek tidak transparan atau reflektif\n';
                }
                
                alert(errorMsg);
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched back to Color mode');
            }
        }
        
        /**
         * Remove background points dari point cloud
         * Menghapus bagian belakang (kiri) yang merupakan background
         * Mempertahankan bagian depan (kanan) yang merupakan objek utama
         */
        function removeBackground() {
            if (pointCloud.length === 0) {
                alert('Tidak ada point cloud untuk di-remove background! Silakan lakukan scanning terlebih dahulu.');
                return;
            }
            
            console.log('üé® Removing background from', pointCloud.length, 'points...');
            updateScanStatus('processing', 'Removing background...');
            
            // Disable button selama proses
            const removeBgBtn = document.getElementById('removeBgBtn');
            if (removeBgBtn) {
                removeBgBtn.disabled = true;
                removeBgBtn.textContent = '‚è≥ Removing BG...';
            }
            
            try {
                // Analisis distribusi point cloud untuk mengidentifikasi background vs foreground
                // Background biasanya berada di bagian belakang (Z lebih besar/jauh) atau kiri (X lebih kecil)
                
                // Hitung statistik posisi untuk menentukan threshold
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;
                let minZ = Infinity, maxZ = -Infinity;
                
                pointCloud.forEach(p => {
                    minX = Math.min(minX, p.x || 0);
                    maxX = Math.max(maxX, p.x || 0);
                    minY = Math.min(minY, p.y || 0);
                    maxY = Math.max(maxY, p.y || 0);
                    minZ = Math.min(minZ, p.z || 0);
                    maxZ = Math.max(maxZ, p.z || 0);
                });
                
                const rangeX = maxX - minX;
                const rangeZ = maxZ - minZ;
                
                console.log('üìä Point cloud bounds:', {
                    X: [minX.toFixed(3), maxX.toFixed(3), 'range:', rangeX.toFixed(3)],
                    Y: [minY.toFixed(3), maxY.toFixed(3)],
                    Z: [minZ.toFixed(3), maxZ.toFixed(3), 'range:', rangeZ.toFixed(3)]
                });
                
                // Strategi: Gunakan kombinasi Z (depth) dan X (kiri/kanan) untuk mengidentifikasi background
                // Background = bagian belakang (Z lebih besar) atau kiri (X lebih kecil)
                
                // Hitung median untuk threshold yang lebih robust
                const zValues = pointCloud.map(p => p.z || 0).sort((a, b) => a - b);
                const xValues = pointCloud.map(p => p.x || 0).sort((a, b) => a - b);
                
                const medianZ = zValues[Math.floor(zValues.length / 2)];
                const medianX = xValues[Math.floor(xValues.length / 2)];
                
                // Threshold: Background adalah points yang:
                // 1. Z lebih besar dari median (lebih jauh/jauh di belakang) ATAU
                // 2. X lebih kecil dari median (lebih kiri)
                // Tapi kita fokus pada Z karena biasanya background lebih jauh
                
                // Gunakan percentile untuk threshold yang lebih akurat
                // Background = 30% terakhir dari Z (paling jauh) atau 30% pertama dari X (paling kiri)
                const zThreshold = zValues[Math.floor(zValues.length * 0.7)]; // 70th percentile
                const xThreshold = xValues[Math.floor(xValues.length * 0.3)]; // 30th percentile
                
                console.log('üìè Thresholds:', {
                    zThreshold: zThreshold.toFixed(3),
                    xThreshold: xThreshold.toFixed(3),
                    medianZ: medianZ.toFixed(3),
                    medianX: medianX.toFixed(3)
                });
                
                // Filter: Hapus points yang berada di background
                // Background = (Z > zThreshold DAN jauh dari objek utama) ATAU (X < xThreshold DAN jauh dari objek utama)
                const filteredPoints = [];
                let removedCount = 0;
                
                // Hitung centroid objek utama (foreground) untuk referensi
                const foregroundPoints = pointCloud.filter(p => {
                    const z = p.z || 0;
                    const x = p.x || 0;
                    // Foreground = dekat (Z kecil) dan kanan (X besar)
                    return z < medianZ && x > medianX;
                });
                
                let centroidX = 0, centroidY = 0, centroidZ = 0;
                if (foregroundPoints.length > 0) {
                    foregroundPoints.forEach(p => {
                        centroidX += (p.x || 0);
                        centroidY += (p.y || 0);
                        centroidZ += (p.z || 0);
                    });
                    centroidX /= foregroundPoints.length;
                    centroidY /= foregroundPoints.length;
                    centroidZ /= foregroundPoints.length;
                }
                
                console.log('üìç Foreground centroid:', {
                    x: centroidX.toFixed(3),
                    y: centroidY.toFixed(3),
                    z: centroidZ.toFixed(3)
                });
                
                // Filter points: Hapus yang terlalu jauh dari centroid (background)
                const maxDistanceFromCentroid = Math.max(rangeZ * 0.6, rangeX * 0.6); // 60% dari range
                
                pointCloud.forEach(p => {
                    const x = p.x || 0;
                    const y = p.y || 0;
                    const z = p.z || 0;
                    
                    // Hitung jarak dari centroid
                    const distX = Math.abs(x - centroidX);
                    const distY = Math.abs(y - centroidY);
                    const distZ = Math.abs(z - centroidZ);
                    const distance = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
                    
                    // Tentukan apakah point adalah background
                    // Background jika:
                    // 1. Terlalu jauh dari centroid (outlier/jauh di belakang)
                    // 2. Z lebih besar dari threshold (jauh di belakang)
                    // 3. X lebih kecil dari threshold (terlalu kiri) DAN jauh dari centroid
                    
                    const isBackground = 
                        distance > maxDistanceFromCentroid || // Terlalu jauh dari objek utama
                        (z > zThreshold && z > medianZ) || // Jauh di belakang
                        (x < xThreshold && distance > maxDistanceFromCentroid * 0.8); // Terlalu kiri dan jauh
                    
                    if (!isBackground) {
                        filteredPoints.push(p);
                    } else {
                        removedCount++;
                    }
                });
                
                console.log('‚úÖ Background removal complete:', {
                    original: pointCloud.length,
                    filtered: filteredPoints.length,
                    removed: removedCount,
                    percentage: ((removedCount / pointCloud.length) * 100).toFixed(1) + '%'
                });
                
                // Update point cloud
                pointCloud = filteredPoints;
                
                // Update visualisasi
                updatePointCloudDisplay();
                
                // Update UI
                document.getElementById('pointCount').textContent = pointCloud.length.toLocaleString();
                updateScanStatus('ready', 
                    'Background removed! ' + pointCloud.length.toLocaleString() + 
                    ' points remaining (' + removedCount.toLocaleString() + ' removed)');
                
                // Re-enable button
                if (removeBgBtn) {
                    removeBgBtn.disabled = false;
                    removeBgBtn.textContent = 'üé® Remove BG';
                }
                
                // Enable generate mesh button
                if (pointCloud.length > 0) {
                    document.getElementById('generateMeshBtn').disabled = false;
                }
                
                alert('‚úÖ Background berhasil dihapus!\n\n' +
                      'üìä Points sebelum: ' + (pointCloud.length + removedCount).toLocaleString() + '\n' +
                      'üìä Points setelah: ' + pointCloud.length.toLocaleString() + '\n' +
                      'üóëÔ∏è Dihapus: ' + removedCount.toLocaleString() + ' points (' + 
                      ((removedCount / (pointCloud.length + removedCount)) * 100).toFixed(1) + '%)');
                
            } catch (error) {
                console.error('‚ùå Error removing background:', error);
                alert('‚ùå Error saat menghapus background!\n\n' +
                      'Error: ' + error.message + '\n\n' +
                      'üí° Solusi: Coba scan ulang atau pastikan ada cukup data.');
                
                // Re-enable button on error
                if (removeBgBtn) {
                    removeBgBtn.disabled = false;
                    removeBgBtn.textContent = 'üé® Remove BG';
                }
                
                updateScanStatus('ready', 'Error removing background');
            }
        }
        
        function generateWatertight() {
            if (pointCloud.length === 0) {
                alert('Tidak ada point cloud untuk di-generate mesh! Silakan lakukan scanning terlebih dahulu.');
                return;
            }

            if (pointCloud.length < 3) {
                alert('Point cloud terlalu sedikit! Minimal 3 points diperlukan untuk membuat mesh.');
                return;
            }

            console.log('üîß Generating mesh from', pointCloud.length.toLocaleString(), 'points...');

            // CRITICAL: Stop receiving data during mesh generation to prevent connection errors
            const wasCaptureActive = isCaptureActive;
            isCaptureActive = false;
            
            // Switch to Color mode to stop point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop data during mesh generation');
            }

            // CRITICAL: Downsample if too many points (prevent freeze)
            // Balance between quality and performance - optimized for watertight quality
            let meshPoints = pointCloud;
            const maxMeshPoints = 100000; // Increased for higher quality watertight mesh

            if (pointCloud.length > maxMeshPoints) {
                console.log('‚ö†Ô∏è Too many points (' + pointCloud.length.toLocaleString() + ') - downsampling to ' + maxMeshPoints.toLocaleString() + ' untuk mencegah freeze');

                // Use FINER voxel-based downsampling for better detail preservation
                const voxelSize = 0.01; // 1cm voxels (was 1.5cm) - finer detail
                const voxelMap = new Map();

                for (let i = 0; i < pointCloud.length; i++) {
                    const p = pointCloud[i];
                    const vx = Math.floor(p.x / voxelSize);
                    const vy = Math.floor(p.y / voxelSize);
                    const vz = Math.floor(p.z / voxelSize);
                    const key = `${vx},${vy},${vz}`;

                    // Keep one point per voxel
                    if (!voxelMap.has(key)) {
                        voxelMap.set(key, p);
                    }
                }

                meshPoints = Array.from(voxelMap.values());

                // If still too many, use additional uniform sampling
                if (meshPoints.length > maxMeshPoints) {
                    const step = meshPoints.length / maxMeshPoints;
                    const sampledPoints = [];
                    for (let i = 0; i < meshPoints.length; i += step) {
                        const idx = Math.floor(i);
                        if (idx < meshPoints.length) {
                            sampledPoints.push(meshPoints[idx]);
                        }
                    }
                    meshPoints = sampledPoints;
                }

                console.log('‚úÖ Downsampled to ' + meshPoints.length.toLocaleString() + ' points (voxel-based with finer detail)');
            }

            // === IMPROVED BACKGROUND REMOVAL FOR TSDF WATERTIGHT ===
            // Statistical + spatial filtering yang lebih pintar dan tidak terlalu agresif
            // TSDF needs MORE points than ball-pivoting, so we keep more data
            console.log('üîç Smart background removal for TSDF reconstruction...');
            const beforeFilter = meshPoints.length;

            try {
                // Stage 1: Statistical outlier removal (gentle)
                // Remove extreme outliers first, but keep most points
                console.log('üìä Stage 1: Statistical outlier removal...');

                // Calculate center of mass
                let centerX = 0, centerY = 0, centerZ = 0;
                for (let i = 0; i < meshPoints.length; i++) {
                    const p = meshPoints[i];
                    centerX += p.x;
                    centerY += p.y;
                    centerZ += p.z;
                }
                centerX /= meshPoints.length;
                centerY /= meshPoints.length;
                centerZ /= meshPoints.length;

                // Calculate distances from center
                const distances = [];
                for (let i = 0; i < meshPoints.length; i++) {
                    const p = meshPoints[i];
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    const dz = p.z - centerZ;
                    distances.push(Math.sqrt(dx * dx + dy * dy + dz * dz));
                }

                // Use percentile-based threshold (very lenient for TSDF)
                const sortedDist = distances.slice().sort((a, b) => a - b);
                const p95 = sortedDist[Math.floor(sortedDist.length * 0.95)]; // 95th percentile
                const threshold = p95 * 1.5; // Keep 95%+ of points

                meshPoints = meshPoints.filter((p, i) => distances[i] <= threshold);

                console.log('üìä After statistical filter: ' + beforeFilter + ' ‚Üí ' + meshPoints.length + ' points (' +
                    ((meshPoints.length / beforeFilter) * 100).toFixed(1) + '% retained)');

                // Stage 2: Gentle depth-based filter (keep most object points)
                console.log('üìä Stage 2: Gentle depth filtering...');

                // Calculate depth statistics
                const depths = meshPoints.map(p => Math.abs(p.z || 0));
                const sortedDepths = depths.slice().sort((a, b) => a - b);
                const depthP10 = sortedDepths[Math.floor(sortedDepths.length * 0.10)];
                const depthP90 = sortedDepths[Math.floor(sortedDepths.length * 0.90)];

                // Expand range for safety
                const minDepth = Math.max(0.3, depthP10 - 0.5);
                const maxDepth = depthP90 + 1.0;

                // Calculate Y statistics (height)
                const heights = meshPoints.map(p => p.y || 0);
                const sortedHeights = heights.slice().sort((a, b) => a - b);
                const heightP5 = sortedHeights[Math.floor(sortedHeights.length * 0.05)];
                const heightP95 = sortedHeights[Math.floor(sortedHeights.length * 0.95)];

                // Expand range for safety
                const minHeight = heightP5 - 0.5;
                const maxHeight = heightP95 + 0.5;

                console.log('üìê Depth range:', minDepth.toFixed(2), '-', maxDepth.toFixed(2), 'm');
                console.log('üìê Height range:', minHeight.toFixed(2), '-', maxHeight.toFixed(2), 'm');

                const beforeDepthFilter = meshPoints.length;
                meshPoints = meshPoints.filter(p => {
                    const depth = Math.abs(p.z || 0);
                    const height = p.y || 0;
                    return depth >= minDepth && depth <= maxDepth &&
                           height >= minHeight && height <= maxHeight;
                });

                console.log('üìä After depth filter: ' + beforeDepthFilter + ' ‚Üí ' + meshPoints.length + ' points (' +
                    ((meshPoints.length / beforeDepthFilter) * 100).toFixed(1) + '% retained)');

                // Ensure minimum points for TSDF
                if (meshPoints.length < 5000) {
                    console.warn('‚ö†Ô∏è Too few points after filtering (' + meshPoints.length + '), using minimal filter');
                    // Fallback: very minimal filtering
                    meshPoints = pointCloud.filter(p => {
                        const dist = Math.abs(p.z || 0);
                        const yPos = p.y || 0;
                        return dist >= 0.3 && dist <= 6.0 && yPos >= -2.0 && yPos <= 3.0;
                    });
                    console.log('üìä Fallback filter applied: ' + meshPoints.length + ' points');
                }

                // Limit for performance (TSDF can handle more points than ball-pivoting)
                if (meshPoints.length > 150000) {
                    console.log('‚ö†Ô∏è Downsampling to 150k for TSDF performance');
                    const voxelSize = 0.008; // 8mm voxels for high quality
                    const voxelMap = new Map();

                    for (let i = 0; i < meshPoints.length; i++) {
                        const p = meshPoints[i];
                        const vx = Math.floor(p.x / voxelSize);
                        const vy = Math.floor(p.y / voxelSize);
                        const vz = Math.floor(p.z / voxelSize);
                        const key = `${vx},${vy},${vz}`;

                        if (!voxelMap.has(key)) {
                            voxelMap.set(key, p);
                        }
                    }

                    meshPoints = Array.from(voxelMap.values());
                    console.log('üìä Voxel downsampled to: ' + meshPoints.length + ' points');
                }

            } catch (err) {
                console.error('‚ùå Background removal error:', err);
                // Fallback: minimal filtering
                meshPoints = pointCloud.filter(p => {
                    const dist = Math.abs(p.z || 0);
                    const yPos = p.y || 0;
                    return dist >= 0.3 && dist <= 5.0 && yPos >= -2.0 && yPos <= 3.0;
                }).slice(0, Math.min(150000, pointCloud.length));
            }

            // Background removal complete
            console.log('‚úÖ Smart background removal complete: ' + beforeFilter + ' ‚Üí ' + meshPoints.length + ' points');
            if (beforeFilter > 0) {
                const removedPercent = ((1 - meshPoints.length / beforeFilter) * 100).toFixed(1);
                console.log('üìä Background removed: ' + (beforeFilter - meshPoints.length).toLocaleString() + ' points (' + removedPercent + '%)');
                console.log('üí° Keeping more points for TSDF volumetric reconstruction (better than ball-pivoting)');
            }

            if (meshPoints.length < 500) {
                console.error('‚ùå Too few points after filtering (' + meshPoints.length + ')');
                if (pointCloud.length > 0) {
                    document.getElementById('removeBgBtn').disabled = false;
                }
                document.getElementById('generateMeshBtn').disabled = false;
                document.getElementById('generateMeshBtn').textContent = 'üî∑ Generate Mesh';
                document.getElementById('clearBtn').disabled = false;
                updateScanStatus('ready', 'Error: Not enough points after filtering');

                const retentionPercent = ((meshPoints.length / beforeFilter) * 100).toFixed(2);
                alert('‚ùå Tidak cukup points setelah filtering!\n\n' +
                      'üìä Statistik:\n' +
                      'Points awal: ' + beforeFilter.toLocaleString() + '\n' +
                      'Points tersisa: ' + meshPoints.length + ' (' + retentionPercent + '%)\n' +
                      'Points minimal: 500\n\n' +
                      'üí° Solusi:\n' +
                      '1. Scan LEBIH LAMA (target: 100,000+ points)\n' +
                      '2. Pastikan objek di range 0.5m - 3.0m dari Kinect\n' +
                      '3. Scan dari berbagai sudut (360¬∞) untuk coverage lengkap\n' +
                      '4. Background harus berbeda dari objek (beda warna/jarak)\n' +
                      '5. Jangan bergerak terlalu cepat saat scan 360¬∞');
                return;
            }

            // === TRANSFORM MESH POINTS TO CANVAS SPACE dengan error handling ===
            try {
                console.log('üîÑ Transforming mesh points to canvas space...');

                // Calculate RAW bounds from Kinect coordinates
                let rawMinX = Infinity, rawMaxX = -Infinity;
                let rawMinY = Infinity, rawMaxY = -Infinity;
                let rawMinZ = Infinity, rawMaxZ = -Infinity;

                for (let i = 0; i < meshPoints.length; i++) {
                    const p = meshPoints[i];
                    if (p && typeof p.x === 'number' && typeof p.y === 'number' && typeof p.z === 'number') {
                        rawMinX = Math.min(rawMinX, p.x);
                        rawMaxX = Math.max(rawMaxX, p.x);
                        rawMinY = Math.min(rawMinY, p.y);
                        rawMaxY = Math.max(rawMaxY, p.y);
                        rawMinZ = Math.min(rawMinZ, p.z);
                        rawMaxZ = Math.max(rawMaxZ, p.z);
                    }
                }

                // Validate bounds
                if (!isFinite(rawMinX) || !isFinite(rawMaxX) || !isFinite(rawMinY) || !isFinite(rawMaxY) || !isFinite(rawMinZ) || !isFinite(rawMaxZ)) {
                    throw new Error('Invalid bounds calculated');
                }

                console.log('Mesh RAW bounds (Kinect):', {
                    x: [rawMinX.toFixed(3), rawMaxX.toFixed(3)],
                    y: [rawMinY.toFixed(3), rawMaxY.toFixed(3)],
                    z: [rawMinZ.toFixed(3), rawMaxZ.toFixed(3)]
                });

                // Calculate center and size
                const centerX = (rawMinX + rawMaxX) / 2;
                const centerY = (rawMinY + rawMaxY) / 2;
                const centerZ = (rawMinZ + rawMaxZ) / 2;
                const sizeX = rawMaxX - rawMinX;
                const sizeY = rawMaxY - rawMinY;
                const sizeZ = rawMaxZ - rawMinZ;
                const maxDim = Math.max(sizeX, sizeY, sizeZ);

                // Calculate scale factor to fit within canvas (max 350mm)
                const maxObjectSize = window.maxObjectSize || 0.35;
                let scaleFactor = 1.0;
                if (maxDim > maxObjectSize) {
                    scaleFactor = maxObjectSize / maxDim;
                    console.log('‚ö†Ô∏è Mesh terlalu besar (' + (maxDim * 1000).toFixed(0) + 'mm), scaling ke ' + (maxObjectSize * 1000).toFixed(0) + 'mm');
                }

                // Transform mesh points to canvas space
                const transformedMeshPoints = [];
                for (let i = 0; i < meshPoints.length; i++) {
                    const p = meshPoints[i];
                    if (p && typeof p.x === 'number' && typeof p.y === 'number' && typeof p.z === 'number') {
                        transformedMeshPoints.push({
                            x: (p.x - centerX) * scaleFactor,
                            y: (p.y - rawMinY) * scaleFactor, // minY becomes 0 (on grid)
                            z: (p.z - centerZ) * scaleFactor,
                            r: p.r || 128,
                            g: p.g || 128,
                            b: p.b || 128
                        });
                    }
                }

                if (transformedMeshPoints.length < 500) {
                    throw new Error('Too few valid points after transformation (' + transformedMeshPoints.length + ')');
                }

                meshPoints = transformedMeshPoints;

                // Simpan transformasi terakhir untuk ekspor (supaya identik dengan tampilan)
                lastTransformParams = {
                    centerX,
                    centerY,
                    centerZ,
                    minY: rawMinY,
                    scaleFactor
                };

                console.log('‚úÖ Mesh points transformed:', {
                    count: meshPoints.length,
                    originalSize: [(sizeX * 1000).toFixed(0) + 'mm', (sizeY * 1000).toFixed(0) + 'mm', (sizeZ * 1000).toFixed(0) + 'mm'],
                    scaledSize: [(sizeX * scaleFactor * 1000).toFixed(0) + 'mm', (sizeY * scaleFactor * 1000).toFixed(0) + 'mm', (sizeZ * scaleFactor * 1000).toFixed(0) + 'mm'],
                    scaleFactor: scaleFactor.toFixed(3)
                });
            } catch (err) {
                console.error('‚ùå Transform error:', err);
                if (pointCloud.length > 0) {
                    document.getElementById('removeBgBtn').disabled = false;
                }
                document.getElementById('generateMeshBtn').disabled = false;
                document.getElementById('generateMeshBtn').textContent = 'üî∑ Generate Mesh';
                updateScanStatus('ready', 'Error during transformation');
                alert('Error saat transform mesh points!\n\n' + err.message + '\n\nSilakan coba scan ulang dengan lebih banyak points.');
                return;
            }

            document.getElementById('removeBgBtn').disabled = true;
            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('generateMeshBtn').textContent = 'Generating Mesh... (' + meshPoints.length.toLocaleString() + ' pts)';
            updateScanStatus('processing', 'Generating watertight mesh from ' + meshPoints.length.toLocaleString() + ' points...');

            // Use Web Worker-like approach with chunked processing to prevent freeze
            const processMeshAsync = () => {
                try {
                    console.log('üîß Starting mesh creation (chunked async)...');
                    const startTime = Date.now();
                    
                    // Process mesh in chunks using requestIdleCallback or setTimeout
                    let progress = 0;
                    
                    const updateProgress = (p) => {
                        progress = p;
                        const progressPercent = Math.round(p * 100);
                        updateScanStatus('processing', 
                            'Generating watertight mesh... ' + progressPercent + '%');
                    };
                    
                    // Use setTimeout to break up work
                    setTimeout(() => {
                        updateProgress(0.2);
                        
                        setTimeout(() => {
                            updateProgress(0.5);
                            
                            setTimeout(() => {
                                updateProgress(0.8);
                                
                                setTimeout(() => {
                                    try {
                                        updateProgress(0.9);
                                        
                                        // Create watertight mesh (this is the heavy operation)
                                        // Watertight mesh mengisi lubang dan membuat objek utuh
                                        mesh = createWatertightMesh(meshPoints);
                                        
                                        updateProgress(1.0);
                                        
                                        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
                                        console.log('‚úÖ Watertight mesh generation completed in ' + elapsedTime + ' seconds');

                                        const oldMesh = scene.getObjectByName('mesh');
                                        if (oldMesh) {
                                            scene.remove(oldMesh);
                                        }

                                        // Also hide point cloud when showing mesh
                                        const oldPointCloud = scene.getObjectByName('pointCloud');
                                        if (oldPointCloud) {
                                            oldPointCloud.visible = false;
                                        }

                                        if (mesh) {
                                            mesh.name = 'mesh';

                                            // Mesh sudah di-transform ke canvas space, langsung posisikan di origin
                                            mesh.position.set(0, 0, 0);
                                            mesh.scale.set(1, 1, 1);
                                            mesh.rotation.set(0, 0, 0);

                                            scene.add(mesh);
                                            console.log('‚úÖ Mesh added to scene at origin (already transformed to canvas space)');

                                            // Force update matrix before centering
                                            mesh.updateMatrixWorld();
                                            
                                            // Bounding box dihilangkan - objek pure di atas kanvas
                                            
                                            // Auto-center the mesh with delay to ensure it's rendered
                                            setTimeout(() => {
                                                centerModel();
                                                // Center again after a short delay to ensure it's correct
                                                setTimeout(() => centerModel(), 200);
                                            }, 100);

                                            // Update mesh info
                                            if (mesh && mesh.geometry) {
                                                const vertexCount = mesh.geometry.attributes.position.count;
                                                const faceCount = mesh.geometry.index ? mesh.geometry.index.count / 3 : 0;
                                                updateMeshInfo(vertexCount, faceCount);
                                            }

                                            // Update UI
                                            updateScanStatus('ready', 'Watertight mesh generated successfully in ' + elapsedTime + 's');
                                            document.getElementById('exportSTLBtn').disabled = false;
                                            document.getElementById('clearBtn').disabled = false; // Ensure Clear All is enabled after mesh generation

                                            alert('‚úÖ Watertight mesh berhasil dibuat!\n\n' +
                                                  'Points: ' + meshPoints.length.toLocaleString() + '\n' +
                                                  'Time: ' + elapsedTime + ' seconds\n\n' +
                                                  'Lubang telah diisi dan objek menjadi utuh.\n' +
                                                  'Background telah di-filter dari mesh.\n' +
                                                  'Objek telah diposisikan di tengah-atas kanvas.');
                                        } else {
                                            console.error('‚ùå Failed to generate watertight mesh');
                                            updateScanStatus('ready', 'Failed to generate watertight mesh');
                                            alert('Gagal membuat watertight mesh. Coba sesuaikan Mesh Resolution atau scan ulang dengan lebih banyak points.');
                                        }

                                        if (pointCloud.length > 0) {
                                            document.getElementById('removeBgBtn').disabled = false;
                                        }
                                        document.getElementById('generateMeshBtn').disabled = false;
                                        document.getElementById('generateMeshBtn').textContent = 'üî∑ Generate Mesh';
                                        document.getElementById('clearBtn').disabled = false; // Re-enable Clear All button
                                        
                                        // Restore capture state if it was active
                                        if (wasCaptureActive) {
                                            console.log('‚ö†Ô∏è Note: Capture was active before mesh generation');
                                        }
                                        
                                    } catch (error) {
                                        console.error('‚ùå Error in mesh creation:', error);
                                        throw error;
                                    }
                                }, 50);
                            }, 50);
                        }, 50);
                    }, 50);
                    
                } catch (error) {
                    console.error('‚ùå Error generating watertight mesh:', error);
                    console.error('Stack trace:', error.stack);
                    alert('Error saat membuat watertight mesh: ' + error.message + '\n\nCek console (F12) untuk detail.');
                    if (pointCloud.length > 0) {
                        document.getElementById('removeBgBtn').disabled = false;
                    }
                    document.getElementById('generateMeshBtn').disabled = false;
                    document.getElementById('generateMeshBtn').textContent = 'üî∑ Generate Mesh';
                    document.getElementById('clearBtn').disabled = false; // Re-enable Clear All button
                    updateScanStatus('ready', 'Error generating watertight mesh');
                }
            };

            // Use setTimeout to prevent UI blocking (give browser time to update UI first)
            setTimeout(processMeshAsync, 100);
        }

        /**
         * Membuat watertight mesh dari point cloud
         * Watertight mesh mengisi lubang dengan cara yang lebih konservatif untuk menghindari hasil tidak karuan
         */
        function createWatertightMesh(points) {
            if (points.length < 3) {
                alert('Tidak cukup points untuk membuat watertight mesh!');
                return null;
            }

            console.log('üîß Creating HIGH-QUALITY watertight mesh from', points.length, 'points...');
            console.log('üî∑ Using TSDF + Marching Cubes (Skanect-like algorithm)...');

            // TRY TSDF + Marching Cubes first (Skanect-like quality)
            const tsdfMesh = createWatertightMeshTSDF(points);
            if (tsdfMesh) {
                console.log('‚úÖ TSDF watertight mesh created successfully!');
                return tsdfMesh;
            }

            // FALLBACK to old method if TSDF fails
            console.warn('‚ö†Ô∏è TSDF failed, falling back to ball-pivoting method...');

            // Gunakan resolution dari slider user untuk detail maksimal
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            // FINER minimum resolution for better detail (was 2cm, now 1cm)
            const stableResolution = Math.max(resolution, 0.01); // Minimum 1cm untuk detail tinggi

            // INCREASED limit untuk kualitas watertight maksimal
            let pointsForMesh = points;
            const meshGenLimit = 80000; // Increased from 50k untuk kualitas watertight lebih detail

            if (points.length > meshGenLimit) {
                console.log('‚ö†Ô∏è Too many points for mesh (' + points.length + '), downsampling to ' + meshGenLimit + ' untuk mencegah freeze');

                // Use FINER voxel-based downsampling untuk kualitas lebih baik
                const voxelSize = 0.01; // 1cm voxels (was 2cm) - finer detail
                const voxelMap = new Map();

                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    const vx = Math.floor(p.x / voxelSize);
                    const vy = Math.floor(p.y / voxelSize);
                    const vz = Math.floor(p.z / voxelSize);
                    const key = `${vx},${vy},${vz}`;

                    if (!voxelMap.has(key)) {
                        voxelMap.set(key, p);
                    }
                }

                pointsForMesh = Array.from(voxelMap.values());

                // Additional uniform sampling if still too many
                if (pointsForMesh.length > meshGenLimit) {
                    const skip = Math.ceil(pointsForMesh.length / meshGenLimit);
                    const sampled = [];
                    for (let i = 0; i < pointsForMesh.length; i += skip) {
                        sampled.push(pointsForMesh[i]);
                    }
                    pointsForMesh = sampled;
                }

                console.log('‚úÖ Downsampled to ' + pointsForMesh.length + ' points untuk high-quality mesh generation');
            }

            // Buat mesh dengan resolution yang lebih stabil (tidak terlalu agresif)
            // Gunakan createImprovedMesh tapi dengan parameter yang lebih konservatif
            console.log('üîß Creating mesh with stable resolution:', stableResolution);
            const meshData = pointCloudProcessor.createImprovedMesh(pointsForMesh, stableResolution);

            // Jika tidak ada faces, gunakan fallback
            if (!meshData || !meshData.faces || meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }

            // Validasi mesh data
            if (!meshData.vertices || meshData.vertices.length === 0) {
                console.warn('‚ö†Ô∏è No vertices generated, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }

            // Buat geometry dari mesh data
            const geometry = new THREE.BufferGeometry();
            const vertices = meshData.vertices;
            const faces = meshData.faces;

            // Validasi vertices dan faces
            if (vertices.length < 3 || faces.length === 0) {
                console.warn('‚ö†Ô∏è Invalid mesh data, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }

            // Set positions dengan validasi
            const positions = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                if (vertices[i] && vertices[i].length >= 3) {
                    positions[i * 3] = vertices[i][0] || 0;
                    positions[i * 3 + 1] = vertices[i][1] || 0;
                    positions[i * 3 + 2] = vertices[i][2] || 0;
                } else {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                }
            }

            // Set indices dengan validasi
            const validFaces = [];
            for (let i = 0; i < faces.length; i++) {
                if (faces[i] && faces[i].length >= 3) {
                    const v0 = faces[i][0];
                    const v1 = faces[i][1];
                    const v2 = faces[i][2];
                    // Validasi indices
                    if (v0 >= 0 && v0 < vertices.length &&
                        v1 >= 0 && v1 < vertices.length &&
                        v2 >= 0 && v2 < vertices.length &&
                        v0 !== v1 && v1 !== v2 && v0 !== v2) {
                        validFaces.push([v0, v1, v2]);
                    }
                }
            }

            if (validFaces.length === 0) {
                console.warn('‚ö†Ô∏è No valid faces after validation, using simple mesh fallback');
                return createMeshFromPointCloud(points);
            }

            const indices = new Uint32Array(validFaces.length * 3);
            for (let i = 0; i < validFaces.length; i++) {
                indices[i * 3] = validFaces[i][0];
                indices[i * 3 + 1] = validFaces[i][1];
                indices[i * 3 + 2] = validFaces[i][2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));

            // Compute normals untuk smooth shading (hanya sekali, tidak berulang)
            try {
                geometry.computeVertexNormals();
            } catch (err) {
                console.warn('‚ö†Ô∏è Error computing normals:', err);
            }

            // Validasi geometry sebelum membuat mesh
            try {
                geometry.computeBoundingBox();
                geometry.computeBoundingSphere();
            } catch (err) {
                console.warn('‚ö†Ô∏è Error computing bounds:', err);
                return createMeshFromPointCloud(points);
            }

            // Apply Taubin smoothing untuk permukaan yang halus seperti Skanect (better than Laplacian)
            console.log('üîß Applying Taubin smoothing for smooth surface (Skanect-like)...');
            try {
                smoothMeshTaubin(geometry, 3); // 3 iterations Taubin (prevents shrinkage)
                console.log('‚úÖ Taubin smoothing applied');
            } catch (err) {
                console.warn('‚ö†Ô∏è Error applying smoothing:', err);
                // Continue without smoothing if it fails
            }

            // Recompute normals after smoothing untuk smooth shading yang lebih baik
            try {
                geometry.computeVertexNormals();
            } catch (err) {
                console.warn('‚ö†Ô∏è Error recomputing normals after smoothing:', err);
            }

            // Buat material dengan warna dari point cloud
            const material = new THREE.MeshPhongMaterial({
                color: 0x888888,
                side: THREE.DoubleSide,
                flatShading: false, // Smooth shading untuk permukaan halus seperti Skanect
                transparent: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            console.log('‚úÖ Watertight mesh created with', validFaces.length, 'valid faces from', vertices.length, 'vertices');

            return mesh;
        }
        
        /**
         * Laplacian smoothing untuk mesh - membuat permukaan halus seperti Skanect
         * @param {THREE.BufferGeometry} geometry - Geometry yang akan di-smooth
         * @param {number} iterations - Jumlah iterasi smoothing (1-3 recommended)
         */
        function smoothMeshLaplacian(geometry, iterations = 2) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                console.warn('‚ö†Ô∏è Invalid geometry for smoothing');
                return;
            }
            
            const positions = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;
            
            if (!indices || indices.length === 0) {
                console.warn('‚ö†Ô∏è No indices for smoothing');
                return;
            }
            
            const vertexCount = positions.count;
            
            // Build vertex neighbor map
            const neighbors = new Array(vertexCount).fill(null).map(() => []);
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                // Add neighbors (avoid duplicates)
                if (!neighbors[i1].includes(i2)) neighbors[i1].push(i2);
                if (!neighbors[i1].includes(i3)) neighbors[i1].push(i3);
                if (!neighbors[i2].includes(i1)) neighbors[i2].push(i1);
                if (!neighbors[i2].includes(i3)) neighbors[i2].push(i3);
                if (!neighbors[i3].includes(i1)) neighbors[i3].push(i1);
                if (!neighbors[i3].includes(i2)) neighbors[i3].push(i2);
            }
            
            // Apply Laplacian smoothing dengan lambda yang lebih konservatif
            // Lambda kecil (0.1-0.2) untuk preserve detail, seperti Skanect
            const lambda = 0.15; // Conservative smoothing factor
            
            for (let iter = 0; iter < iterations; iter++) {
                const newPositions = new Float32Array(positions.array.length);
                
                for (let i = 0; i < vertexCount; i++) {
                    const x = positions.array[i * 3];
                    const y = positions.array[i * 3 + 1];
                    const z = positions.array[i * 3 + 2];
                    
                    // Only smooth vertices with enough neighbors (preserve boundaries)
                    if (neighbors[i].length >= 3) {
                        // Calculate Laplacian (average of neighbors)
                        let avgX = 0, avgY = 0, avgZ = 0;
                        neighbors[i].forEach(nIdx => {
                            avgX += positions.array[nIdx * 3];
                            avgY += positions.array[nIdx * 3 + 1];
                            avgZ += positions.array[nIdx * 3 + 2];
                        });
                        avgX /= neighbors[i].length;
                        avgY /= neighbors[i].length;
                        avgZ /= neighbors[i].length;
                        
                        // Laplacian smoothing: newPos = oldPos + lambda * (avgNeighbor - oldPos)
                        newPositions[i * 3] = x + lambda * (avgX - x);
                        newPositions[i * 3 + 1] = y + lambda * (avgY - y);
                        newPositions[i * 3 + 2] = z + lambda * (avgZ - z);
                    } else {
                        // Preserve boundary/edge vertices
                        newPositions[i * 3] = x;
                        newPositions[i * 3 + 1] = y;
                        newPositions[i * 3 + 2] = z;
                    }
                }
                
                // Update positions
                positions.array.set(newPositions);
                positions.needsUpdate = true;
            }
            
            console.log(`‚úÖ Laplacian smoothing applied (${iterations} iterations, lambda=${lambda})`);
        }
        
        /**
         * TSDF (Truncated Signed Distance Function) - Skanect-like volumetric reconstruction
         * This is the key algorithm used by professional 3D scanning software like Skanect
         * Creates a volumetric representation for smooth, watertight mesh generation
         */
        function createTSDFVolume(points, voxelSize = 0.01) {
            console.log('üî∑ Creating TSDF volume with voxel size:', voxelSize);

            // Calculate bounding box
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                minX = Math.min(minX, p.x);
                maxX = Math.max(maxX, p.x);
                minY = Math.min(minY, p.y);
                maxY = Math.max(maxY, p.y);
                minZ = Math.min(minZ, p.z);
                maxZ = Math.max(maxZ, p.z);
            }

            // Add padding
            const padding = voxelSize * 3;
            minX -= padding; maxX += padding;
            minY -= padding; maxY += padding;
            minZ -= padding; maxZ += padding;

            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;

            const gridX = Math.ceil(sizeX / voxelSize);
            const gridY = Math.ceil(sizeY / voxelSize);
            const gridZ = Math.ceil(sizeZ / voxelSize);

            console.log('üìä TSDF Grid size:', gridX, 'x', gridY, 'x', gridZ, '=', gridX * gridY * gridZ, 'voxels');

            // Limit grid size to prevent memory issues
            const maxVoxels = 512 * 512 * 512; // 128M voxels max
            if (gridX * gridY * gridZ > maxVoxels) {
                const scale = Math.pow(maxVoxels / (gridX * gridY * gridZ), 1/3);
                console.warn('‚ö†Ô∏è Grid too large, scaling down by', scale.toFixed(3));
                return createTSDFVolume(points, voxelSize / scale);
            }

            // Create voxel grid with distance and weight
            const grid = new Map();
            const truncation = voxelSize * 5; // Truncation distance

            // Build spatial index for faster point lookup
            const pointGrid = new Map();
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const px = Math.floor((p.x - minX) / voxelSize);
                const py = Math.floor((p.y - minY) / voxelSize);
                const pz = Math.floor((p.z - minZ) / voxelSize);
                const key = `${px},${py},${pz}`;

                if (!pointGrid.has(key)) {
                    pointGrid.set(key, []);
                }
                pointGrid.get(key).push(p);
            }

            console.log('üîç Computing TSDF values for voxels near surface...');

            // Compute TSDF values only for voxels near points (optimization)
            let voxelsProcessed = 0;
            const searchRadius = Math.ceil(truncation / voxelSize) + 1;

            pointGrid.forEach((cellPoints, cellKey) => {
                const [cx, cy, cz] = cellKey.split(',').map(Number);

                // Process voxels around this point cell
                for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        for (let dz = -searchRadius; dz <= searchRadius; dz++) {
                            const vx = cx + dx;
                            const vy = cy + dy;
                            const vz = cz + dz;

                            if (vx < 0 || vx >= gridX || vy < 0 || vy >= gridY || vz < 0 || vz >= gridZ) continue;

                            const voxelKey = `${vx},${vy},${vz}`;

                            // Voxel center in world coordinates
                            const worldX = minX + (vx + 0.5) * voxelSize;
                            const worldY = minY + (vy + 0.5) * voxelSize;
                            const worldZ = minZ + (vz + 0.5) * voxelSize;

                            // Find closest point distance
                            let minDist = Infinity;

                            // Check nearby cells
                            for (let dcx = -1; dcx <= 1; dcx++) {
                                for (let dcy = -1; dcy <= 1; dcy++) {
                                    for (let dcz = -1; dcz <= 1; dcz++) {
                                        const checkKey = `${cx + dx + dcx},${cy + dy + dcy},${cz + dz + dcz}`;
                                        const nearPoints = pointGrid.get(checkKey);
                                        if (!nearPoints) continue;

                                        for (const p of nearPoints) {
                                            const dx2 = p.x - worldX;
                                            const dy2 = p.y - worldY;
                                            const dz2 = p.z - worldZ;
                                            const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2);
                                            minDist = Math.min(minDist, dist);
                                        }
                                    }
                                }
                            }

                            if (minDist <= truncation) {
                                // Truncate distance
                                const tsdf = Math.max(-truncation, Math.min(truncation, minDist));

                                if (!grid.has(voxelKey)) {
                                    grid.set(voxelKey, { distance: 0, weight: 0 });
                                }

                                const voxel = grid.get(voxelKey);
                                const weight = 1.0; // Uniform weight

                                // Weighted average
                                voxel.distance = (voxel.distance * voxel.weight + tsdf * weight) / (voxel.weight + weight);
                                voxel.weight += weight;

                                voxelsProcessed++;
                            }
                        }
                    }
                }
            });

            console.log('‚úÖ TSDF volume created:', voxelsProcessed, 'voxels with valid distances');

            return {
                grid,
                minX, minY, minZ,
                voxelSize,
                gridX, gridY, gridZ
            };
        }

        /**
         * Marching Cubes algorithm - Extract smooth isosurface from TSDF volume
         * This creates the final watertight mesh like Skanect
         */
        function marchingCubes(tsdf, isovalue = 0) {
            console.log('üî∑ Running Marching Cubes to extract isosurface...');

            const { grid, minX, minY, minZ, voxelSize, gridX, gridY, gridZ } = tsdf;

            const vertices = [];
            const faces = [];
            const vertexMap = new Map();

            // Marching Cubes edge table (256 configurations)
            const edgeTable = [
                0x0  , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
                0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
                0x190, 0x99 , 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
                0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
                0x230, 0x339, 0x33 , 0x13a, 0x636, 0x73f, 0x435, 0x53c,
                0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
                0x3a0, 0x2a9, 0x1a3, 0xaa , 0x7a6, 0x6af, 0x5a5, 0x4ac,
                0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
                0x460, 0x569, 0x663, 0x76a, 0x66 , 0x16f, 0x265, 0x36c,
                0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
                0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff , 0x3f5, 0x2fc,
                0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55 , 0x15c,
                0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
                0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc ,
                0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
                0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
                0xcc , 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
                0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
                0x15c, 0x55 , 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
                0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
                0x2fc, 0x3f5, 0xff , 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
                0x36c, 0x265, 0x16f, 0x66 , 0x76a, 0x663, 0x569, 0x460,
                0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
                0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0,
                0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
                0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230,
                0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
                0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190,
                0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
                0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
            ];

            // Triangle table (simplified - full table is very large)
            // For production use, full table should be included
            const triTable = []; // Would contain 256 rows of triangle configurations

            // Simplified Marching Cubes - Process each voxel
            let cubesProcessed = 0;

            for (let x = 0; x < gridX - 1; x++) {
                for (let y = 0; y < gridY - 1; y++) {
                    for (let z = 0; z < gridZ - 1; z++) {
                        // Get 8 corner values
                        const corners = [];
                        const values = [];

                        for (let i = 0; i < 8; i++) {
                            const dx = (i & 1) ? 1 : 0;
                            const dy = (i & 2) ? 1 : 0;
                            const dz = (i & 4) ? 1 : 0;

                            const key = `${x + dx},${y + dy},${z + dz}`;
                            const voxel = grid.get(key);

                            corners.push({ x: x + dx, y: y + dy, z: z + dz });
                            values.push(voxel ? voxel.distance : Infinity);
                        }

                        // Calculate cube index based on which corners are inside/outside
                        let cubeIndex = 0;
                        for (let i = 0; i < 8; i++) {
                            if (values[i] < isovalue) cubeIndex |= (1 << i);
                        }

                        // Skip if cube is entirely inside or outside
                        if (cubeIndex === 0 || cubeIndex === 255) continue;

                        // Find intersections on edges
                        const edge = edgeTable[cubeIndex];
                        if (edge === 0) continue;

                        const edgeVertices = [];

                        // Check each of 12 edges
                        for (let i = 0; i < 12; i++) {
                            if ((edge & (1 << i)) !== 0) {
                                // Edge vertices indices
                                const e1 = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]][i];
                                const p1 = corners[e1[0]];
                                const p2 = corners[e1[1]];
                                const v1 = values[e1[0]];
                                const v2 = values[e1[1]];

                                // Linear interpolation
                                const t = (isovalue - v1) / (v2 - v1);
                                const edgeKey = `${Math.min(p1.x, p2.x)},${Math.min(p1.y, p2.y)},${Math.min(p1.z, p2.z)}_` +
                                               `${Math.max(p1.x, p2.x)},${Math.max(p1.y, p2.y)},${Math.max(p1.z, p2.z)}`;

                                if (!vertexMap.has(edgeKey)) {
                                    const vx = minX + (p1.x + t * (p2.x - p1.x)) * voxelSize;
                                    const vy = minY + (p1.y + t * (p2.y - p1.y)) * voxelSize;
                                    const vz = minZ + (p1.z + t * (p2.z - p1.z)) * voxelSize;

                                    vertexMap.set(edgeKey, vertices.length);
                                    vertices.push([vx, vy, vz]);
                                }

                                edgeVertices.push(vertexMap.get(edgeKey));
                            }
                        }

                        // Create triangles (simplified - use edge vertices directly)
                        if (edgeVertices.length >= 3) {
                            for (let i = 0; i < edgeVertices.length - 2; i++) {
                                faces.push([edgeVertices[0], edgeVertices[i + 1], edgeVertices[i + 2]]);
                            }
                        }

                        cubesProcessed++;
                    }
                }
            }

            console.log('‚úÖ Marching Cubes complete:', vertices.length, 'vertices,', faces.length, 'faces from', cubesProcessed, 'cubes');

            return { vertices, faces };
        }

        /**
         * Create watertight mesh using TSDF + Marching Cubes (Skanect-like quality)
         */
        function createWatertightMeshTSDF(points) {
            if (points.length < 100) {
                console.warn('‚ö†Ô∏è Too few points for TSDF reconstruction, falling back');
                return null;
            }

            console.log('üî∑ Creating watertight mesh using TSDF + Marching Cubes (Skanect-like)...');

            try {
                // Step 1: Create TSDF volume
                const voxelSize = 0.015; // 1.5cm voxels - balance between detail and performance
                const tsdf = createTSDFVolume(points, voxelSize);

                if (!tsdf || !tsdf.grid || tsdf.grid.size === 0) {
                    console.warn('‚ö†Ô∏è TSDF volume creation failed');
                    return null;
                }

                // Step 2: Extract mesh using Marching Cubes
                const meshData = marchingCubes(tsdf, 0);

                if (!meshData || !meshData.vertices || meshData.vertices.length === 0) {
                    console.warn('‚ö†Ô∏è Marching Cubes failed to extract mesh');
                    return null;
                }

                // Step 3: Create Three.js geometry
                const geometry = new THREE.BufferGeometry();
                const { vertices, faces } = meshData;

                const positions = new Float32Array(vertices.length * 3);
                for (let i = 0; i < vertices.length; i++) {
                    positions[i * 3] = vertices[i][0];
                    positions[i * 3 + 1] = vertices[i][1];
                    positions[i * 3 + 2] = vertices[i][2];
                }

                const indices = new Uint32Array(faces.length * 3);
                for (let i = 0; i < faces.length; i++) {
                    indices[i * 3] = faces[i][0];
                    indices[i * 3 + 1] = faces[i][1];
                    indices[i * 3 + 2] = faces[i][2];
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                geometry.computeVertexNormals();

                // Step 4: Apply Taubin smoothing (better than Laplacian)
                console.log('üîß Applying Taubin smoothing for natural surface...');
                smoothMeshTaubin(geometry, 3);

                // Step 5: Create material and mesh
                const material = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    side: THREE.DoubleSide,
                    flatShading: false,
                    transparent: false
                });

                const mesh = new THREE.Mesh(geometry, material);

                console.log('‚úÖ TSDF watertight mesh created successfully!');
                console.log('üìä Vertices:', vertices.length, '| Faces:', faces.length);

                return mesh;
            } catch (err) {
                console.error('‚ùå TSDF mesh generation failed:', err);
                return null;
            }
        }

        /**
         * Taubin smoothing - Better than Laplacian, prevents shrinkage
         * Used by professional software like Skanect
         */
        function smoothMeshTaubin(geometry, iterations = 3) {
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                return;
            }

            const positions = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;

            if (!indices || indices.length === 0) {
                return;
            }

            const vertexCount = positions.count;

            // Build vertex neighbor map
            const neighbors = new Array(vertexCount).fill(null).map(() => []);
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];

                if (!neighbors[i1].includes(i2)) neighbors[i1].push(i2);
                if (!neighbors[i1].includes(i3)) neighbors[i1].push(i3);
                if (!neighbors[i2].includes(i1)) neighbors[i2].push(i1);
                if (!neighbors[i2].includes(i3)) neighbors[i2].push(i3);
                if (!neighbors[i3].includes(i1)) neighbors[i3].push(i1);
                if (!neighbors[i3].includes(i2)) neighbors[i3].push(i2);
            }

            // Taubin parameters - carefully tuned
            const lambda = 0.5;   // Smoothing factor
            const mu = -0.53;     // Unshrink factor (negative, slightly less than -lambda)

            for (let iter = 0; iter < iterations; iter++) {
                // Forward pass (smoothing)
                applyLaplacianPass(positions, neighbors, lambda);
                // Backward pass (unshrink)
                applyLaplacianPass(positions, neighbors, mu);
            }

            positions.needsUpdate = true;
            console.log(`‚úÖ Taubin smoothing applied (${iterations} iterations)`);
        }

        function applyLaplacianPass(positions, neighbors, weight) {
            const vertexCount = positions.count;
            const newPositions = new Float32Array(positions.array.length);

            for (let i = 0; i < vertexCount; i++) {
                const x = positions.array[i * 3];
                const y = positions.array[i * 3 + 1];
                const z = positions.array[i * 3 + 2];

                if (neighbors[i].length >= 3) {
                    let avgX = 0, avgY = 0, avgZ = 0;
                    neighbors[i].forEach(nIdx => {
                        avgX += positions.array[nIdx * 3];
                        avgY += positions.array[nIdx * 3 + 1];
                        avgZ += positions.array[nIdx * 3 + 2];
                    });
                    avgX /= neighbors[i].length;
                    avgY /= neighbors[i].length;
                    avgZ /= neighbors[i].length;

                    newPositions[i * 3] = x + weight * (avgX - x);
                    newPositions[i * 3 + 1] = y + weight * (avgY - y);
                    newPositions[i * 3 + 2] = z + weight * (avgZ - z);
                } else {
                    newPositions[i * 3] = x;
                    newPositions[i * 3 + 1] = y;
                    newPositions[i * 3 + 2] = z;
                }
            }

            positions.array.set(newPositions);
        }

        /**
         * Fallback function untuk membuat mesh sederhana
         */
        function createMeshFromPointCloud(points) {
            if (points.length < 3) {
                alert('Tidak cukup points untuk membuat mesh!');
                return null;
            }
            
            console.log('üîß Creating mesh from', points.length, 'points with improved reconstruction...');
            
            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            // But limit points to prevent freeze
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            
            // Further limit points for mesh generation to prevent freeze
            let pointsForMesh = points;
            if (points.length > 20000) {
                console.log('‚ö†Ô∏è Too many points for mesh (' + points.length + '), downsampling to 20000');
                const skip = Math.ceil(points.length / 20000);
                pointsForMesh = [];
                for (let i = 0; i < points.length; i += skip) {
                    pointsForMesh.push(points[i]);
                }
            }
            
            const meshData = pointCloudProcessor.createImprovedMesh(pointsForMesh, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, using fallback');
                // Fallback: create simple mesh
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(points.length * 3);
                const colors = new Float32Array(points.length * 3);
                
                for (let i = 0; i < points.length; i++) {
                    positions[i * 3] = points[i].x;
                    positions[i * 3 + 1] = points[i].y;
                    positions[i * 3 + 2] = points[i].z;
                    
                    colors[i * 3] = (points[i].r || 128) / 255;
                    colors[i * 3 + 1] = (points[i].g || 128) / 255;
                    colors[i * 3 + 2] = (points[i].b || 128) / 255;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Simple sequential triangulation as fallback
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false // Smooth shading for better appearance
                });
                
                return new THREE.Mesh(geometry, material);
            }
            
            // Create geometry from improved mesh data
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            // Map original points to mesh vertices to preserve colors
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Find closest original point for color
                let closestIdx = 0;
                let minDist = Infinity;
                for (let j = 0; j < points.length; j++) {
                    const dist = Math.hypot(
                        points[j].x - v[0],
                        points[j].y - v[1],
                        points[j].z - v[2]
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = j;
                    }
                }
                
                colors[i * 3] = (points[closestIdx].r || 128) / 255;
                colors[i * 3 + 1] = (points[closestIdx].g || 128) / 255;
                colors[i * 3 + 2] = (points[closestIdx].b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices from faces
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            
            // Compute normals for smooth shading (this helps fix broken/rough surfaces)
            geometry.computeVertexNormals();
            
            // Compute normals for smooth shading
            geometry.computeVertexNormals();
            
            // Apply light smoothing to fix broken surfaces (without causing freeze)
            const positions = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const vertexCount = positions.count;
            
            // Create vertex neighbor map for smoothing
            const neighbors = new Array(vertexCount).fill(null).map(() => []);
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                if (!neighbors[i1].includes(i2)) neighbors[i1].push(i2);
                if (!neighbors[i1].includes(i3)) neighbors[i1].push(i3);
                if (!neighbors[i2].includes(i1)) neighbors[i2].push(i1);
                if (!neighbors[i2].includes(i3)) neighbors[i2].push(i3);
                if (!neighbors[i3].includes(i1)) neighbors[i3].push(i1);
                if (!neighbors[i3].includes(i2)) neighbors[i3].push(i2);
            }
            
            // Apply light Laplacian smoothing (only 1 iteration to prevent freeze)
            // But only smooth vertices that have enough neighbors (to preserve shape)
            const smoothingFactor = 0.15; // Light smoothing to preserve detail
            const newPositions = new Float32Array(positions.array.length);
            
            for (let i = 0; i < vertexCount; i++) {
                const x = positions.array[i * 3];
                const y = positions.array[i * 3 + 1];
                const z = positions.array[i * 3 + 2];
                
                // Only smooth if vertex has enough neighbors (at least 3)
                if (neighbors[i].length >= 3) {
                    // Average with neighbors
                    let avgX = 0, avgY = 0, avgZ = 0;
                    neighbors[i].forEach(nIdx => {
                        avgX += positions.array[nIdx * 3];
                        avgY += positions.array[nIdx * 3 + 1];
                        avgZ += positions.array[nIdx * 3 + 2];
                    });
                    avgX /= neighbors[i].length;
                    avgY /= neighbors[i].length;
                    avgZ /= neighbors[i].length;
                    
                    // Blend original with averaged position (preserve shape)
                    newPositions[i * 3] = x * (1 - smoothingFactor) + avgX * smoothingFactor;
                    newPositions[i * 3 + 1] = y * (1 - smoothingFactor) + avgY * smoothingFactor;
                    newPositions[i * 3 + 2] = z * (1 - smoothingFactor) + avgZ * smoothingFactor;
                } else {
                    // Keep original position for vertices with few neighbors (boundary/edge vertices)
                    newPositions[i * 3] = x;
                    newPositions[i * 3 + 1] = y;
                    newPositions[i * 3 + 2] = z;
                }
            }
            
            positions.array.set(newPositions);
            
            // Recompute normals after smoothing
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            
            // Repair mesh: remove duplicate faces and fix normals
            geometry = repairMeshGeometry(geometry);
            
            // Final pass: ensure mesh is watertight by checking for unpaired edges
            geometry = ensureWatertightMesh(geometry, positions, vertexCount);
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false // Smooth shading for better appearance
            });
            
            const finalVertexCount = meshData.vertices.length;
            console.log('‚úÖ Mesh created with', meshData.faces.length, 'faces,', finalVertexCount, 'vertices');
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Repair mesh: remove duplicate faces and ensure proper orientation
         */
        function repairMeshGeometry(geometry) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const positions = geometry.attributes.position.array;
            const faceSet = new Set();
            const newIndices = [];
            
            // Remove duplicate faces
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                // Create sorted key
                const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                
                if (!faceSet.has(triKey)) {
                    faceSet.add(triKey);
                    
                    // Use original orientation (assume it's correct)
                    newIndices.push(i1, i2, i3);
                }
            }
            
            // Update geometry with cleaned indices
            geometry.setIndex(newIndices);
            geometry.computeVertexNormals();
            
            console.log('‚úÖ Mesh repaired: removed', (indices.length - newIndices.length) / 3, 'duplicate faces');
            
            return geometry;
        }
        
        /**
         * Ensure mesh is watertight by filling remaining holes
         */
        function ensureWatertightMesh(geometry, positions, vertexCount) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const edgeMap = new Map();
            
            // Count edge occurrences
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                const edges = [
                    [i1, i2],
                    [i2, i3],
                    [i3, i1]
                ];
                
                edges.forEach(edge => {
                    const edgeKey = edge.sort((a, b) => a - b).join(',');
                    if (!edgeMap.has(edgeKey)) {
                        edgeMap.set(edgeKey, 0);
                    }
                    edgeMap.set(edgeKey, edgeMap.get(edgeKey) + 1);
                });
            }
            
            // Find boundary edges (appear only once)
            const boundaryEdges = [];
            edgeMap.forEach((count, edgeKey) => {
                if (count === 1) {
                    const [i1, i2] = edgeKey.split(',').map(Number);
                    boundaryEdges.push([i1, i2]);
                }
            });
            
            if (boundaryEdges.length === 0) {
                console.log('‚úÖ Mesh is watertight (no boundary edges)');
                return geometry;
            }
            
            console.log('üîß Found', boundaryEdges.length, 'boundary edges, attempting to close...');
            
            // Try to close small holes by finding nearby points
            const newIndices = Array.from(indices);
            const faceSet = new Set();
            
            // Rebuild face set
            for (let i = 0; i < indices.length; i += 3) {
                const tri = [indices[i], indices[i + 1], indices[i + 2]].sort((a, b) => a - b);
                faceSet.add(tri.join(','));
            }
            
            // Process boundary edges (limit for performance)
            let closed = 0;
            for (const [i1, i2] of boundaryEdges.slice(0, 1000)) { // Limit to 1000 for performance
                const p1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
                const p2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
                
                // Find closest point to form triangle
                let bestPoint = -1;
                let bestDist = Infinity;
                const edgeLength = p1.distanceTo(p2);
                
                for (let i = 0; i < vertexCount; i++) {
                    if (i === i1 || i === i2) continue;
                    
                    const p3 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const dist1 = p1.distanceTo(p3);
                    const dist2 = p2.distanceTo(p3);
                    
                    // Check if triangle is reasonable
                    if (dist1 < edgeLength * 2 && dist2 < edgeLength * 2) {
                        const avgDist = (dist1 + dist2) / 2;
                        if (avgDist < bestDist) {
                            bestDist = avgDist;
                            bestPoint = i;
                        }
                    }
                }
                
                // Create triangle if good candidate found
                if (bestPoint !== -1 && bestDist < edgeLength * 1.5) {
                    const tri = [i1, i2, bestPoint].sort((a, b) => a - b);
                    const faceKey = tri.join(',');
                    
                    if (!faceSet.has(faceKey)) {
                        faceSet.add(faceKey);
                        newIndices.push(tri[0], tri[1], tri[2]);
                        closed++;
                    }
                }
            }
            
            if (closed > 0) {
                geometry.setIndex(newIndices);
                geometry.computeVertexNormals();
                console.log('‚úÖ Closed', closed, 'holes in mesh');
            }
            
            return geometry;
        }
        
        function createTriangulation(points) {
            console.log('üîß Creating improved triangulation for ' + points.length.toLocaleString() + ' points...');

            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            const meshData = pointCloudProcessor.createImprovedMesh(points, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces from improved mesh, using fallback');
                // Fallback: simple sequential triangulation
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                return new Uint32Array(indices);
            }
            
            // Convert faces to indices array
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            console.log('‚úÖ Created ' + (indices.length / 3).toLocaleString() + ' triangles using improved mesh generation');
            
            return indices;
        }

        /**
         * Ambil parameter transformasi terakhir atau hitung ulang jika belum ada.
         * Digunakan agar ekspor STL identik dengan tampilan di kanvas.
         */
        function getTransformParamsForExport(points) {
            const hasCached =
                lastTransformParams &&
                Number.isFinite(lastTransformParams.centerX) &&
                Number.isFinite(lastTransformParams.centerY) &&
                Number.isFinite(lastTransformParams.centerZ) &&
                Number.isFinite(lastTransformParams.minY) &&
                Number.isFinite(lastTransformParams.scaleFactor);

            if (hasCached) {
                return lastTransformParams;
            }

            if (!points || points.length < 3) return null;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                if (!p) continue;
                const x = p.x || 0;
                const y = p.y || 0;
                const z = p.z || 0;
                minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
            }

            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            const maxDim = Math.max(sizeX, sizeY, sizeZ);

            const maxObjectSize = window.maxObjectSize || 0.35;
            let scaleFactor = 1.0;
            if (maxDim > maxObjectSize) {
                scaleFactor = maxObjectSize / maxDim;
            }

            lastTransformParams = { centerX, centerY, centerZ, minY, scaleFactor };
            return lastTransformParams;
        }

        /**
         * Terapkan transformasi kanvas + scale dan optional offset posisi/scale objek.
         */
        function applyTransformToPoints(points, transformParams) {
            if (!points || points.length === 0) return [];
            const t = transformParams || getTransformParamsForExport(points);
            if (!t) return points;

            const applyScale = (v) => Number.isFinite(v) ? v : 0;
            const scale = applyScale(t.scaleFactor);
            const cx = applyScale(t.centerX);
            const cy = applyScale(t.minY);
            const cz = applyScale(t.centerZ);

            const base = points.map(p => ({
                x: (p.x - cx) * scale,
                y: (p.y - cy) * scale,
                z: (p.z - cz) * scale,
                r: p.r,
                g: p.g,
                b: p.b
            }));

            // Apply user-controlled scale + posisi (slider)
            if (currentObjectScale !== 1.0) {
                base.forEach(p => {
                    p.x *= currentObjectScale;
                    p.y *= currentObjectScale;
                    p.z *= currentObjectScale;
                });
            }
            if (window.objectPosition) {
                base.forEach(p => {
                    p.x += window.objectPosition.x || 0;
                    p.y += window.objectPosition.y || 0;
                    p.z += window.objectPosition.z || 0;
                });
            }

            return base;
        }

        /**
         * Ambil posisi world-space dari objek Three.js (mesh atau points)
         * supaya STL mengikuti transformasi di scene.
         */
        function extractWorldPointsFromObject(obj) {
            if (!obj || !obj.geometry || !obj.geometry.attributes || !obj.geometry.attributes.position) return null;
            obj.updateMatrixWorld(true);
            const pos = obj.geometry.attributes.position;
            const pts = [];
            const tmp = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                tmp.fromBufferAttribute(pos, i);
                tmp.applyMatrix4(obj.matrixWorld);
                pts.push({ x: tmp.x, y: tmp.y, z: tmp.z });
            }
            return pts;
        }
        
        function exportSTL() {
            console.log('üíæ Exporting STL file...');
            
            // Disable export button to prevent multiple clicks during export
            const exportBtn = document.getElementById('exportSTLBtn');
            if (exportBtn) {
                exportBtn.disabled = true;
                exportBtn.textContent = '‚è≥ Exporting...';
            }

            let geometryToExport = null;
            let exportSource = '';
            let sourceObject = null;

            // Check if we have mesh, otherwise create temporary mesh from point cloud
            // IMPORTANT: Gunakan mesh yang sama yang ditampilkan di viewer untuk konsistensi
            const meshObj = scene ? scene.getObjectByName('mesh') : mesh;
            if (meshObj && meshObj.geometry) {
                // Clone geometry dari mesh yang ditampilkan (sudah di-transform ke canvas space)
                geometryToExport = meshObj.geometry.clone();
                sourceObject = meshObj;
                exportSource = 'mesh';
                console.log('üì¶ Exporting from existing watertight mesh (same as displayed)');
                console.log('üìç Mesh position:', meshObj.position);
                console.log('üìç Mesh scale:', meshObj.scale);
                console.log('üìç Mesh rotation:', meshObj.rotation);
            } else if (pointCloud.length > 0) {
                // Export langsung dari point cloud tanpa generate mesh (lebih cepat, tidak freeze)
                console.log('üì¶ Exporting directly from point cloud (fast mode)...');
                exportSource = 'pointcloud';
                
                // Export langsung dari point cloud dengan triangulasi cepat
                // Gunakan async untuk mencegah freeze
                (async () => {
                    try {
                        updateScanStatus('processing', 'Exporting STL from point cloud...');
                        
                        // Gunakan point cloud yang sudah ditransformasi ke world-space bila ada
                        let pointsForExport = pointCloud;
                        const pointCloudObj = scene ? scene.getObjectByName('pointCloud') : null;
                        const worldPoints = extractWorldPointsFromObject(pointCloudObj);
                        if (worldPoints && worldPoints.length > 0) {
                            pointsForExport = worldPoints;
                            console.log('üìç Using world-space point cloud from scene for export');
                        } else {
                            const transformParams = getTransformParamsForExport(pointCloud);
                            pointsForExport = applyTransformToPoints(pointCloud, transformParams);
                            console.log('üìç Applied cached transform to point cloud for export');
                        }

                        // Export dengan triangulasi cepat (tidak freeze)
                        const stlString = await convertPointCloudToSTLAsync(pointsForExport, (progress) => {
                            if (exportBtn) {
                                exportBtn.textContent = `‚è≥ Exporting... ${progress}%`;
                            }
                            updateScanStatus('processing', `Exporting STL... ${progress}%`);
                        });
                        
                        if (!stlString || stlString.length < 100) {
                            throw new Error('STL conversion failed - no valid triangles generated');
                        }
                        
                        const blob = new Blob([stlString], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        a.download = 'kinect-scan-' + timestamp + '.stl';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        console.log('‚úÖ Point cloud STL exported successfully:', a.download);
                        alert('‚úÖ File STL berhasil di-export dari point cloud!\n\n' +
                              'üìÅ File: ' + a.download + '\n' +
                              'üìä Points: ' + pointsForExport.length.toLocaleString() + '\n' +
                              'üìè Scale: ' + currentObjectScale.toFixed(2) + 'x' +
                              (currentObjectScale !== 1.0 ? ' (ukuran telah disesuaikan)' : ' (ukuran asli)') + '\n\n' +
                              'üí° File ini langsung dari point cloud tanpa generate mesh.\n' +
                              'Hasil akan sesuai dengan tampilan di viewer.');
                        
                        // Re-enable button after successful export
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.textContent = 'üíæ Export STL';
                        }
                        updateScanStatus('ready', 'STL exported successfully');
                        return;
                    } catch (error) {
                        console.error('‚ùå Error exporting point cloud STL:', error);
                        // Re-enable button on error
                        if (exportBtn) {
                            exportBtn.disabled = false;
                            exportBtn.textContent = 'üíæ Export STL';
                        }
                        alert('‚ùå Error saat mengekspor STL dari point cloud!\n\n' +
                              'Error: ' + error.message + '\n\n' +
                              'üí° Solusi:\n' +
                              '1. Pastikan ada cukup data scan (minimal 1,000 points)\n' +
                              '2. Coba generate Watertight terlebih dahulu untuk hasil lebih baik\n' +
                              '3. Check console (F12) untuk detail error');
                        updateScanStatus('ready', 'Export failed');
                    }
                })();
                return; // Return immediately, async function will handle the rest
            } else {
                // Re-enable button before returning
                if (exportBtn) {
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'üíæ Export STL';
                }
                alert('Tidak ada data untuk di-export! Lakukan scanning terlebih dahulu.');
                return;
            }

            if (!geometryToExport) {
                // Re-enable button before returning
                if (exportBtn) {
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'üíæ Export STL';
                }
                alert('Gagal mengakses geometry untuk export.');
                return;
            }

            try {
                console.log('üìè Preparing geometry for export...');

                // Clone geometry - mesh sudah di-transform ke canvas space saat dibuat
                // Mesh yang ditampilkan sudah di-posisikan di origin (0,0,0) dengan scale (1,1,1)
                // Jadi geometry sudah dalam koordinat yang benar untuk export
                const geometryWithTransform = geometryToExport.clone();
                
                // IMPORTANT: Jangan apply matrixWorld lagi karena:
                // 1. Mesh sudah di-transform ke canvas space saat createWatertightMesh
                // 2. Mesh sudah di-posisikan di origin (0,0,0) saat ditambahkan ke scene
                // 3. Apply matrixWorld lagi akan menyebabkan double transform dan hasil berbeda
                
                console.log('üìç Exporting mesh as displayed (already in canvas space)');
                console.log('üìç Source object position:', sourceObject ? sourceObject.position : 'N/A');
                console.log('üìç Source object scale:', sourceObject ? sourceObject.scale : 'N/A');
                console.log('üìç Geometry vertices count:', geometryWithTransform.attributes.position.count);

                const stlString = convertToSTL(geometryWithTransform);
                
                // Check if STL conversion was successful
                if (!stlString || stlString.length < 100) {
                    // Re-enable button before returning
                    if (exportBtn) {
                        exportBtn.disabled = false;
                        exportBtn.textContent = 'üíæ Export STL';
                    }
                    alert('‚ùå Gagal mengkonversi geometry ke STL!\n\n' +
                          'Kemungkinan penyebab:\n' +
                          '1. Tidak ada triangle yang valid dalam mesh\n' +
                          '2. Geometry kosong atau rusak\n\n' +
                          'üí° Solusi: Coba generate mesh ulang atau pastikan ada cukup data scan.');
                    console.error('‚ùå STL conversion returned invalid result:', stlString ? stlString.substring(0, 200) : 'null');
                    return;
                }
                
                const blob = new Blob([stlString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = 'kinect-scan-' + timestamp + '.stl';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('‚úÖ STL file exported successfully:', a.download);

                // Show detailed success message
                // Fix: Use geometryWithTransform instead of undefined scaledGeometry
                const vertexCount = geometryWithTransform.attributes.position.count;
                const faceCount = geometryWithTransform.index ? geometryWithTransform.index.count / 3 : 0;

                alert('‚úÖ File STL berhasil di-export!\n\n' +
                      'üìÅ File: ' + a.download + '\n' +
                      'üìä Vertices: ' + vertexCount.toLocaleString() + '\n' +
                      'üìê Faces: ' + Math.floor(faceCount).toLocaleString() + '\n' +
                      'üìè Scale: ' + currentObjectScale.toFixed(2) + 'x' +
                      (currentObjectScale !== 1.0 ? ' (ukuran telah disesuaikan)' : ' (ukuran asli)') + '\n' +
                      'üì¶ Source: ' + (exportSource === 'mesh' ? 'Watertight Mesh' : 'Point Cloud (auto-mesh)') + '\n\n' +
                      'üí° TIP: File dapat dibuka di aplikasi 3D print seperti:\n' +
                      '   - Ultimaker Cura\n' +
                      '   - PrusaSlicer\n' +
                      '   - Simplify3D\n' +
                      '   - Meshmixer\n\n' +
                      (exportSource === 'pointcloud' ?
                          '‚ö†Ô∏è Catatan: Untuk kualitas terbaik, gunakan "Generate Watertight" sebelum export.' :
                          ''));
                
                // Re-enable button after successful export
                if (exportBtn) {
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'üíæ Export STL';
                }
            } catch (error) {
                console.error('‚ùå Error exporting STL:', error);
                
                // Re-enable button on error
                if (exportBtn) {
                    exportBtn.disabled = false;
                    exportBtn.textContent = 'üíæ Export STL';
                }
                
                alert('‚ùå Error saat mengekspor STL!\n\n' +
                      'Error: ' + error.message + '\n\n' +
                      'üí° Solusi:\n' +
                      '1. Pastikan ada data scan (minimal 1,000 points)\n' +
                      '2. Coba generate Watertight terlebih dahulu\n' +
                      '3. Check console (F12) untuk detail error');
            }
        }
        
        /**
         * Convert point cloud directly to STL format (ASYNC version - tidak freeze)
         * Creates simple triangles from nearby points dengan progress update
         * Optimized untuk export langsung dari point cloud tanpa generate mesh
         */
        async function convertPointCloudToSTLAsync(points, progressCallback) {
            if (points.length < 3) {
                return 'solid kinect_scan\nendsolid kinect_scan\n';
            }
            
            console.log('üîß Converting point cloud to STL (fast async mode)...');
            if (progressCallback) progressCallback(0);
            
            // Limit points untuk performa yang lebih baik (tapi tetap bagus)
            const maxPoints = 50000; // Increased untuk kualitas lebih baik
            let processedPoints = points;
            if (points.length > maxPoints) {
                console.log('‚ö†Ô∏è Point cloud too large (' + points.length + ' points), downsampling to ' + maxPoints + ' for export...');
                const step = Math.floor(points.length / maxPoints);
                processedPoints = [];
                for (let i = 0; i < points.length; i += step) {
                    processedPoints.push(points[i]);
                }
            }
            
            if (progressCallback) progressCallback(10);
            
            // Gunakan algoritma triangulasi yang lebih cepat: Delaunay-like dengan spatial hashing
            const triangles = await createFastTriangulation(processedPoints, progressCallback);
            
            if (progressCallback) progressCallback(90);
            
            // Convert triangles to STL format
            let stl = 'solid kinect_scan\n';
            const scale = 1000; // Convert dari meter ke mm untuk 3D print
            
            for (let i = 0; i < triangles.length; i++) {
                const tri = triangles[i];
                const p1 = processedPoints[tri[0]];
                const p2 = processedPoints[tri[1]];
                const p3 = processedPoints[tri[2]];
                
                // Calculate normal
                const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                const normal = new THREE.Vector3().crossVectors(v1, v2);
                const area = normal.length();
                
                // Skip degenerate triangles
                if (area < 0.000001) continue;
                
                normal.normalize();
                
                // Scale to mm
                const p1Scaled = { x: p1.x * scale, y: p1.y * scale, z: p1.z * scale };
                const p2Scaled = { x: p2.x * scale, y: p2.y * scale, z: p2.z * scale };
                const p3Scaled = { x: p3.x * scale, y: p3.y * scale, z: p3.z * scale };
                
                stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                stl += `    outer loop\n`;
                stl += `      vertex ${p1Scaled.x.toFixed(6)} ${p1Scaled.y.toFixed(6)} ${p1Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p2Scaled.x.toFixed(6)} ${p2Scaled.y.toFixed(6)} ${p2Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p3Scaled.x.toFixed(6)} ${p3Scaled.y.toFixed(6)} ${p3Scaled.z.toFixed(6)}\n`;
                stl += `    endloop\n`;
                stl += `  endfacet\n`;
                
                // Update progress setiap 1000 triangles
                if (i % 1000 === 0 && progressCallback) {
                    const progress = 90 + Math.floor((i / triangles.length) * 10);
                    progressCallback(progress);
                    // Give browser time to breathe
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            stl += 'endsolid kinect_scan\n';
            console.log('‚úÖ Converted', triangles.length, 'triangles to STL');
            
            if (progressCallback) progressCallback(100);
            return stl;
        }
        
        /**
         * Create fast triangulation dari point cloud (tidak freeze)
         * Menggunakan spatial hashing dengan async untuk memberikan waktu browser
         */
        async function createFastTriangulation(points, progressCallback) {
            const triangles = [];
            const maxTriangles = 100000; // Limit untuk performa
            const maxDistance = 0.15; // 15cm max distance untuk connecting points
            const hashSize = 0.08; // 8cm grid cells
            const spatialHash = new Map();
            
            // Build spatial hash
            console.log('üîß Building spatial hash...');
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const hx = Math.floor(p.x / hashSize);
                const hy = Math.floor(p.y / hashSize);
                const hz = Math.floor(p.z / hashSize);
                const key = `${hx},${hy},${hz}`;
                
                if (!spatialHash.has(key)) {
                    spatialHash.set(key, []);
                }
                spatialHash.get(key).push(i);
                
                // Update progress
                if (i % 5000 === 0 && progressCallback) {
                    const progress = 10 + Math.floor((i / points.length) * 30);
                    progressCallback(progress);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            if (progressCallback) progressCallback(40);
            
            // Generate triangles dari nearby points
            console.log('üîß Generating triangles...');
            const processed = new Set();
            const maxPointsPerCell = 15; // Limit untuk performa
            
            for (let i = 0; i < points.length && triangles.length < maxTriangles; i++) {
                const p1 = points[i];
                const hx = Math.floor(p1.x / hashSize);
                const hy = Math.floor(p1.y / hashSize);
                const hz = Math.floor(p1.z / hashSize);
                
                // Check neighboring cells (3x3x3 = 27 cells)
                for (let dx = -1; dx <= 1 && triangles.length < maxTriangles; dx++) {
                    for (let dy = -1; dy <= 1 && triangles.length < maxTriangles; dy++) {
                        for (let dz = -1; dz <= 1 && triangles.length < maxTriangles; dz++) {
                            const key = `${hx+dx},${hy+dy},${hz+dz}`;
                            const cellPoints = spatialHash.get(key);
                            
                            if (!cellPoints || cellPoints.length === 0) continue;
                            
                            // Limit points checked per cell
                            const checkCount = Math.min(cellPoints.length, maxPointsPerCell);
                            
                            for (let idx = 0; idx < checkCount && triangles.length < maxTriangles; idx++) {
                                const j = cellPoints[idx];
                                if (j <= i) continue;
                                
                                const p2 = points[j];
                                const dist12 = Math.hypot(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                                if (dist12 > maxDistance) continue;
                                
                                // Find third point
                                for (let idx2 = idx + 1; idx2 < checkCount && triangles.length < maxTriangles; idx2++) {
                                    const k = cellPoints[idx2];
                                    if (k === i || k === j) continue;
                                    
                                    const p3 = points[k];
                                    const dist13 = Math.hypot(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                                    const dist23 = Math.hypot(p3.x - p2.x, p3.y - p2.y, p3.z - p2.z);
                                    
                                    if (dist13 <= maxDistance && dist23 <= maxDistance) {
                                        // Check triangle quality
                                        const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                                        const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                                        const normal = new THREE.Vector3().crossVectors(v1, v2);
                                        const area = normal.length();
                                        
                                        if (area > 0.0001) { // Valid triangle
                                            const triKey = [i, j, k].sort((a, b) => a - b).join(',');
                                            if (!processed.has(triKey)) {
                                                processed.add(triKey);
                                                triangles.push([i, j, k]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Update progress dan beri waktu browser
                if (i % 1000 === 0 && progressCallback) {
                    const progress = 40 + Math.floor((i / points.length) * 40);
                    progressCallback(progress);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            console.log('‚úÖ Generated', triangles.length, 'triangles');
            return triangles;
        }
        
        /**
         * Convert point cloud directly to STL format (fallback when mesh generation fails)
         * Creates simple triangles from nearby points
         * Optimized to prevent freezing on large point clouds
         * DEPRECATED: Use convertPointCloudToSTLAsync instead
         */
        function convertPointCloudToSTL(points) {
            if (points.length < 3) {
                return 'solid kinect_scan\nendsolid kinect_scan\n';
            }
            
            console.log('üîß Converting point cloud to STL (simple triangulation)...');
            
            // Limit points to prevent freezing on very large point clouds
            const maxPoints = 10000; // Limit to 10k points for performance
            let processedPoints = points;
            if (points.length > maxPoints) {
                console.log('‚ö†Ô∏è Point cloud too large (' + points.length + ' points), downsampling to ' + maxPoints + ' for export...');
                const step = Math.floor(points.length / maxPoints);
                processedPoints = [];
                for (let i = 0; i < points.length; i += step) {
                    processedPoints.push(points[i]);
                }
            }
            
            // Use simple spatial hashing for triangulation
            const maxDistance = 0.1; // 10cm max distance for connecting points
            const hashSize = 0.05; // 5cm grid cells
            const spatialHash = {};
            
            // Build spatial hash
            processedPoints.forEach((p, i) => {
                const hx = Math.floor(p.x / hashSize);
                const hy = Math.floor(p.y / hashSize);
                const hz = Math.floor(p.z / hashSize);
                const key = `${hx},${hy},${hz}`;
                if (!spatialHash[key]) spatialHash[key] = [];
                spatialHash[key].push(i);
            });
            
            const triangles = [];
            const processed = new Set();
            const maxTriangles = 50000; // Limit triangles to prevent freezing
            
            // Generate triangles from nearby points
            // Optimized: limit iterations and add early exit
            for (let i = 0; i < processedPoints.length && triangles.length < maxTriangles; i++) {
                const p1 = processedPoints[i];
                const hx = Math.floor(p1.x / hashSize);
                const hy = Math.floor(p1.y / hashSize);
                const hz = Math.floor(p1.z / hashSize);
                
                // Check neighboring cells (reduced to immediate neighbors only)
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            if (triangles.length >= maxTriangles) break;
                            
                            const key = `${hx+dx},${hy+dy},${hz+dz}`;
                            if (!spatialHash[key]) continue;
                            
                            // Limit points checked per cell
                            const cellPoints = spatialHash[key];
                            const maxPointsPerCell = 20; // Limit to prevent excessive iterations
                            
                            for (let idx = 0; idx < Math.min(cellPoints.length, maxPointsPerCell) && triangles.length < maxTriangles; idx++) {
                                const j = cellPoints[idx];
                                if (j <= i) continue;
                                
                                const p2 = processedPoints[j];
                                const dist12 = Math.hypot(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                                if (dist12 > maxDistance) continue;
                                
                                // Find third point in nearby cells
                                for (let dx2 = -1; dx2 <= 1 && triangles.length < maxTriangles; dx2++) {
                                    for (let dy2 = -1; dy2 <= 1 && triangles.length < maxTriangles; dy2++) {
                                        for (let dz2 = -1; dz2 <= 1 && triangles.length < maxTriangles; dz2++) {
                                            const key2 = `${hx+dx2},${hy+dy2},${hz+dz2}`;
                                            if (!spatialHash[key2]) continue;
                                            
                                            const cellPoints2 = spatialHash[key2];
                                            for (let idx2 = 0; idx2 < Math.min(cellPoints2.length, maxPointsPerCell) && triangles.length < maxTriangles; idx2++) {
                                                const k = cellPoints2[idx2];
                                                if (k === i || k === j) continue;
                                                
                                                const p3 = processedPoints[k];
                                                const dist13 = Math.hypot(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                                                const dist23 = Math.hypot(p3.x - p2.x, p3.y - p2.y, p3.z - p2.z);
                                                
                                                if (dist13 <= maxDistance && dist23 <= maxDistance) {
                                                    const triKey = [i, j, k].sort().join(',');
                                                    if (!processed.has(triKey)) {
                                                        processed.add(triKey);
                                                        triangles.push([i, j, k]);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Convert to STL format
            let stl = 'solid kinect_scan\n';
            
            // Log warning if we had to limit triangles
            if (triangles.length >= maxTriangles) {
                console.warn('‚ö†Ô∏è Triangle limit reached (' + maxTriangles + '), some triangles may be missing');
            }
            
            triangles.forEach(tri => {
                const p1 = processedPoints[tri[0]];
                const p2 = processedPoints[tri[1]];
                const p3 = processedPoints[tri[2]];
                
                // Calculate normal
                const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                
                // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                const scale = 1000; // Scale dari meter ke mm
                const p1Scaled = { x: p1.x * scale, y: p1.y * scale, z: p1.z * scale };
                const p2Scaled = { x: p2.x * scale, y: p2.y * scale, z: p2.z * scale };
                const p3Scaled = { x: p3.x * scale, y: p3.y * scale, z: p3.z * scale };
                
                stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                stl += `    outer loop\n`;
                stl += `      vertex ${p1Scaled.x.toFixed(6)} ${p1Scaled.y.toFixed(6)} ${p1Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p2Scaled.x.toFixed(6)} ${p2Scaled.y.toFixed(6)} ${p2Scaled.z.toFixed(6)}\n`;
                stl += `      vertex ${p3Scaled.x.toFixed(6)} ${p3Scaled.y.toFixed(6)} ${p3Scaled.z.toFixed(6)}\n`;
                stl += `    endloop\n`;
                stl += `  endfacet\n`;
            });
            
            stl += 'endsolid kinect_scan\n';
            console.log('‚úÖ Converted', triangles.length, 'triangles to STL');
            return stl;
        }
        
        /**
         * Convert Three.js geometry to STL format with validation
         * Ensures mesh is valid and properly formatted
         */
        function convertToSTL(geometry) {
            console.log('üîß Converting geometry to STL format...');
            
            // Validate and repair geometry before export
            geometry = validateAndRepairGeometry(geometry);
            
            let stl = 'solid kinect_scan\n';
            const positions = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;
            
            let validTriangles = 0;
            let invalidTriangles = 0;
            
            if (indices) {
                // Indexed geometry - more efficient
                const triangleSet = new Set(); // Track unique triangles
                
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i];
                    const i2 = indices[i + 1];
                    const i3 = indices[i + 2];
                    
                    // Validate indices
                    if (i1 === i2 || i2 === i3 || i1 === i3) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    // Check for duplicate triangles
                    const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue; // Skip duplicate triangles
                    }
                    triangleSet.add(triKey);
                    
                    const idx1 = i1 * 3;
                    const idx2 = i2 * 3;
                    const idx3 = i3 * 3;
                    
                    // Validate array bounds
                    if (idx1 + 2 >= positions.length || idx2 + 2 >= positions.length || idx3 + 2 >= positions.length) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    const v1 = new THREE.Vector3(positions[idx1], positions[idx1 + 1], positions[idx1 + 2]);
                    const v2 = new THREE.Vector3(positions[idx2], positions[idx2 + 1], positions[idx2 + 2]);
                    const v3 = new THREE.Vector3(positions[idx3], positions[idx3 + 1], positions[idx3 + 2]);
                    
                    // Check for degenerate triangles (zero area)
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    normal.normalize();
                    
                    // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                    // STL biasanya dalam mm, jadi scale up 1000x
                    const scale = 1000; // Scale dari meter ke mm
                    const v1Scaled = new THREE.Vector3(v1.x * scale, v1.y * scale, v1.z * scale);
                    const v2Scaled = new THREE.Vector3(v2.x * scale, v2.y * scale, v2.z * scale);
                    const v3Scaled = new THREE.Vector3(v3.x * scale, v3.y * scale, v3.z * scale);
                    
                    // Write triangle to STL (dalam mm)
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1Scaled.x.toFixed(6)} ${v1Scaled.y.toFixed(6)} ${v1Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2Scaled.x.toFixed(6)} ${v2Scaled.y.toFixed(6)} ${v2Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3Scaled.x.toFixed(6)} ${v3Scaled.y.toFixed(6)} ${v3Scaled.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            } else {
                // Non-indexed geometry
                const vertexCount = positions.length / 3;
                const triangleSet = new Set();
                
                for (let i = 0; i < vertexCount - 2; i += 3) {
                    const v1 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const v2 = new THREE.Vector3(positions[(i + 1) * 3], positions[(i + 1) * 3 + 1], positions[(i + 1) * 3 + 2]);
                    const v3 = new THREE.Vector3(positions[(i + 2) * 3], positions[(i + 2) * 3 + 1], positions[(i + 2) * 3 + 2]);
                    
                    // Check for duplicate triangles
                    const triKey = `${i},${i+1},${i+2}`;
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue;
                    }
                    triangleSet.add(triKey);
                    
                    // Check for degenerate triangles
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    normal.normalize();
                    
                    // Scale up untuk 3D print (konversi dari meter ke mm, x1000)
                    const scale = 1000; // Scale dari meter ke mm
                    const v1Scaled = new THREE.Vector3(v1.x * scale, v1.y * scale, v1.z * scale);
                    const v2Scaled = new THREE.Vector3(v2.x * scale, v2.y * scale, v2.z * scale);
                    const v3Scaled = new THREE.Vector3(v3.x * scale, v3.y * scale, v3.z * scale);
                    
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1Scaled.x.toFixed(6)} ${v1Scaled.y.toFixed(6)} ${v1Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2Scaled.x.toFixed(6)} ${v2Scaled.y.toFixed(6)} ${v2Scaled.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3Scaled.x.toFixed(6)} ${v3Scaled.y.toFixed(6)} ${v3Scaled.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            }
            
            stl += 'endsolid kinect_scan\n';
            
            console.log('‚úÖ STL conversion complete:', validTriangles, 'valid triangles,', invalidTriangles, 'invalid triangles skipped');
            
            if (validTriangles === 0) {
                console.error('‚ùå No valid triangles in geometry!');
                return null;
            }
            
            return stl;
        }
        
        /**
         * Validate and repair geometry before STL export
         * Ensures mesh is watertight and properly formed
         */
        function validateAndRepairGeometry(geometry) {
            console.log('üîß Validating and repairing geometry...');
            
            if (!geometry.index) {
                console.log('‚ö†Ô∏è Geometry is not indexed, computing index...');
                // Try to merge vertices if BufferGeometryUtils is available
                if (typeof THREE.BufferGeometryUtils !== 'undefined') {
                    geometry = THREE.BufferGeometryUtils.mergeVertices(geometry, 0.001);
                }
                geometry.computeVertexNormals();
                return geometry;
            }
            
            // Remove duplicate vertices
            const positions = geometry.attributes.position.array;
            const indices = geometry.index.array;
            const vertexCount = positions.length / 3;
            
            // Recompute normals to ensure consistency
            geometry.computeVertexNormals();
            
            // Ensure bounding sphere is computed
            if (!geometry.boundingSphere) {
                geometry.computeBoundingSphere();
            }
            
            console.log('‚úÖ Geometry validated:', vertexCount, 'vertices,', indices.length / 3, 'triangles');
            
            return geometry;
        }
        
        function clearScan() {
            // Reset multi-phase data
            scanPhase = 0;
            pointCloudFront = [];
            pointCloudBack = [];
            isMultiPhaseMode = false;
            if (document.getElementById('enableMultiPhaseCheckbox')) {
                document.getElementById('enableMultiPhaseCheckbox').checked = false;
            }
            if (document.getElementById('phaseInfo')) {
                document.getElementById('phaseInfo').style.display = 'none';
            }
            if (document.getElementById('startPhase2Btn')) {
                document.getElementById('startPhase2Btn').style.display = 'none';
                document.getElementById('startPhase2Btn').disabled = true;
            }
            
            // Stop scanning if active
            if (isScanning) {
                stopScan();
            }
            
            pointCloud = [];
            pointCloudFrames = [];
            meshFrames = []; // Clear mesh frames
            mesh = null;
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            kinectPosition = { x: 0, y: 0, z: 0 };
            
            // Remove depth mesh and bounding box if exists
            if (scene) {
                const depthMesh = scene.getObjectByName('depthMesh');
                if (depthMesh) {
                    scene.remove(depthMesh);
                }
                
                // Remove bounding box
                const boundingBox = scene.getObjectByName('boundingBox');
                if (boundingBox) {
                    scene.remove(boundingBox);
                }
            }
            
            if (scene) {
                const oldPointCloud = scene.getObjectByName('pointCloud');
                if (oldPointCloud) {
                    scene.remove(oldPointCloud);
                }
                
                const oldMesh = scene.getObjectByName('mesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
                
                // Remove bounding box
                const oldBoundingBox = scene.getObjectByName('boundingBox');
                if (oldBoundingBox) {
                    scene.remove(oldBoundingBox);
                }
            }
            
            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('removeBgBtn').disabled = true;
            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('exportSTLBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true; // Disable Clear All after clearing
            updateScanStatus('idle', 'Tidak aktif');
            const debugMsgEl = document.getElementById('debugMessage');
            const debugCountEl = document.getElementById('debugDataCount');
            if (debugMsgEl) debugMsgEl.textContent = '-';
            if (debugCountEl) debugCountEl.textContent = '0';

            // Reset progress bar
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '0%';
                progressFillEl.textContent = '0%';
            }

            updateStats();
        }
        
        function updateStats() {
            const pointCountEl = document.getElementById('pointCount');
            const frameCountEl = document.getElementById('frameCount');
            const progressFillEl = document.getElementById('progressFill');
            
            // Update point count
            if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
            
            // Update frame count (actual number of frames captured)
            if (frameCountEl) frameCountEl.textContent = frameCount.toLocaleString();
            
            // Update progress bar (based on point count, max 200k points = 100%)
            if (progressFillEl) {
                const maxPoints = maxTotalPoints; // Maximum expected points for a good scan
                const progress = Math.min(100, (pointCloud.length / maxPoints) * 100);
                progressFillEl.style.width = progress + '%';
                progressFillEl.textContent = Math.round(progress) + '%';
            }
        }
        
        /**
         * Calculate principal component analysis (PCA) to find main orientation
         * Returns rotation quaternion to align object upright
         */
        function calculateOrientationAlignment(points) {
            if (points.length < 3) return null;
            
            // Calculate bounding box to find longest dimension
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < points.length; i++) {
                minX = Math.min(minX, points[i].x);
                maxX = Math.max(maxX, points[i].x);
                minY = Math.min(minY, points[i].y);
                maxY = Math.max(maxY, points[i].y);
                minZ = Math.min(minZ, points[i].z);
                maxZ = Math.max(maxZ, points[i].z);
            }
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            
            // Find longest dimension
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            // For human body, Y (height) should typically be longest
            // If it's not, rotate to make the longest dimension vertical
            const rotation = new THREE.Quaternion();
            
            // Only rotate if Y is not the longest (object is tilted)
            if (maxSize === sizeX && sizeX > sizeY * 1.2) {
                // Longest is X, rotate 90 degrees around Z to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
                console.log('üîÑ Rotating: X-axis is longest, rotating 90¬∞ around Z');
            } else if (maxSize === sizeZ && sizeZ > sizeY * 1.2) {
                // Longest is Z, rotate 90 degrees around X to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                console.log('üîÑ Rotating: Z-axis is longest, rotating 90¬∞ around X');
            }
            // If Y is already longest or close, no rotation needed
            
            return rotation;
        }
        
        /**
         * Apply rotation to align object upright (horizontal/tegak)
         */
        function alignObjectUpright(obj, points) {
            if (!obj || !points || points.length < 3) return;
            
            // Calculate orientation alignment
            const rotation = calculateOrientationAlignment(points);
            if (!rotation) return;
            
            // Check if rotation is needed (quaternion is not identity)
            if (rotation.x === 0 && rotation.y === 0 && rotation.z === 0 && rotation.w === 1) {
                return; // No rotation needed
            }
            
            // Apply rotation to object
            // Store original rotation if not already stored
            if (!obj.userData.originalRotation) {
                obj.userData.originalRotation = obj.quaternion.clone();
            }
            
            // Apply rotation
            obj.quaternion.copy(rotation);
            
            console.log('üîÑ Object rotated to upright orientation');
        }
        
        function centerModel() {
            if (!scene || !camera) return;

            // Get all objects that should be centered (point cloud or mesh)
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');

            const objectsToCenter = [];
            if (pointCloudObj && pointCloudObj.visible) objectsToCenter.push(pointCloudObj);
            if (meshObj && meshObj.visible) objectsToCenter.push(meshObj);

            if (objectsToCenter.length === 0) return;

            // CATATAN: Point cloud sudah di-transform di updatePointCloudDisplay()
            // Fungsi ini hanya perlu mengatur kamera untuk melihat objek yang sudah ada

            // Get points for orientation calculation
            let pointsForAlignment = [];
            if (pointCloudObj && pointCloud.length > 0) {
                pointsForAlignment = pointCloud;
            } else if (meshObj && meshObj.geometry) {
                // Extract points from mesh geometry
                const positions = meshObj.geometry.attributes.position;
                if (positions) {
                    for (let i = 0; i < positions.count; i++) {
                        pointsForAlignment.push({
                            x: positions.getX(i),
                            y: positions.getY(i),
                            z: positions.getZ(i)
                        });
                    }
                }
            }
            
            // DISABLED: Auto-rotation and object repositioning
            // Objek sudah di-transform dengan benar di updatePointCloudDisplay()
            // Fungsi ini sekarang HANYA mengatur kamera, tidak mengubah posisi/scale objek

            // Calculate bounding box of all objects (as-is, tanpa diubah)
            const box = new THREE.Box3();
            objectsToCenter.forEach(obj => {
                obj.updateMatrixWorld();
                box.expandByObject(obj);
            });

            if (box.isEmpty()) return;

            // Calculate center and size
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);

            console.log('üìè centerModel() - Object info:', {
                center: center,
                size: size,
                maxDim: (maxDim * 1000).toFixed(0) + 'mm'
            });

            // TIDAK ada scaling atau positioning - objek sudah benar
            // Hanya adjust kamera untuk melihat objek dengan baik

            // Fit camera to view the object properly
            if (maxDim > 0) {
                // Get canvas dimensions
                const container = document.getElementById('viewer');
                const width = container ? container.clientWidth : 800;
                const height = container ? container.clientHeight : 600;

                // Calculate distance needed to fit object in view
                // Use FOV and object size to calculate optimal distance
                const fov = camera.fov * (Math.PI / 180); // Convert to radians
                const distance = Math.max(
                    maxDim / (2 * Math.tan(fov / 2)), // Fit width
                    maxDim / (2 * Math.tan(fov / 2) * (height / width)) // Fit height
                );

                // Add some padding (50% extra space around object for better view)
                const distanceWithPadding = distance * 1.5;

                // Position camera to view the object
                // Objek sudah berada di origin dengan Y=0 sebagai base
                const lookAtY = Math.max(0, size.y * 0.5); // Look at tengah objek
                const cameraY = Math.max(0, size.y * 0.4); // Camera sedikit di bawah tengah untuk perspektif yang baik

                camera.position.set(0, cameraY, distanceWithPadding);
                camera.lookAt(0, lookAtY, 0);
                camera.updateProjectionMatrix();

                console.log('üì∑ Camera adjusted:', {
                    position: camera.position,
                    lookAt: new THREE.Vector3(0, lookAtY, 0),
                    objectSize: size,
                    distance: distanceWithPadding.toFixed(3) + 'm'
                });
            }

            console.log('‚úÖ Camera adjusted to view object. Size:', size);
        }

        /**
         * ===== SIZE CONTROL FUNCTIONS =====
         * Update object scale (size) dynamically
         */
        var currentObjectScale = 1.0; // Track current scale

        function updateObjectScale(scaleValue) {
            const scale = parseFloat(scaleValue);
            currentObjectScale = scale;

            // Update display value
            document.getElementById('objectScaleValue').textContent = scale.toFixed(2) + 'x';

            // Apply scale to both point cloud and mesh
            const pointCloudObj = scene ? scene.getObjectByName('pointCloud') : null;
            const meshObj = scene ? scene.getObjectByName('mesh') : null;

            if (pointCloudObj) {
                pointCloudObj.scale.set(scale, scale, scale);
                pointCloudObj.updateMatrixWorld();
                console.log('‚úÖ Point cloud scaled to', scale.toFixed(2) + 'x');
            }

            if (meshObj) {
                meshObj.scale.set(scale, scale, scale);
                meshObj.updateMatrixWorld();
                console.log('‚úÖ Mesh scaled to', scale.toFixed(2) + 'x');
            }

            // Re-center camera to adjusted object
            if (pointCloudObj || meshObj) {
                setTimeout(() => centerModel(), 100);
            }
        }

        function adjustScale(delta) {
            const slider = document.getElementById('objectScaleSlider');
            const currentValue = parseFloat(slider.value);
            const newValue = Math.max(0.1, Math.min(3.0, currentValue + delta));
            slider.value = newValue;
            updateObjectScale(newValue);
        }

        function resetScale() {
            const slider = document.getElementById('objectScaleSlider');
            slider.value = 1.0;
            updateObjectScale(1.0);
            console.log('üîÑ Scale reset to 1.0x');
        }

        /**
         * Create a simple mesh from point cloud for STL export
         * Uses improved triangulation to create a proper mesh
         */
        function createSimpleMeshForExport(points) {
            if (points.length < 3) {
                console.warn('Not enough points for mesh export');
                return null;
            }
            
            console.log('üîß Creating simple mesh for export from', points.length, 'points...');
            
            // Downsample if too many points for performance (use uniform sampling for better quality)
            let meshPoints = points;
            const maxPoints = 150000; // Increased limit for high-quality export
            
            if (points.length > maxPoints) {
                // Use uniform sampling instead of skip factor for better quality
                const step = points.length / maxPoints;
                meshPoints = [];
                for (let i = 0; i < points.length; i += step) {
                    const idx = Math.floor(i);
                    if (idx < points.length) {
                        meshPoints.push(points[idx]);
                    }
                }
                console.log('üìâ Downsampled to', meshPoints.length, 'points for export (uniform sampling)');
            }
            
            // Terapkan transformasi yang sama dengan tampilan kanvas agar ekspor konsisten
            const transformParams = getTransformParamsForExport(meshPoints);
            if (transformParams) {
                meshPoints = applyTransformToPoints(meshPoints, transformParams);
                console.log('‚úÖ Applied canvas transform to mesh export points');
            }

            // Use improved mesh generation from pointcloud processor
            // Use finer resolution for better quality mesh
            const baseResolution = parseFloat(document.getElementById('meshResolutionSlider')?.value || 0.05);
            const resolution = Math.max(0.02, baseResolution * 0.8); // Finer resolution for export
            console.log('üîß Generating mesh with resolution:', resolution);
            
            const meshData = pointCloudProcessor.createImprovedMesh(meshPoints, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, trying with coarser resolution...');
                // Try with coarser resolution
                const coarserMesh = pointCloudProcessor.createImprovedMesh(meshPoints, resolution * 2);
                if (coarserMesh.faces.length > 0) {
                    Object.assign(meshData, coarserMesh);
                    console.log('‚úÖ Generated mesh with coarser resolution');
                } else {
                    console.warn('‚ö†Ô∏è Still no faces, using IMPROVED fallback triangulation');
                    // IMPROVED Fallback: spatial-based triangulation for better mesh
                    const fallbackFaces = [];
                    const cellSize = 0.05; // 5cm cells
                    const spatialHash = new Map();

                    // Build spatial hash
                    meshPoints.forEach((p, idx) => {
                        const key = `${Math.floor(p.x / cellSize)},${Math.floor(p.y / cellSize)},${Math.floor(p.z / cellSize)}`;
                        if (!spatialHash.has(key)) spatialHash.set(key, []);
                        spatialHash.get(key).push(idx);
                    });

                    // Generate triangles from nearby points in each cell
                    let faceCount = 0;
                    const maxFaces = 50000; // Limit faces for performance

                    spatialHash.forEach((indices) => {
                        if (faceCount >= maxFaces) return;

                        // For each cell with 3+ points, create triangles
                        if (indices.length >= 3) {
                            // Create fan triangulation from first point
                            for (let i = 1; i < indices.length - 1 && faceCount < maxFaces; i++) {
                                const v0 = meshPoints[indices[0]];
                                const v1 = meshPoints[indices[i]];
                                const v2 = meshPoints[indices[i + 1]];

                                // Validate triangle is not degenerate
                                const dx1 = v1.x - v0.x, dy1 = v1.y - v0.y, dz1 = v1.z - v0.z;
                                const dx2 = v2.x - v0.x, dy2 = v2.y - v0.y, dz2 = v2.z - v0.z;

                                // Cross product for area check
                                const cx = dy1 * dz2 - dz1 * dy2;
                                const cy = dz1 * dx2 - dx1 * dz2;
                                const cz = dx1 * dy2 - dy1 * dx2;
                                const area = Math.sqrt(cx * cx + cy * cy + cz * cz);

                                if (area > 0.0001) { // Not degenerate
                                    fallbackFaces.push([indices[0], indices[i], indices[i + 1]]);
                                    faceCount++;
                                }
                            }
                        }
                    });

                    // If still no faces, use simple nearby-point triangulation
                    if (fallbackFaces.length === 0) {
                        console.warn('‚ö†Ô∏è Spatial triangulation failed, using simple nearby-point triangulation');
                        const maxDist = 0.1; // 10cm max distance
                        for (let i = 0; i < Math.min(meshPoints.length - 2, 5000); i++) {
                            const p0 = meshPoints[i];
                            let closestPoints = [];

                            // Find 2 closest points
                            for (let j = i + 1; j < meshPoints.length && closestPoints.length < 2; j++) {
                                const p = meshPoints[j];
                                const dist = Math.sqrt(
                                    Math.pow(p.x - p0.x, 2) +
                                    Math.pow(p.y - p0.y, 2) +
                                    Math.pow(p.z - p0.z, 2)
                                );
                                if (dist < maxDist) {
                                    closestPoints.push({ idx: j, dist: dist });
                                }
                            }

                            if (closestPoints.length >= 2) {
                                fallbackFaces.push([i, closestPoints[0].idx, closestPoints[1].idx]);
                            }
                        }
                    }

                    meshData.faces = fallbackFaces;
                    console.log('‚úÖ Fallback generated ' + fallbackFaces.length + ' faces');
                }
            }
            
            console.log('‚úÖ Mesh data generated:', meshData.vertices.length, 'vertices,', meshData.faces.length, 'faces');

            // Validate mesh has faces (prevent zero volume error)
            if (meshData.faces.length === 0) {
                console.error('‚ùå No faces generated - mesh would have zero volume');
                alert('‚ùå Gagal membuat mesh untuk export!\n\n' +
                      'Mesh tidak memiliki faces (zero volume).\n\n' +
                      'üí° Solusi:\n' +
                      '1. Scan lebih lama untuk mendapatkan lebih banyak points (target: 50,000+)\n' +
                      '2. Pastikan objek jelas terlihat oleh Kinect\n' +
                      '3. Sesuaikan Mesh Resolution slider (coba nilai 0.03-0.05)\n' +
                      '4. Coba generate Watertight terlebih dahulu untuk hasil terbaik');
                return null;
            }

            // Create Three.js geometry
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Use original point colors if available
                const origPoint = meshPoints[i];
                colors[i * 3] = (origPoint.r || 128) / 255;
                colors[i * 3 + 1] = (origPoint.g || 128) / 255;
                colors[i * 3 + 2] = (origPoint.b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Filter point cloud to keep only human body, remove background
         * Uses simpler depth-based filtering - keeps points in typical human range
         * and removes outliers that are too far from the main cluster
         */
        function filterHumanBodyOnly(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m - Kinect optimal range for humans)
            const depthFiltered = points.filter(p => {
                // Z is typically the distance from Kinect (forward direction)
                // Use absolute value to handle negative Z
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No points in human depth range, using all points');
                return points;
            }
            
            console.log('üìä After depth filter:', depthFiltered.length, 'points');
            
            // Step 2: Remove outliers using statistical filtering
            // Find the main cluster by removing points that are too far from the center
            
            // Calculate center of mass
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Calculate median distance (more robust than mean)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            
            // Keep points within 2x median distance (this keeps the main body, removes far background)
            const threshold = medianDist * 2.5; // More lenient threshold
            const filtered = depthFiltered.filter((p, i) => {
                return distances[i] <= threshold;
            });
            
            console.log('‚úÖ Human body filter:', points.length, '‚Üí', filtered.length, 'points (removed', (points.length - filtered.length), 'background points)');
            
            // If filter removed too many points (>70%), return depth-filtered only
            if (filtered.length < points.length * 0.3) {
                console.warn('‚ö†Ô∏è Filter too aggressive, using depth-filtered points only');
                return depthFiltered;
            }
            
            return filtered;
        }
        
        /**
         * Filter menggunakan depth camera untuk menangkap objek 3D anggota tubuh
         * Seperti depth map: objek dekat (anggota tubuh) berwarna merah/oranye, background jauh abu-abu/hitam
         * Menggunakan depth-based filtering untuk memisahkan anggota tubuh dari background
         */
        function filterDepthBasedBodyParts(points) {
            if (points.length === 0) return points;

            console.log('üì∑ Filtering body parts using depth camera from', points.length, 'points...');

            // Step 1: Filter by depth range dengan range yang lebih luas untuk menangkap lebih banyak detail
            // Background biasanya lebih jauh dari 3.5m - HILANGKAN HANYA BACKGROUND YANG SANGAT JAUH
            const bodyPartsFiltered = points.filter(p => {
                const dist = Math.abs(p.z);
                // Range lebih luas untuk menangkap semua bagian objek: 0.5m - 3.5m
                // Background yang sangat jauh (> 3.5m) dihilangkan
                // Filter Y position dengan range yang lebih luas
                const yPos = p.y || 0;
                // Range Y yang lebih luas untuk menangkap semua bagian objek
                return dist >= 0.5 && dist <= 3.5 && yPos >= -1.5 && yPos <= 2.0;
            });

            if (bodyPartsFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No points in body parts depth range, using all points');
                return points;
            }
            
            console.log('üìä After depth-based body parts filter:', bodyPartsFiltered.length, 'points');
            
            // Step 2: Apply color mapping berdasarkan depth (seperti depth map)
            // Objek dekat (anggota tubuh) akan memiliki warna lebih cerah (merah/oranye)
            // Background jauh akan lebih gelap (abu-abu/hitam) - sudah dihilangkan di step 1
            // Untuk visualisasi, kita bisa map depth ke warna, tapi untuk filtering cukup depth saja
            
            // Step 3: Remove outliers menggunakan clustering
            if (bodyPartsFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No body parts found, using all points');
                return points;
            }
            
            // Calculate center of mass untuk clustering
            let centerX = 0, centerY = 0, centerZ = 0;
            bodyPartsFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= bodyPartsFiltered.length;
            centerY /= bodyPartsFiltered.length;
            centerZ /= bodyPartsFiltered.length;
            
            // Calculate distances from center untuk remove outliers
            const distances = bodyPartsFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Calculate median distance
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            
            // Keep points within 3.0x median distance (main cluster = anggota tubuh)
            // Threshold lebih lebar untuk menangkap lebih banyak detail
            const threshold = medianDist * 3.0;
            const filtered = bodyPartsFiltered.filter((p, i) => {
                return distances[i] <= threshold;
            });
            
            console.log('‚úÖ Depth-based body parts filter:', points.length, '‚Üí', filtered.length, 'points (removed', (points.length - filtered.length), 'background points)');

            // If filter removed too many points (>90%), return depth-filtered only
            // Threshold lebih tinggi untuk mempertahankan lebih banyak filtering
            if (filtered.length < points.length * 0.1) {
                console.warn('‚ö†Ô∏è Filter too aggressive, using depth-filtered points only');
                return bodyPartsFiltered;
            }

            return filtered;
        }
        
        /**
         * Remove duplicate/overlapping points to prevent layering
         * Uses voxel-based approach for better deduplication
         * This ensures each voxel (3D cell) contains only one point
         */
        function removeDuplicatePoints(newPoints, existingPoints) {
            if (newPoints.length === 0) return newPoints;

            console.log('üîç Removing duplicate points using voxel-based deduplication...');

            // Use voxel-based approach: each voxel can only contain one point
            // This is more effective than distance-based for preventing layering
            // LARGER voxel for 360¬∞ scans to prevent duplication
            const voxelSize = 0.015; // 1.5cm voxels (was 1cm) - more aggressive deduplication
            const voxelMap = new Map();
            
            // Build voxel map from existing points
            existingPoints.forEach((p, idx) => {
                const vx = Math.floor(p.x / voxelSize);
                const vy = Math.floor(p.y / voxelSize);
                const vz = Math.floor(p.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Store only one point per voxel (the first one)
                if (!voxelMap.has(voxelKey)) {
                    voxelMap.set(voxelKey, p);
                }
            });
            
            // Filter new points: keep only if voxel is empty
            const filtered = [];
            const newVoxelMap = new Map();
            
            for (const point of newPoints) {
                const vx = Math.floor(point.x / voxelSize);
                const vy = Math.floor(point.y / voxelSize);
                const vz = Math.floor(point.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Check if voxel is already occupied
                const existingInVoxel = voxelMap.get(voxelKey);
                const newInVoxel = newVoxelMap.get(voxelKey);
                
                if (!existingInVoxel && !newInVoxel) {
                    // Voxel is empty, add point
                    filtered.push(point);
                    newVoxelMap.set(voxelKey, point);
                } else {
                    // Voxel is occupied, check if this point is better (closer to voxel center)
                    const voxelCenterX = (vx + 0.5) * voxelSize;
                    const voxelCenterY = (vy + 0.5) * voxelSize;
                    const voxelCenterZ = (vz + 0.5) * voxelSize;
                    
                    const pointDist = Math.hypot(
                        point.x - voxelCenterX,
                        point.y - voxelCenterY,
                        point.z - voxelCenterZ
                    );
                    
                    // Replace if this point is closer to voxel center
                    if (existingInVoxel) {
                        const existingDist = Math.hypot(
                            existingInVoxel.x - voxelCenterX,
                            existingInVoxel.y - voxelCenterY,
                            existingInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < existingDist) {
                            // Replace existing point in voxel
                            voxelMap.set(voxelKey, point);
                            // Note: we can't remove from existingPoints array, but this prevents future duplicates
                        }
                    } else if (newInVoxel) {
                        const newDist = Math.hypot(
                            newInVoxel.x - voxelCenterX,
                            newInVoxel.y - voxelCenterY,
                            newInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < newDist) {
                            // Replace in new points
                            const idx = filtered.indexOf(newInVoxel);
                            if (idx !== -1) {
                                filtered[idx] = point;
                                newVoxelMap.set(voxelKey, point);
                            }
                        }
                    }
                }
            }
            
            console.log('‚úÖ Voxel deduplication: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points (removed ' + (newPoints.length - filtered.length) + ' duplicates)');
            
            return filtered;
        }
        
        /**
         * Alternative: Temporal filtering to reduce layering
         * Only keeps points that are stable across frames
         */
        function applyTemporalFiltering(newPoints, pointCloudFrames) {
            if (pointCloudFrames.length < 2) return newPoints;
            
            console.log('üîç Applying temporal filtering to reduce noise...');
            
            // Build spatial hash for recent frames
            const cellSize = 0.03; // 3cm cells
            const frameGrids = [];
            
            // Get last 3 frames for temporal consistency
            const recentFrames = pointCloudFrames.slice(-3);
            
            recentFrames.forEach(frame => {
                const grid = new Map();
                frame.forEach((p, idx) => {
                    const gx = Math.floor(p.x / cellSize);
                    const gy = Math.floor(p.y / cellSize);
                    const gz = Math.floor(p.z / cellSize);
                    const key = `${gx},${gy},${gz}`;
                    
                    if (!grid.has(key)) {
                        grid.set(key, []);
                    }
                    grid.get(key).push(p);
                });
                frameGrids.push(grid);
            });
            
            // Keep points that appear in multiple frames (more stable)
            const filtered = newPoints.filter(point => {
                const gx = Math.floor(point.x / cellSize);
                const gy = Math.floor(point.y / cellSize);
                const gz = Math.floor(point.z / cellSize);
                
                let matchCount = 0;
                
                frameGrids.forEach(grid => {
                    // Check neighboring cells
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const key = `${gx + dx},${gy + dy},${gz + dz}`;
                                const cellPoints = grid.get(key) || [];
                                
                                for (const otherPoint of cellPoints) {
                                    const dist = Math.hypot(
                                        point.x - otherPoint.x,
                                        point.y - otherPoint.y,
                                        point.z - otherPoint.z
                                    );
                                    
                                    if (dist < cellSize) {
                                        matchCount++;
                                        return; // Found match in this frame
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Keep if appears in at least 1 other frame (temporal consistency)
                return matchCount >= 1;
            });
            
            console.log('‚úÖ Temporal filter: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points');
            
            return filtered;
        }
        
        /**
         * Aggressive filter for mesh generation - removes background more aggressively
         * Uses tighter clustering to ensure only human body remains
         */
        function filterHumanBodyOnlyAggressive(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Aggressive filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m)
            const depthFiltered = points.filter(p => {
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                return points;
            }
            
            // Step 2: Find the main cluster using tighter threshold
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Use tighter threshold for aggressive filtering (1.8x instead of 2.5x)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            const threshold = medianDist * 1.8; // Tighter threshold for mesh
            
            // Also filter by Y position - human body is typically in middle-upper Y range
            // Remove points that are too low (likely floor) or too high (likely ceiling)
            const yValues = depthFiltered.map(p => p.y);
            const sortedY = [...yValues].sort((a, b) => a - b);
            const minY = sortedY[Math.floor(sortedY.length * 0.1)]; // 10th percentile
            const maxY = sortedY[Math.floor(sortedY.length * 0.9)]; // 90th percentile
            
            const filtered = depthFiltered.filter((p, i) => {
                // Check distance from center
                if (distances[i] > threshold) return false;
                // Check Y position (remove floor and ceiling)
                if (p.y < minY || p.y > maxY) return false;
                return true;
            });
            
            console.log('‚úÖ Aggressive filter:', points.length, '‚Üí', filtered.length, 'points');
            
            return filtered;
        }

        // Object position control variables - MUST be global
        window.objectPosition = { x: 0, y: 0, z: 0 };
        
        /**
         * Update object position in the scene
         * Applies position to both point cloud and mesh
         */
        window.updateObjectPosition = function() {
            if (!scene) {
                console.warn('Scene not initialized, cannot update position');
                return;
            }
            
            console.log('üìç Updating object position to:', window.objectPosition);
            
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');
            
            let updated = false;
            
            // Apply position to point cloud
            if (pointCloudObj) {
                pointCloudObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated point cloud position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Point cloud not found in scene');
            }
            
            // Apply position to mesh
            if (meshObj) {
                meshObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated mesh position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Mesh not found in scene');
            }
            
            // Apply position to bounding box
            // Bounding box dihilangkan - tidak perlu update position
            
            if (!updated) {
                console.warn('‚ö†Ô∏è No object found to update position (point cloud or mesh). Make sure you have scanned or generated mesh first.');
            }
            
            // Update display
            const posDisplay = document.getElementById('currentPosition');
            if (posDisplay) {
                posDisplay.textContent = `X: ${window.objectPosition.x.toFixed(2)}, Y: ${window.objectPosition.y.toFixed(2)}, Z: ${window.objectPosition.z.toFixed(2)}`;
            }
        };
        
        /**
         * Adjust position by increment
         */
        window.adjustPosition = function(axis, increment) {
            console.log(`üîß Adjusting position ${axis} by ${increment}`);
            window.objectPosition[axis] += increment;
            window.objectPosition[axis] = Math.max(-5, Math.min(5, window.objectPosition[axis])); // Clamp to -5 to 5
            
            // Update sliders and input fields
            const axisUpper = axis.toUpperCase();
            const slider = document.getElementById(`position${axisUpper}Slider`);
            const input = document.getElementById(`position${axisUpper}Value`);
            if (slider) {
                slider.value = window.objectPosition[axis];
                console.log(`Updated slider ${axis} to ${window.objectPosition[axis]}`);
            }
            if (input) {
                input.value = window.objectPosition[axis].toFixed(1);
                console.log(`Updated input ${axis} to ${window.objectPosition[axis]}`);
            }
            
            window.updateObjectPosition();
        };
        
        /**
         * Update position X
         */
        window.updatePositionX = function(value) {
            console.log('üîß Updating position X to:', value);
            window.objectPosition.x = parseFloat(value) || 0;
            window.objectPosition.x = Math.max(-5, Math.min(5, window.objectPosition.x));
            const slider = document.getElementById('positionXSlider');
            if (slider) {
                slider.value = window.objectPosition.x;
                console.log('Updated X slider to:', window.objectPosition.x);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Y
         */
        window.updatePositionY = function(value) {
            console.log('üîß Updating position Y to:', value);
            window.objectPosition.y = parseFloat(value) || 0;
            window.objectPosition.y = Math.max(-5, Math.min(5, window.objectPosition.y));
            const slider = document.getElementById('positionYSlider');
            if (slider) {
                slider.value = window.objectPosition.y;
                console.log('Updated Y slider to:', window.objectPosition.y);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Z
         */
        window.updatePositionZ = function(value) {
            console.log('üîß Updating position Z to:', value);
            window.objectPosition.z = parseFloat(value) || 0;
            window.objectPosition.z = Math.max(-5, Math.min(5, window.objectPosition.z));
            const slider = document.getElementById('positionZSlider');
            if (slider) {
                slider.value = window.objectPosition.z;
                console.log('Updated Z slider to:', window.objectPosition.z);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Reset object position to center
         */
        window.resetObjectPosition = function() {
            console.log('üîÑ Resetting object position to center');
            window.objectPosition = { x: 0, y: 0, z: 0 };
            
            // Update all sliders and inputs
            ['X', 'Y', 'Z'].forEach(axis => {
                const slider = document.getElementById(`position${axis}Slider`);
                const input = document.getElementById(`position${axis}Value`);
                if (slider) slider.value = 0;
                if (input) input.value = '0.0';
            });
            
            window.updateObjectPosition();
            centerModel(); // Also recenter the view
        };
        
        // Settings sliders
        document.addEventListener('DOMContentLoaded', function() {
            const maxPointsSlider = document.getElementById('maxPointsSlider');
            const meshResolutionSlider = document.getElementById('meshResolutionSlider');
            
            if (maxPointsSlider) {
                maxPointsSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('maxPointsValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            if (meshResolutionSlider) {
                meshResolutionSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('meshResolutionValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            // Position control sliders - CRITICAL: Must be set up here
            const positionXSlider = document.getElementById('positionXSlider');
            const positionYSlider = document.getElementById('positionYSlider');
            const positionZSlider = document.getElementById('positionZSlider');
            
            if (positionXSlider) {
                positionXSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.x = value;
                    const input = document.getElementById('positionXValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position X slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position X slider not found');
            }
            
            if (positionYSlider) {
                positionYSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.y = value;
                    const input = document.getElementById('positionYValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Y slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Y slider not found');
            }
            
            if (positionZSlider) {
                positionZSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.z = value;
                    const input = document.getElementById('positionZValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Z slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Z slider not found');
            }
        });

        // Auto-connect on page load
        window.addEventListener('load', function() {
            console.log('üîµ Page loaded, auto-connecting...');
            connect();
        });

        // Periodic state check for debugging
        setInterval(() => {
            if (currentMode === 'scanning') {
                const scanBtn = document.getElementById('startScanBtn');
                const hasScanningClass = scanBtn ? scanBtn.classList.contains('scanning') : false;
                if (hasScanningClass && !isScanning) {
                    console.warn('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INCONSISTENT STATE DETECTED!');
                    console.warn('Button says "Scanning..." but isScanning = false');
                    console.warn('Forcing isScanning = true...');
                    isScanning = true;
                    window.isScanning = true;
                }
            }
        }, 1000); // Check every second

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            disconnect();
        });

        // ========================================
        // Ball Pivoting Integration
        // ========================================

        // Initialize Ball Pivoting Generator
        let ballPivotingGenerator = null;

        // Initialize on page load
        window.addEventListener('load', function() {
            // Initialize Ball Pivoting
            ballPivotingGenerator = new BallPivotingMeshGenerator('http://localhost:5000');

            // Check server health silently in background
            ballPivotingGenerator.checkServerHealth().then(isHealthy => {
                if (!isHealthy) {
                    console.warn('‚ö†Ô∏è Ball Pivoting server is not running. Please start mesh-server to use Ball Pivoting method.');
                }
            });

            // Mesh method change handler
            const meshMethodSelect = document.getElementById('meshMethod');
            if (meshMethodSelect) {
                meshMethodSelect.addEventListener('change', function() {
                    updateMeshMethodDescription();
                });
            }
        });

        // Update description based on selected mesh method
        function updateMeshMethodDescription() {
            const method = document.getElementById('meshMethod').value;
            const descSpan = document.getElementById('meshMethodDesc');

            if (method === 'watertight') {
                descSpan.textContent = 'Fast processing, good quality, works offline';
                descSpan.style.color = '#2ecc71';
            } else if (method === 'ballpivoting') {
                descSpan.textContent = 'High quality mesh, requires Python server';
                descSpan.style.color = '#667eea';
            }
        }

        // Main mesh generation dispatcher
        async function generateMesh() {
            const method = document.getElementById('meshMethod').value;

            if (method === 'watertight') {
                generateWatertight();
            } else if (method === 'ballpivoting') {
                await generateBallPivoting();
            }
        }

        // Generate mesh using Ball Pivoting Algorithm
        async function generateBallPivoting() {
            if (pointCloud.length === 0) {
                alert('Tidak ada point cloud untuk di-generate mesh! Silakan lakukan scanning terlebih dahulu.');
                return;
            }

            if (pointCloud.length < 100) {
                alert('Point cloud terlalu sedikit untuk Ball Pivoting! Minimal 100 points diperlukan.');
                return;
            }

            console.log('üî∑ Generating Ball Pivoting mesh from', pointCloud.length.toLocaleString(), 'points...');

            // Check server health first
            const isHealthy = await ballPivotingGenerator.checkServerHealth();
            if (!isHealthy) {
                const startServer = confirm(
                    'Ball Pivoting server is not running!\n\n' +
                    'You need to start the Python server first:\n' +
                    '1. Open mesh-server folder\n' +
                    '2. Run setup.bat (first time only)\n' +
                    '3. Run start-server.bat\n\n' +
                    'Click OK to use Watertight method instead, or Cancel to abort.'
                );

                if (startServer) {
                    document.getElementById('meshMethod').value = 'watertight';
                    updateMeshMethodDescription();
                    generateWatertight();
                }
                return;
            }

            // Stop data capture
            const wasCaptureActive = isCaptureActive;
            isCaptureActive = false;

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode during Ball Pivoting');
            }

            // Downsample if too many points (for performance)
            let meshPoints = pointCloud;
            const maxPoints = 150000; // Ball Pivoting can handle more points

            if (pointCloud.length > maxPoints) {
                console.log('‚ö†Ô∏è Downsampling from', pointCloud.length.toLocaleString(), 'to', maxPoints.toLocaleString(), 'points');

                const voxelSize = 0.008; // 8mm voxels
                const voxelMap = new Map();

                for (const p of pointCloud) {
                    const key = `${Math.floor(p.x/voxelSize)},${Math.floor(p.y/voxelSize)},${Math.floor(p.z/voxelSize)}`;
                    if (!voxelMap.has(key)) {
                        voxelMap.set(key, p);
                    }
                }

                meshPoints = Array.from(voxelMap.values());
                console.log('‚úÖ Downsampled to', meshPoints.length.toLocaleString(), 'points');
            }

            // Update UI
            updateScanStatus('processing', 'Sending to Ball Pivoting server (' + meshPoints.length.toLocaleString() + ' points)...');
            document.getElementById('generateMeshBtn').disabled = true;

            try {
                // Configure Ball Pivoting parameters
                ballPivotingGenerator.setConfig({
                    radiusMultiplier: 1.5, // Adjust for your needs
                    numRadii: 2,
                    outputFormat: 'ply'
                });

                // Remove previous mesh if exists
                if (ballPivotingGenerator.lastMesh) {
                    scene.remove(ballPivotingGenerator.lastMesh);
                    ballPivotingGenerator.lastMesh.geometry.dispose();
                    ballPivotingGenerator.lastMesh.material.dispose();
                }

                // Generate mesh
                console.log('üì§ Sending point cloud to server...');
                updateScanStatus('processing', 'Ball Pivoting processing... (may take 10-30 seconds)');

                const mesh = await ballPivotingGenerator.processAndLoadMesh(
                    meshPoints,
                    scene,
                    {
                        useJSON: true,
                        vertexColors: true,
                        wireframe: false,
                        metalness: 0.3,
                        roughness: 0.7
                    }
                );

                console.log('‚úÖ Ball Pivoting mesh loaded successfully!');

                // Update UI
                updateScanStatus('ready', 'Ball Pivoting mesh generated successfully!');
                alert('‚úÖ Ball Pivoting mesh generated successfully!\n\nMesh is now displayed in 3D view.');

                // Enable export
                document.getElementById('exportSTLBtn').disabled = false;

                // Store mesh for export
                currentGeometry = mesh.geometry;

            } catch (error) {
                console.error('‚ùå Ball Pivoting failed:', error);
                updateScanStatus('ready', 'Ball Pivoting failed');

                const retry = confirm(
                    'Ball Pivoting mesh generation failed!\n\n' +
                    'Error: ' + error.message + '\n\n' +
                    'Possible causes:\n' +
                    '- Server not responding\n' +
                    '- Not enough points\n' +
                    '- Point cloud too sparse\n\n' +
                    'Try using Watertight method instead?'
                );

                if (retry) {
                    document.getElementById('meshMethod').value = 'watertight';
                    updateMeshMethodDescription();
                    generateWatertight();
                }
            } finally {
                document.getElementById('generateMeshBtn').disabled = false;

                // Resume capture if it was active
                if (wasCaptureActive) {
                    isCaptureActive = true;
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(currentMode === 'pointCloud' ? 'PointCloud' : 'PointCloudRGB');
                    }
                }
            }
        }
    </script>
</body>
</html>


