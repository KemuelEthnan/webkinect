<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Kinect - Example</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="pointcloud-processor.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 1.1em;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #44ff44;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .content {
            padding: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        button.scanning {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            animation: pulse-button 1s infinite;
        }

        @keyframes pulse-button {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .video-container {
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 30px;
            position: relative;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cameraImage {
            max-width: 100%;
            max-height: 600px;
            display: block;
        }

        .placeholder {
            color: #888;
            font-size: 1.2em;
        }

        .data-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .data-panel h2 {
            margin-bottom: 15px;
            color: #667eea;
        }

        #skeletonData {
            background: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .info p {
            margin: 5px 0;
        }

        /* 3D Scanning Styles */
        #viewer {
            width: 100%;
            height: 600px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.3em;
        }

        .info-item {
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .info-item label {
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #333;
            font-size: 1.1em;
        }

        .scan-progress {
            margin-top: 15px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        @media (max-width: 1200px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Web Kinect Example</h1>
            <div class="status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Menghubungkan ke server...</span>
            </div>
        </div>

        <div class="content">
            <div class="info">
                <p><strong>Catatan:</strong> Pastikan server Kinect sudah berjalan di <code>ws://127.0.0.1:8181</code></p>
                <p>Server dapat dijalankan dengan menjalankan <code>bin/server.exe</code></p>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('normal')">üéÆ Normal Mode</button>
                <button class="tab" onclick="switchTab('scanning')">üì∑ 3D Scanning</button>
            </div>

            <!-- Normal Mode Tab -->
            <div id="normalTab" class="tab-content active">
                <div class="controls">
                    <button id="connectBtn" onclick="connect()">Hubungkan</button>
                    <button id="disconnectBtn" onclick="disconnect()" disabled>Putuskan Koneksi</button>
                    <button id="colorBtn" onclick="setColorMode()" disabled>Mode Warna</button>
                    <button id="depthBtn" onclick="setDepthMode()" disabled>Mode Depth</button>
                </div>

                <div class="video-container">
                    <img id="cameraImage" style="display: none;" alt="Kinect Camera Feed">
                    <div class="placeholder" id="placeholder">Tidak ada data kamera</div>
                </div>

                <div class="data-panel">
                    <h2>üìä Skeleton Data</h2>
                    <div id="skeletonData">Menunggu data skeleton...</div>
                </div>
            </div>

            <!-- 3D Scanning Tab -->
            <div id="scanningTab" class="tab-content">
                <div class="content-grid">
                    <div class="viewer-section">
                        <div class="info">
                            <p><strong>Instruksi 3D Scanning:</strong></p>
                            <p>1. Pastikan Kinect terhubung dan objek berada di depan Kinect (jarak 0.85-4 meter)</p>
                            <p>2. Pilih mode scan: <strong>Normal</strong> (satu sisi) atau <strong>Dua Fase</strong> (depan & belakang)</p>
                            <p>3. Klik "Mulai Scan" - sistem akan otomatis menangkap model 3D</p>
                            <p style="margin-left: 20px; color: #666;">‚Ä¢ Mode Normal: 60 detik</p>
                            <p style="margin-left: 20px; color: #666;">‚Ä¢ Mode Dua Fase: Fase 1 (depan) 15 detik, lalu Fase 2 (belakang) 15 detik</p>
                            <p>4. Progress bar akan menunjukkan progress dari 0-100%</p>
                            <p>5. Gerakkan objek atau pindahkan Kinect untuk mendapatkan berbagai sudut saat scanning</p>
                            <p>6. Setelah scanning selesai (progress 100%), klik "Generate Mesh" untuk membuat 3D model</p>
                            <p>7. Klik "Export STL" untuk menyimpan file .stl</p>
                            <p style="color: #d32f2f; font-weight: bold;">‚ö†Ô∏è Mode Dua Fase: Setelah Fase 1 selesai, putar objek 180¬∞ lalu klik "Mulai Fase 2"</p>
                            <p><strong>Tips:</strong> Buka Console browser (F12) untuk melihat log debugging</p>
                        </div>

                        <div class="controls">
                            <button id="startScanBtn" onclick="startScan()" disabled>Reset & Start Capture</button>
                            <button id="startPhase2Btn" onclick="startPhase2()" disabled style="display: none; background: #ff9800; color: white;">Mulai Fase 2 (Belakang)</button>
                            <button id="stopScanBtn" onclick="stopCapture()" disabled>Stop Capture</button>
                            <button id="generateMeshBtn" onclick="generateMesh()" disabled>Generate Mesh</button>
                            <button id="exportSTLBtn" onclick="exportSTL()" disabled>Export STL</button>
                            <button id="clearBtn" onclick="clearScan()" disabled>Clear</button>
                        </div>

                        <div id="viewer"></div>
                    </div>

                    <div class="sidebar">
                        <div class="panel">
                            <h2>üìä Scan Info</h2>
                            <div class="info-item">
                                <label>Status:</label>
                                <span id="scanStatus">Tidak aktif</span>
                            </div>
                            <div class="info-item">
                                <label>Point Count:</label>
                                <span id="pointCount">0</span>
                            </div>
                            <div class="info-item">
                                <label>Frames Captured:</label>
                                <span id="frameCount">0</span>
                            </div>
                            <div class="scan-progress">
                                <label>Progress:</label>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
                                </div>
                            </div>
                        </div>

                        <div class="panel">
                            <h2>‚öôÔ∏è Settings</h2>
                            <div class="info-item">
                                <label>Max Points per Frame:</label>
                                <input type="range" id="maxPointsSlider" min="1000" max="100000" value="20000" step="1000">
                                <span id="maxPointsValue">20000</span>
                            </div>
                            <div class="info-item">
                                <label>Mesh Resolution:</label>
                                <input type="range" id="meshResolutionSlider" min="0.01" max="0.1" value="0.05" step="0.01">
                                <span id="meshResolutionValue">0.05</span>
                            </div>
                            <div class="info-item">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="enableICPCheckbox" style="width: auto;">
                                    Enable ICP Alignment (‚ö†Ô∏è Causes lag - disabled by default)
                                </label>
                            </div>
                            <div class="info-item">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" id="enableNoiseFilterCheckbox" style="width: auto;">
                                    Enable Noise Filtering (‚ö†Ô∏è Causes lag - disabled by default)
                                </label>
                            </div>
                            <div class="info-item" style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-radius: 5px; border: 2px solid #2196f3;">
                                <label style="display: flex; align-items: center; gap: 8px; font-weight: bold;">
                                    <input type="checkbox" id="enableMultiPhaseCheckbox" style="width: auto;" onchange="toggleMultiPhaseMode()">
                                    üîÑ Scan Dua Fase (Depan & Belakang)
                                </label>
                                <p style="margin: 8px 0 0 0; font-size: 0.9em; color: #555;">
                                    Fase 1: Scan depan (15 detik)<br>
                                    Fase 2: Scan belakang (15 detik)<br>
                                    Hasil: Objek 3D utuh dari kedua sisi
                                </p>
                            </div>
                            <div class="info-item" id="phaseInfo" style="display: none; margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 5px;">
                                <label style="font-weight: bold;">Fase Saat Ini:</label>
                                <span id="currentPhase" style="font-size: 1.1em; color: #d32f2f;">-</span>
                            </div>
                        </div>

                        <div class="panel">
                            <h2>üìç Position Control</h2>
                            <div class="info-item">
                                <label>Position X:</label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="range" id="positionXSlider" min="-5" max="5" value="0" step="0.1" style="flex: 1;">
                                    <input type="number" id="positionXValue" value="0" step="0.1" style="width: 80px;" onchange="updatePositionX(this.value)">
                                    <button onclick="adjustPosition('x', -0.1)" style="padding: 5px 10px; font-size: 14px;">-</button>
                                    <button onclick="adjustPosition('x', 0.1)" style="padding: 5px 10px; font-size: 14px;">+</button>
                                </div>
                            </div>
                            <div class="info-item">
                                <label>Position Y:</label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="range" id="positionYSlider" min="-5" max="5" value="0" step="0.1" style="flex: 1;">
                                    <input type="number" id="positionYValue" value="0" step="0.1" style="width: 80px;" onchange="updatePositionY(this.value)">
                                    <button onclick="adjustPosition('y', -0.1)" style="padding: 5px 10px; font-size: 14px;">-</button>
                                    <button onclick="adjustPosition('y', 0.1)" style="padding: 5px 10px; font-size: 14px;">+</button>
                                </div>
                            </div>
                            <div class="info-item">
                                <label>Position Z:</label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="range" id="positionZSlider" min="-5" max="5" value="0" step="0.1" style="flex: 1;">
                                    <input type="number" id="positionZValue" value="0" step="0.1" style="width: 80px;" onchange="updatePositionZ(this.value)">
                                    <button onclick="adjustPosition('z', -0.1)" style="padding: 5px 10px; font-size: 14px;">-</button>
                                    <button onclick="adjustPosition('z', 0.1)" style="padding: 5px 10px; font-size: 14px;">+</button>
                                </div>
                            </div>
                            <div class="info-item" style="margin-top: 15px;">
                                <button onclick="resetObjectPosition()" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">
                                    üîÑ Reset to Center
                                </button>
                            </div>
                            <div class="info-item" style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
                                <label style="font-size: 0.9em; color: #666;">Current Position:</label>
                                <div id="currentPosition" style="font-size: 1.1em; font-weight: 600; color: #333;">X: 0.00, Y: 0.00, Z: 0.00</div>
                            </div>
                        </div>

                        <div class="panel">
                            <h2>üíæ Export</h2>
                            <p>Setelah generate mesh, klik "Export STL" untuk menyimpan file.</p>
                        </div>

                        <div class="panel">
                            <h2>üîç Debug Info</h2>
                            <div class="info-item">
                                <label>Last Message:</label>
                                <span id="debugMessage" style="font-size: 0.9em; color: #666;">-</span>
                            </div>
                            <div class="info-item">
                                <label>Data Received:</label>
                                <span id="debugDataCount">0</span>
                            </div>
                            <div class="info-item">
                                <label>Point Cloud Frames:</label>
                                <span id="pointCloudFramesCount">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        var socket = null;
        var connected = false;
        var currentMode = 'normal'; // 'normal' or 'scanning'

        // 3D Scanning variables
        var isScanning = false;
        var isCaptureActive = true; // New flag for auto-capture control
        var pointCloud = [];
        var mesh = null;
        var scene, camera, renderer;
        var viewerInitialized = false;
        var debugDataCount = 0;
        var frameCount = 0;
        var scanTimer = null;
        var scanStartTime = 0;
        var scanDuration = 60000; // Auto-stop after 60 seconds (increased for more points)
        var dataReceivedDuringScan = 0;
        var pointCloudDataReceived = 0;
        var maxTotalPoints = 500000; // Limit to 500k points for high-quality scans
        var autoCaptureTimer = null;
        
        // Multi-phase scanning (depan dan belakang)
        var scanPhase = 0; // 0 = not started, 1 = depan (front), 2 = belakang (back)
        var pointCloudFront = []; // Point cloud from phase 1 (depan)
        var pointCloudBack = []; // Point cloud from phase 2 (belakang)
        var phaseDuration = 15000; // 15 seconds per phase
        var isMultiPhaseMode = false; // Enable/disable multi-phase mode
        
        // Point cloud processing
        var pointCloudProcessor = new PointCloudProcessor();
        var pointCloudFrames = [];
        var useICP = false; // Disabled by default - too CPU intensive!
        var useNoiseFilter = false; // Disabled by default - too CPU intensive!
        var kinectPosition = { x: 0, y: 0, z: 0 };

        // Throttling to prevent freeze
        var lastProcessTime = 0;
        var processingThrottle = 100; // Process max once every 100ms
        var renderThrottle = 50; // Render max once every 50ms
        var lastRenderTime = 0;

        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            if (tab === 'normal') {
                document.querySelector('.tab:first-child').classList.add('active');
                document.getElementById('normalTab').classList.add('active');
                currentMode = 'normal';
                // Switch back to Color mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("Color");
                }
            } else {
                document.querySelector('.tab:last-child').classList.add('active');
                document.getElementById('scanningTab').classList.add('active');
                currentMode = 'scanning';

                console.log('üîµ Switched to 3D Scanning tab - AUTO-CAPTURE MODE (60 seconds)');
                console.log('üìå Auto-capture will run for 60 seconds (or until max points reached) then stop automatically');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());

                // Initialize 3D viewer if not already done
                if (!viewerInitialized) {
                    console.log('üîµ Initializing 3D viewer...');
                    initViewer();
                    viewerInitialized = true;
                }

                // Switch to PointCloud mode if connected
                if (connected && socket && socket.readyState === WebSocket.OPEN) {
                    socket.send("PointCloud");
                    console.log('üì§ Switched to PointCloud mode via tab switch');

                    // Enable buttons
                    const startBtn = document.getElementById('startScanBtn');
                    const stopBtn = document.getElementById('stopScanBtn');
                    if (startBtn) startBtn.disabled = false;
                    if (stopBtn) stopBtn.disabled = false;

                    // Reset and start auto-capture with 15 second timer
                    isCaptureActive = true;
                    scanStartTime = Date.now();

                    // Update status
                    document.getElementById('scanStatus').textContent = 'Auto-capturing for 60 seconds...';

                    // Auto-stop after scanDuration (60 seconds) OR when max points reached
                    if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
                    autoCaptureTimer = setTimeout(() => {
                        console.log('‚è±Ô∏è ' + (scanDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                        console.log('üìä Final point count:', pointCloud.length.toLocaleString());
                        stopCapture();
                    }, scanDuration);

                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode switch');
                        }
                    }, 100);
                }
            }
        }

        function updateStatus(isConnected) {
            connected = isConnected;
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const colorBtn = document.getElementById('colorBtn');
            const depthBtn = document.getElementById('depthBtn');
            const startScanBtn = document.getElementById('startScanBtn');

            if (isConnected) {
                indicator.classList.add('connected');
                statusText.textContent = 'Terhubung ke server';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                colorBtn.disabled = false;
                depthBtn.disabled = false;
                if (startScanBtn) startScanBtn.disabled = false;
            } else {
                indicator.classList.remove('connected');
                statusText.textContent = 'Tidak terhubung';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                colorBtn.disabled = true;
                depthBtn.disabled = true;
                if (startScanBtn) startScanBtn.disabled = true;
            }
        }

        function connect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('Already connected');
                return;
            }

            console.log('Connecting to ws://127.0.0.1:8181...');
            socket = new WebSocket("ws://127.0.0.1:8181");

            socket.onopen = function() {
                console.log('Connected to server');
                updateStatus(true);
                // Set initial mode based on current tab
                if (currentMode === 'scanning') {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode on connect');
                    // Send again to ensure mode switch
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.OPEN) {
                            socket.send("PointCloud");
                            console.log('üì§ Confirmed PointCloud mode on connect');
                        }
                    }, 100);
                } else {
                    socket.send("Color");
                    console.log('üì§ Sent Color mode on connect');
                }
            };

            socket.onclose = function() {
                console.log('Disconnected from server');
                updateStatus(false);
                document.getElementById('cameraImage').style.display = 'none';
                document.getElementById('placeholder').style.display = 'block';
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateStatus(false);
                alert('Error: Tidak dapat terhubung ke server. Pastikan server.exe sudah berjalan.');
            };

            socket.onmessage = function(event) {
                // Skeleton data or Point Cloud (JSON string)
                if (typeof event.data === "string") {
                    // Count data received during scan
                    if (isScanning) {
                        dataReceivedDuringScan++;
                    }
                    
                    try {
                        // Log raw data untuk debugging (first 500 chars)
                        const rawDataPreview = event.data.length > 500 ? event.data.substring(0, 500) + '...' : event.data;
                        console.log('üì• Received string data, length:', event.data.length, 'chars', isScanning ? '(during scan)' : '');
                        if (!isScanning || dataReceivedDuringScan <= 3) { // Only log first few during scan to avoid spam
                            console.log('üì• Raw data preview:', rawDataPreview);
                        }
                        
                        var data = JSON.parse(event.data);
                        console.log('‚úÖ Parsed JSON successfully. Keys:', Object.keys(data));
                        console.log('üìã Full data structure:', {
                            hasMode: !!data.mode,
                            mode: data.mode,
                            hasData: !!data.data,
                            dataIsArray: Array.isArray(data.data),
                            dataLength: data.data ? data.data.length : 0,
                            hasSkeletons: !!data.skeletons,
                            width: data.width,
                            height: data.height
                        });
                        
                        // Check if it's point cloud data (server sends: {mode: "PointCloud", data: [...], width, height})
                        if (data.mode === 'PointCloud' && data.data && Array.isArray(data.data)) {
                            // Count point cloud data received
                            if (isScanning) {
                                pointCloudDataReceived++;
                            }
                            
                            // Create a new object in the format the rest of the JS expects
                            const pointCloudPayload = { points: data.data };

                            debugDataCount++;
                            const debugMsg = `Received ${pointCloudPayload.points.length} points (Mode: ${currentMode}, Scanning: ${isScanning})`;
                            console.log('‚úÖ‚úÖ‚úÖ Point cloud data received!', {
                                pointCount: pointCloudPayload.points.length,
                                width: data.width,
                                height: data.height,
                                currentMode: currentMode,
                                isScanning: isScanning,
                                firstPoint: pointCloudPayload.points.length > 0 ? pointCloudPayload.points[0] : 'no points',
                                totalPointCloudFrames: pointCloudDataReceived
                            });
                            
                            // Update debug UI
                            const debugMsgEl = document.getElementById('debugMessage');
                            const debugCountEl = document.getElementById('debugDataCount');
                            const pointCloudFramesEl = document.getElementById('pointCloudFramesCount');
                            if (debugMsgEl) debugMsgEl.textContent = debugMsg;
                            if (debugCountEl) debugCountEl.textContent = debugDataCount;
                            if (pointCloudFramesEl) pointCloudFramesEl.textContent = pointCloudDataReceived;
                            
                            // üî• RADICAL SIMPLIFICATION: If we're in scanning tab, ALWAYS process point cloud data
                            // This bypasses all the complex isScanning flag logic that keeps failing
                            if (currentMode === 'scanning') {
                                // Check if we should still capture (auto-stop after limit or duration)
                                if (!isCaptureActive) {
                                    console.log('‚è∏Ô∏è Capture stopped - ignoring new data');
                                    return;
                                }

                                // Check if we've hit the point limit
                                if (pointCloud.length >= maxTotalPoints) {
                                    console.log('‚è∏Ô∏è Max points reached (' + maxTotalPoints.toLocaleString() + ') - stopping capture');
                                    stopCapture();
                                    return;
                                }

                                console.log('üîÑ AUTO-PROCESSING point cloud data (simplified mode)...');
                                console.log('üìä Received ' + pointCloudPayload.points.length + ' points');

                                // Always process in scanning mode - no button check needed
                                processPointCloud(pointCloudPayload);

                                // Update scan info
                                const pointCountEl = document.getElementById('pointCount');
                                const frameCountEl = document.getElementById('frameCount');
                                if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
                                if (frameCountEl) frameCountEl.textContent = frameCount;
                            } else {
                                console.log('‚ö†Ô∏è Point cloud data received but not in scanning tab');
                                if (debugMsgEl) debugMsgEl.textContent = 'Data received but not in scanning tab';
                            }
                        } 
                        // Check if it's skeleton data (server sends: {skeletons: [...]})
                        else if (data.skeletons && Array.isArray(data.skeletons)) {
                            // Only process skeleton data in normal mode
                            if (currentMode === 'normal') {
                                document.getElementById('skeletonData').textContent = 
                                    JSON.stringify(data, null, 2);
                                console.log('Skeleton data received:', data);
                            } else {
                                // In scanning mode, ignore skeleton data (it's from old Color mode frames)
                                // But also try to force switch mode again if we keep receiving skeleton data
                                if (isScanning) {
                                    console.log('‚ö†Ô∏è Ignoring skeleton data in scanning mode - server mungkin belum switch mode');
                                    console.log('üîÑ Attempting to force switch to PointCloud mode again...');
                                    
                                    // Force switch again
                                    if (socket && socket.readyState === WebSocket.OPEN) {
                                        socket.send("PointCloud");
                                        console.log('üì§ Re-sent PointCloud mode request');
                                    }
                                    
                                    const debugMsgEl = document.getElementById('debugMessage');
                                    if (debugMsgEl) debugMsgEl.textContent = 'Server masih mengirim skeleton data - mencoba switch mode lagi...';
                                }
                            }
                        } 
                        // Check if it's point cloud data but with empty array (mode active but no valid points)
                        else if (data.mode === 'PointCloud' && (!data.data || !Array.isArray(data.data))) {
                            console.warn('‚ö†Ô∏è PointCloud mode detected but data format invalid:', {
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                dataValue: data.data
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'PointCloud mode active but data format invalid';
                        }
                        // Unknown data format
                        else {
                            console.warn('‚ö†Ô∏è Unknown JSON data format received:', {
                                keys: Object.keys(data),
                                hasMode: !!data.mode,
                                mode: data.mode,
                                hasSkeletons: !!data.skeletons,
                                hasData: !!data.data,
                                dataType: typeof data.data,
                                currentMode: currentMode,
                                fullData: JSON.stringify(data).substring(0, 200)
                            });
                            const debugMsgEl = document.getElementById('debugMessage');
                            if (debugMsgEl) debugMsgEl.textContent = 'Unknown data format: ' + Object.keys(data).join(', ') + ' | Mode: ' + (data.mode || 'none');
                        }
                    } catch (e) {
                        console.error('‚ùå Error parsing JSON data:', e);
                        console.error('Raw data (first 200 chars):', event.data.substring(0, 200));
                        const debugMsgEl = document.getElementById('debugMessage');
                        if (debugMsgEl) debugMsgEl.textContent = 'Error parsing data: ' + e.message;
                    }
                }
                // Camera feed (Blob) - only process in normal mode
                else if (event.data instanceof Blob && currentMode === 'normal') {
                    var url = URL.createObjectURL(event.data);
                    var img = document.getElementById('cameraImage');
                    img.src = url;
                    img.style.display = 'block';
                    document.getElementById('placeholder').style.display = 'none';
                    
                    // Revoke old URL to prevent memory leaks
                    if (img.dataset.oldUrl) {
                        URL.revokeObjectURL(img.dataset.oldUrl);
                    }
                    img.dataset.oldUrl = url;
                }
            };
        }

        function disconnect() {
            if (socket) {
                socket.close();
                socket = null;
            }
            updateStatus(false);
        }

        function setColorMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('Switched to Color mode');
            }
        }

        function setDepthMode() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Depth");
                console.log('Switched to Depth mode');
            }
        }

        // ========== 3D Scanning Functions ==========
        
        function initViewer() {
            const container = document.getElementById('viewer');
            if (!container) return;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(10, 10);
            scene.add(gridHelper);
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);
            
            // Simple orbit controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                    camera.position.applyAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * 0.01);
                    camera.lookAt(0, 0, 0);
                }
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const delta = e.deltaY * 0.001;
                camera.position.multiplyScalar(1 + delta);
            });
            
            animate();
        }
        
        function animate() {
            if (renderer && scene && camera) {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
        }
        
        function processPointCloud(data) {
            // üî• CRITICAL: Check if capture is still active - stop processing if not
            if (!isCaptureActive) {
                console.log('‚è∏Ô∏è Capture stopped - ignoring point cloud data');
                return;
            }
            
            // üî• THROTTLING: Skip if processing too frequently (prevent freeze)
            const now = Date.now();
            if (now - lastProcessTime < processingThrottle) {
                console.log('‚è≠Ô∏è Skipping frame (throttle) - too fast');
                return;
            }
            lastProcessTime = now;

            if (!data || !data.points || !Array.isArray(data.points)) {
                console.warn('‚ö†Ô∏è Invalid point cloud data:', data);
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Error: Invalid point cloud data format';
                return;
            }

            // Log even if empty to help debugging
            console.log('üîç Processing', data.points.length, 'points (Frame #' + frameCount + ')');

            if (data.points.length === 0) {
                console.warn('‚ö†Ô∏è Received empty point cloud - mungkin objek tidak terdeteksi atau terlalu jauh/dekat');
                const debugMsgEl = document.getElementById('debugMessage');
                if (debugMsgEl) debugMsgEl.textContent = 'Warning: Empty point cloud - pastikan objek dalam range 0.85-4 meter';
                // Still increment frame count to show that we're receiving data
                frameCount++;
                updateStats();
                return;
            }
            
            const maxPoints = parseInt(document.getElementById('maxPointsSlider').value);
            let newPoints = data.points.slice(0, Math.min(data.points.length, maxPoints));
            
            if (newPoints.length === 0) {
                frameCount++;
                updateStats();
                return;
            }
            
            // Validate point structure
            const firstPoint = newPoints[0];
            if (!firstPoint || !firstPoint.hasOwnProperty('x') || !firstPoint.hasOwnProperty('y') || !firstPoint.hasOwnProperty('z')) {
                console.error('‚ùå Invalid point structure:', firstPoint);
                return;
            }
            
            // OPTIMIZATION: Skip heavy processing for real-time performance
            // Noise filtering and ICP are disabled by default
            // You can enable them in settings if needed (but may cause lag)

            if (useNoiseFilter && newPoints.length > 10) {
                console.log('üîß Applying noise filtering... (this may cause lag)');
                try {
                    const beforeFilter = newPoints.length;
                    newPoints = pointCloudProcessor.statisticalOutlierRemoval(newPoints, 20, 2.0);
                    console.log(`‚úÖ Noise filtering: ${beforeFilter} ‚Üí ${newPoints.length} points`);
                } catch (err) {
                    console.error('‚ùå Noise filtering failed:', err);
                }
            }

            // Store frame for ICP
            pointCloudFrames.push([...newPoints]);

            // Transform to world coordinate (currently Kinect is stationary, so no transform)
            // Future: if Kinect moves, apply transform here
            newPoints = pointCloudProcessor.transformToWorldCoordinate(newPoints, null);

            // Apply ICP alignment if enabled and we have previous frames
            if (useICP && pointCloud.length > 100 && newPoints.length > 10) {
                console.log('üîß Applying ICP alignment... (this may cause lag)');
                try {
                    const icpResult = pointCloudProcessor.icpAlign(newPoints, pointCloud, 10, 0.01);
                    if (icpResult.transform) {
                        newPoints = icpResult.alignedPoints;
                        console.log('‚úÖ ICP alignment applied');
                    } else {
                        console.log('‚ö†Ô∏è ICP alignment failed, using original points');
                    }
                } catch (err) {
                    console.error('‚ùå ICP alignment failed:', err);
                }
            }
            
            // Update Kinect position estimate (for future tracking)
            if (pointCloud.length === 0) {
                kinectPosition = pointCloudProcessor.estimateKinectPosition(newPoints);
            }
            
            // Filter to keep only human body, remove background
            // Only apply filter if we have enough points to filter effectively
            let humanBodyPoints = newPoints;
            if (newPoints.length > 100) {
                try {
                    humanBodyPoints = filterHumanBodyOnly(newPoints);
                    // If filter removed too many points (>80%), use original points
                    if (humanBodyPoints.length < newPoints.length * 0.2) {
                        console.warn('‚ö†Ô∏è Filter too aggressive, using original points');
                        humanBodyPoints = newPoints;
                    }
                } catch (err) {
                    console.error('‚ùå Filter error, using original points:', err);
                    humanBodyPoints = newPoints;
                }
            }
            
            // CRITICAL: Remove duplicate/overlapping points to prevent layering
            // Use voxel-based deduplication for better results
            const beforeDedup = humanBodyPoints.length;
            humanBodyPoints = removeDuplicatePoints(humanBodyPoints, pointCloud);
            
            // Optional: Apply temporal filtering for additional stability (can be enabled)
            // This helps reduce noise and layering from frame-to-frame variations
            // humanBodyPoints = applyTemporalFiltering(humanBodyPoints, pointCloudFrames);
            
            console.log('üìä Deduplication: ' + beforeDedup + ' ‚Üí ' + humanBodyPoints.length + ' points');
            
            // Add filtered and deduplicated points to point cloud
            pointCloud.push(...humanBodyPoints);
            frameCount++;

            const addedCount = humanBodyPoints.length;
            const duplicatesRemoved = beforeDedup - addedCount;
            console.log('‚úÖ Added ' + addedCount + ' points (from ' + newPoints.length + ', duplicates removed: ' + duplicatesRemoved + '). Total: ' + pointCloud.length.toLocaleString());

            // Update display and stats (throttled)
            requestAnimationFrame(() => {
                const now = Date.now();
                if (now - lastRenderTime >= renderThrottle) {
                    updatePointCloudDisplay();
                    // Center model more frequently to keep it visible
                    setTimeout(() => centerModel(), 100);
                    lastRenderTime = now;
                }
                updateStats();
            });
            
            console.log('‚úÖ‚úÖ‚úÖ Successfully added', newPoints.length, 'points. Total:', pointCloud.length, 'points from', frameCount, 'frames');
            
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) {
                const duplicatesRemoved = newPoints.length - humanBodyPoints.length;
                debugMsgEl.textContent = `‚úÖ Added ${humanBodyPoints.length} points (removed ${duplicatesRemoved} duplicates/background). Total: ${pointCloud.length} points`;
            }
        }
        
        function updatePointCloudDisplay() {
            if (!scene) {
                console.warn('Scene not initialized');
                return;
            }
            
            const oldPointCloud = scene.getObjectByName('pointCloud');
            if (oldPointCloud) {
                scene.remove(oldPointCloud);
            }
            
            if (pointCloud.length === 0) {
                console.log('No points to display');
                return;
            }
            
            console.log('Updating point cloud display with', pointCloud.length, 'points');
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(pointCloud.length * 3);
            const colors = new Float32Array(pointCloud.length * 3);
            
            // Calculate bounds for camera positioning
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < pointCloud.length; i++) {
                const point = pointCloud[i];
                const x = point.x || 0;
                const y = point.y || 0;
                const z = point.z || 0;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                colors[i * 3] = (point.r || 128) / 255;
                colors[i * 3 + 1] = (point.g || 128) / 255;
                colors[i * 3 + 2] = (point.b || 128) / 255;
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                minZ = Math.min(minZ, z);
                maxZ = Math.max(maxZ, z);
            }
            
            console.log('Point cloud bounds:', {
                x: [minX, maxX],
                y: [minY, maxY],
                z: [minZ, maxZ]
            });
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.02, // Increased size for better visibility
                vertexColors: true,
                sizeAttenuation: false
            });
            
            const pointsObj = new THREE.Points(geometry, material);
            pointsObj.name = 'pointCloud';
            scene.add(pointsObj);
            
            // Apply current manual position
            pointsObj.position.set(
                window.objectPosition ? window.objectPosition.x : 0,
                window.objectPosition ? window.objectPosition.y : 0,
                window.objectPosition ? window.objectPosition.z : 0
            );
            
            // Center and fit the point cloud immediately after adding
            // This ensures it's always visible
            setTimeout(() => {
                centerModel();
            }, 50);
        }
        
        function startScan() {
            console.log('üîµüîµüîµ startScan() called - SIMPLIFIED MODE üîµüîµüîµ');

            if (!connected) {
                alert('Harus terhubung ke server terlebih dahulu!');
                console.error('‚ùå Cannot start scan: not connected');
                return;
            }

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif! Silakan hubungkan terlebih dahulu.');
                console.error('‚ùå Cannot start scan: WebSocket not open');
                return;
            }

            // Check if multi-phase mode is enabled
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox')?.checked || false;
            
            if (isMultiPhaseMode) {
                // Multi-phase mode: Phase 1 (depan)
                scanPhase = 1;
                pointCloudFront = [];
                pointCloudBack = [];
                pointCloud = []; // Reset current point cloud
                console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 1 (Depan/Front)');
                console.log('üìå Duration: 15 seconds');
            } else {
                // Normal mode: single scan
                scanPhase = 0;
                pointCloud = [];
                console.log('üöÄ Starting REAL-TIME CAPTURE (60 seconds or until ' + maxTotalPoints.toLocaleString() + ' points)...');
                console.log('üìå Mode: Simplified auto-capture');
                console.log('üìå Duration: 60 seconds (or until max points reached)');
                console.log('üìå Max points: ' + maxTotalPoints.toLocaleString());
            }

            // Reset data
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();

            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;

            // Auto-stop timer - different duration for multi-phase vs normal
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
            const currentDuration = isMultiPhaseMode ? phaseDuration : scanDuration;
            autoCaptureTimer = setTimeout(() => {
                console.log('‚è±Ô∏è ' + (currentDuration / 1000) + ' seconds elapsed - auto-stopping capture');
                console.log('üìä Final point count:', pointCloud.length.toLocaleString());
                if (isMultiPhaseMode && scanPhase === 1) {
                    // Phase 1 complete, save to pointCloudFront
                    pointCloudFront = [...pointCloud];
                    console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                    stopCapture();
                    // Show button for Phase 2
                    document.getElementById('startPhase2Btn').style.display = 'inline-block';
                    document.getElementById('startPhase2Btn').disabled = false;
                    document.getElementById('scanStatus').textContent = 'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2"';
                } else {
                    stopCapture();
                }
            }, currentDuration);
            
            // Get settings
            useICP = document.getElementById('enableICPCheckbox').checked;
            useNoiseFilter = document.getElementById('enableNoiseFilterCheckbox').checked;
            
            // Clear any existing timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = isMultiPhaseMode ? 'Scanning Fase 1...' : 'Scanning...';
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('clearBtn').disabled = false;
            document.getElementById('scanStatus').textContent = isMultiPhaseMode ? 'Scanning Fase 1 (Depan)...' : 'Scanning...';
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            if (isMultiPhaseMode) {
                document.getElementById('currentPhase').textContent = 'Fase 1: Depan';
            }
            
            // Send PointCloud mode request directly and multiple times to ensure server receives it
            console.log('üîÑ Switching server mode to PointCloud...');
            
            // Send immediately
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request to server (attempt 1)');
            
            // Send multiple times with delays to ensure server processes it
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 2)');
                }
            }, 50);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 3)');
                }
            }, 150);
            
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN && isScanning) {
                    socket.send("PointCloud");
                    console.log('üì§ Sent PointCloud mode request to server (attempt 4)');
                }
            }, 300);
            
            // Start progress bar update timer
            scanTimer = setInterval(() => {
                if (!isScanning) {
                    clearInterval(scanTimer);
                    return;
                }
                
                const elapsed = Date.now() - scanStartTime;
                const progress = Math.min(100, (elapsed / scanDuration) * 100);
                
                const progressFillEl = document.getElementById('progressFill');
                if (progressFillEl) {
                    progressFillEl.style.width = progress + '%';
                    progressFillEl.textContent = Math.round(progress) + '%';
                }
                
                // Auto-stop after scan duration
                if (elapsed >= scanDuration) {
                    console.log('‚è±Ô∏è Scan duration completed, stopping automatically...');
                    stopScan();
                }
            }, 50); // Update every 50ms for smooth progress bar
            
            // Update debug message
            const debugMsgEl = document.getElementById('debugMessage');
            if (debugMsgEl) debugMsgEl.textContent = 'Waiting for PointCloud data from server...';
        }
        
        /**
         * Toggle multi-phase mode on/off
         */
        function toggleMultiPhaseMode() {
            isMultiPhaseMode = document.getElementById('enableMultiPhaseCheckbox').checked;
            const phaseInfoEl = document.getElementById('phaseInfo');
            if (phaseInfoEl) {
                phaseInfoEl.style.display = isMultiPhaseMode ? 'block' : 'none';
            }
            
            if (isMultiPhaseMode) {
                console.log('üîÑ Multi-phase mode ENABLED');
                document.getElementById('currentPhase').textContent = 'Belum dimulai';
            } else {
                console.log('üîÑ Multi-phase mode DISABLED');
                scanPhase = 0;
            }
        }
        
        /**
         * Start Phase 2 (belakang/back) scanning
         */
        function startPhase2() {
            if (!connected || !socket || socket.readyState !== WebSocket.OPEN) {
                alert('Koneksi WebSocket tidak aktif!');
                return;
            }
            
            if (pointCloudFront.length === 0) {
                alert('Fase 1 belum selesai atau tidak ada data!');
                return;
            }
            
            console.log('üîÑ Starting MULTI-PHASE SCAN - Phase 2 (Belakang/Back)');
            console.log('üìå Duration: 15 seconds');
            console.log('üìå Phase 1 points: ' + pointCloudFront.length.toLocaleString());
            
            // Set phase 2
            scanPhase = 2;
            pointCloudBack = [];
            pointCloud = []; // Reset current point cloud for phase 2
            
            // Reset counters
            pointCloudFrames = [];
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            scanStartTime = Date.now();
            
            // Set flags
            isScanning = true;
            window.isScanning = true;
            isCaptureActive = true;
            
            // Auto-stop after phaseDuration (15 seconds)
            if (autoCaptureTimer) clearTimeout(autoCaptureTimer);
            autoCaptureTimer = setTimeout(() => {
                console.log('‚è±Ô∏è Phase 2 (15 seconds) elapsed - auto-stopping capture');
                pointCloudBack = [...pointCloud];
                console.log('‚úÖ Phase 2 (Belakang) complete: ' + pointCloudBack.length.toLocaleString() + ' points');
                
                // Merge both phases
                mergePhasePointClouds();
                
                stopCapture();
            }, phaseDuration);
            
            // Update UI
            document.getElementById('startPhase2Btn').disabled = true;
            document.getElementById('startPhase2Btn').style.display = 'none';
            document.getElementById('startScanBtn').disabled = true;
            document.getElementById('startScanBtn').classList.add('scanning');
            document.getElementById('startScanBtn').textContent = 'Scanning Fase 2...';
            document.getElementById('stopScanBtn').disabled = false;
            document.getElementById('scanStatus').textContent = 'Scanning Fase 2 (Belakang)...';
            document.getElementById('pointCount').textContent = '0';
            document.getElementById('frameCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('progressFill').textContent = '0%';
            document.getElementById('currentPhase').textContent = 'Fase 2: Belakang';
            
            // Send PointCloud mode request
            socket.send("PointCloud");
            console.log('üì§ Sent PointCloud mode request for Phase 2');
        }
        
        /**
         * Merge point clouds from Phase 1 (depan) and Phase 2 (belakang)
         * Combines both point clouds into one complete 3D object
         */
        function mergePhasePointClouds() {
            console.log('üîó Merging point clouds from Phase 1 and Phase 2...');
            console.log('üìä Phase 1 (Depan): ' + pointCloudFront.length.toLocaleString() + ' points');
            console.log('üìä Phase 2 (Belakang): ' + pointCloudBack.length.toLocaleString() + ' points');
            
            if (pointCloudFront.length === 0 && pointCloudBack.length === 0) {
                console.warn('‚ö†Ô∏è No points to merge!');
                return;
            }
            
            // Combine both point clouds
            // For now, simple concatenation - can be improved with ICP alignment later
            pointCloud = [...pointCloudFront, ...pointCloudBack];
            
            console.log('‚úÖ Merged point cloud: ' + pointCloud.length.toLocaleString() + ' points total');
            
            // Update display
            updatePointCloudDisplay();
            centerModel();
            
            // Update UI
            document.getElementById('scanStatus').textContent = 
                'Scan selesai! ' + pointCloud.length.toLocaleString() + ' points (Depan: ' + 
                pointCloudFront.length.toLocaleString() + ', Belakang: ' + 
                pointCloudBack.length.toLocaleString() + ')';
            document.getElementById('pointCount').textContent = pointCloud.length.toLocaleString();
            document.getElementById('generateMeshBtn').disabled = false;
            document.getElementById('exportSTLBtn').disabled = false;
            document.getElementById('currentPhase').textContent = 'Selesai - Objek 3D Utuh';
        }
        
        function stopCapture() {
            console.log('üõë Stopping capture...');
            isCaptureActive = false;
            isScanning = false;

            // Clear timers
            if (autoCaptureTimer) {
                clearTimeout(autoCaptureTimer);
                autoCaptureTimer = null;
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop point cloud data');
            }

            // Handle multi-phase mode
            if (isMultiPhaseMode && scanPhase === 1) {
                // Phase 1 complete - save to pointCloudFront
                pointCloudFront = [...pointCloud];
                console.log('‚úÖ Phase 1 (Depan) complete: ' + pointCloudFront.length.toLocaleString() + ' points');
                
                // Update UI for Phase 2
                document.getElementById('startPhase2Btn').style.display = 'inline-block';
                document.getElementById('startPhase2Btn').disabled = false;
                document.getElementById('scanStatus').textContent = 
                    'Fase 1 selesai! Putar objek 180¬∞ lalu klik "Mulai Fase 2" (' + 
                    pointCloudFront.length.toLocaleString() + ' points)';
                document.getElementById('currentPhase').textContent = 'Fase 1 selesai - Menunggu Fase 2';
                
                // Reset UI buttons
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
                document.getElementById('stopScanBtn').disabled = true;
                
                return; // Don't enable mesh/export yet - wait for Phase 2
            } else if (isMultiPhaseMode && scanPhase === 2) {
                // Phase 2 complete - already merged in timeout handler
                document.getElementById('startScanBtn').disabled = false;
                document.getElementById('startScanBtn').classList.remove('scanning');
                document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
                document.getElementById('stopScanBtn').disabled = true;
                return;
            }

            // Normal mode or both phases complete
            // Update UI
            document.getElementById('scanStatus').textContent = pointCloud.length > 0 ?
                'Capture stopped - ' + pointCloud.length.toLocaleString() + ' points collected' :
                'Capture stopped - No data';

            // Enable buttons if we have points
            if (pointCloud.length > 0) {
                document.getElementById('generateMeshBtn').disabled = false;
                document.getElementById('exportSTLBtn').disabled = false; // Enable export even without mesh
                console.log('‚úÖ Capture stopped. Total: ' + pointCloud.length.toLocaleString() + ' points from ' + frameCount + ' frames');

                // Auto-center the point cloud
                centerModel();
            }
            
            // Reset UI buttons
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'Reset & Start Capture';
            document.getElementById('stopScanBtn').disabled = true;
        }

        function stopScan() {
            if (!isScanning) return; // Already stopped

            console.log('üõë Stopping scan...');
            isScanning = false;
            stopCapture();
            
            // Clear timer
            if (scanTimer) {
                clearInterval(scanTimer);
                scanTimer = null;
            }
            
            // Update UI
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('startScanBtn').classList.remove('scanning');
            document.getElementById('startScanBtn').textContent = 'Mulai Scan';
            document.getElementById('scanStatus').textContent = pointCloud.length > 0 ? 'Selesai - Siap untuk Generate Mesh' : 'Selesai - Tidak ada data';
            
            // Set progress to 100%
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '100%';
                progressFillEl.textContent = '100%';
            }
            
            // Log statistics
            console.log('üìä Scan Statistics:', {
                totalDataReceived: dataReceivedDuringScan,
                pointCloudDataReceived: pointCloudDataReceived,
                skeletonDataReceived: dataReceivedDuringScan - pointCloudDataReceived,
                pointsCollected: pointCloud.length,
                framesProcessed: frameCount
            });
            
            // Enable generate mesh button if we have points
            if (pointCloud.length > 0) {
                document.getElementById('generateMeshBtn').disabled = false;
                console.log('‚úÖ Scan completed with', pointCloud.length, 'points from', frameCount, 'frames');
            } else {
                console.warn('‚ö†Ô∏è Scan completed but no points collected');
                
                // Provide detailed error message based on what we received
                let errorMsg = 'Scanning selesai tapi tidak ada data yang terkumpul.\n\n';
                
                if (dataReceivedDuringScan === 0) {
                    errorMsg += '‚ùå MASALAH: Server TIDAK mengirim data sama sekali!\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Pastikan server.exe berjalan\n';
                    errorMsg += '2. Restart server.exe\n';
                    errorMsg += '3. Cek apakah Kinect terhubung dan terdeteksi\n';
                    errorMsg += '4. Tampilkan console server untuk lihat error:\n';
                    errorMsg += '   - Edit source/Program.cs line 26\n';
                    errorMsg += '   - Ganti CONSOLE_HIDE menjadi CONSOLE_SHOW\n';
                    errorMsg += '   - Recompile server\n';
                } else if (pointCloudDataReceived === 0) {
                    errorMsg += '‚ùå MASALAH: Server mengirim data tapi BUKAN point cloud!\n\n';
                    errorMsg += 'Server mengirim ' + (dataReceivedDuringScan - pointCloudDataReceived) + ' skeleton data.\n';
                    errorMsg += 'Server TIDAK switch ke PointCloud mode.\n\n';
                    errorMsg += 'Solusi:\n';
                    errorMsg += '1. Restart server.exe\n';
                    errorMsg += '2. Pastikan server support PointCloud mode\n';
                    errorMsg += '3. Cek console server untuk error\n';
                } else {
                    errorMsg += '‚ö†Ô∏è Server mengirim ' + pointCloudDataReceived + ' frame point cloud, tapi semua kosong.\n\n';
                    errorMsg += 'Pastikan:\n';
                    errorMsg += '- Objek berada dalam range 0.85-4 meter dari Kinect\n';
                    errorMsg += '- Objek cukup besar dan jelas\n';
                    errorMsg += '- Lighting cukup\n';
                    errorMsg += '- Objek tidak transparan atau reflektif\n';
                }
                
                alert(errorMsg);
            }
            
            // Switch back to Color mode to stop sending point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched back to Color mode');
            }
        }
        
        function generateMesh() {
            if (pointCloud.length === 0) {
                alert('Tidak ada point cloud untuk di-generate mesh! Silakan lakukan scanning terlebih dahulu.');
                return;
            }

            if (pointCloud.length < 3) {
                alert('Point cloud terlalu sedikit! Minimal 3 points diperlukan untuk membuat mesh.');
                return;
            }

            console.log('üîß Generating mesh from', pointCloud.length.toLocaleString(), 'points...');

            // CRITICAL: Stop receiving data during mesh generation to prevent connection errors
            const wasCaptureActive = isCaptureActive;
            isCaptureActive = false;
            
            // Switch to Color mode to stop point cloud data
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send("Color");
                console.log('üì§ Switched to Color mode to stop data during mesh generation');
            }

            // CRITICAL: Downsample if too many points (prevent freeze)
            let meshPoints = pointCloud;
            const maxMeshPoints = 100000; // Increased for better quality mesh

            if (pointCloud.length > maxMeshPoints) {
                console.log('‚ö†Ô∏è Too many points (' + pointCloud.length.toLocaleString() + ') - downsampling to ' + maxMeshPoints.toLocaleString());
                // Use uniform sampling instead of skip factor for better quality
                const step = pointCloud.length / maxMeshPoints;
                meshPoints = [];
                for (let i = 0; i < pointCloud.length; i += step) {
                    const idx = Math.floor(i);
                    if (idx < pointCloud.length) {
                        meshPoints.push(pointCloud[idx]);
                    }
                }
                console.log('‚úÖ Downsampled to ' + meshPoints.length.toLocaleString() + ' points using uniform sampling');

                // Don't show alert for better UX
            }

            // Apply aggressive background filter to mesh points
            console.log('üîç Filtering background from mesh points (aggressive mode)...');
            const beforeFilter = meshPoints.length;
            meshPoints = filterHumanBodyOnlyAggressive(meshPoints);
            console.log('‚úÖ Background filter: ' + beforeFilter + ' ‚Üí ' + meshPoints.length + ' points');
            
            if (meshPoints.length < 100) {
                console.warn('‚ö†Ô∏è Too few points after filtering, using less aggressive filter');
                // Re-apply with less aggressive filter
                meshPoints = filterHumanBodyOnly(meshPoints);
            }

            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('generateMeshBtn').textContent = 'Generating... (' + meshPoints.length.toLocaleString() + ' pts)';
            document.getElementById('scanStatus').textContent = 'Generating mesh from ' + meshPoints.length.toLocaleString() + ' points...';

            // Use Web Worker-like approach with chunked processing to prevent freeze
            const processMeshAsync = () => {
                try {
                    console.log('üîß Starting mesh creation (chunked async)...');
                    const startTime = Date.now();
                    
                    // Process mesh in chunks using requestIdleCallback or setTimeout
                    let progress = 0;
                    
                    const updateProgress = (p) => {
                        progress = p;
                        const progressPercent = Math.round(p * 100);
                        document.getElementById('scanStatus').textContent = 
                            'Generating mesh... ' + progressPercent + '%';
                    };
                    
                    // Use setTimeout to break up work
                    setTimeout(() => {
                        updateProgress(0.2);
                        
                        setTimeout(() => {
                            updateProgress(0.5);
                            
                            setTimeout(() => {
                                updateProgress(0.8);
                                
                                setTimeout(() => {
                                    try {
                                        updateProgress(0.9);
                                        
                                        // Create mesh (this is the heavy operation)
                                        mesh = createMeshFromPointCloud(meshPoints);
                                        
                                        updateProgress(1.0);
                                        
                                        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
                                        console.log('‚úÖ Mesh generation completed in ' + elapsedTime + ' seconds');

                                        const oldMesh = scene.getObjectByName('mesh');
                                        if (oldMesh) {
                                            scene.remove(oldMesh);
                                        }

                                        // Also hide point cloud when showing mesh
                                        const oldPointCloud = scene.getObjectByName('pointCloud');
                                        if (oldPointCloud) {
                                            oldPointCloud.visible = false;
                                        }

                                        if (mesh) {
                                            mesh.name = 'mesh';
                                            scene.add(mesh);
                                            console.log('‚úÖ Mesh added to scene successfully');

                                            // Apply current manual position
                                            mesh.position.set(
                                                window.objectPosition ? window.objectPosition.x : 0,
                                                window.objectPosition ? window.objectPosition.y : 0,
                                                window.objectPosition ? window.objectPosition.z : 0
                                            );

                                            // Force update matrix before centering
                                            mesh.updateMatrixWorld();
                                            
                                            // Auto-center the mesh with delay to ensure it's rendered
                                            setTimeout(() => {
                                                centerModel();
                                                // Center again after a short delay to ensure it's correct
                                                setTimeout(() => centerModel(), 200);
                                            }, 100);

                                            // Update UI
                                            document.getElementById('scanStatus').textContent = 'Mesh generated successfully in ' + elapsedTime + 's';
                                            document.getElementById('exportSTLBtn').disabled = false;

                                            alert('‚úÖ Mesh berhasil dibuat!\n\n' +
                                                  'Points: ' + meshPoints.length.toLocaleString() + '\n' +
                                                  'Time: ' + elapsedTime + ' seconds\n\n' +
                                                  'Background telah di-filter dari mesh.\n' +
                                                  'Objek telah diposisikan di tengah-atas kanvas.');
                                        } else {
                                            console.error('‚ùå Failed to generate mesh');
                                            document.getElementById('scanStatus').textContent = 'Failed to generate mesh';
                                            alert('Gagal membuat mesh. Coba sesuaikan Mesh Resolution atau scan ulang dengan lebih banyak points.');
                                        }

                                        document.getElementById('generateMeshBtn').disabled = false;
                                        document.getElementById('generateMeshBtn').textContent = 'Generate Mesh';
                                        
                                        // Restore capture state if it was active
                                        if (wasCaptureActive) {
                                            console.log('‚ö†Ô∏è Note: Capture was active before mesh generation');
                                        }
                                        
                                    } catch (error) {
                                        console.error('‚ùå Error in mesh creation:', error);
                                        throw error;
                                    }
                                }, 50);
                            }, 50);
                        }, 50);
                    }, 50);
                    
                } catch (error) {
                    console.error('‚ùå Error generating mesh:', error);
                    console.error('Stack trace:', error.stack);
                    alert('Error saat membuat mesh: ' + error.message + '\n\nCek console (F12) untuk detail.');
                    document.getElementById('generateMeshBtn').disabled = false;
                    document.getElementById('generateMeshBtn').textContent = 'Generate Mesh';
                    document.getElementById('scanStatus').textContent = 'Error generating mesh';
                }
            };

            // Use setTimeout to prevent UI blocking (give browser time to update UI first)
            setTimeout(processMeshAsync, 100);
        }

        function createMeshFromPointCloud(points) {
            if (points.length < 3) {
                alert('Tidak cukup points untuk membuat mesh!');
                return null;
            }
            
            console.log('üîß Creating mesh from', points.length, 'points with improved reconstruction...');
            
            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            // But limit points to prevent freeze
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            
            // Further limit points for mesh generation to prevent freeze
            let pointsForMesh = points;
            if (points.length > 20000) {
                console.log('‚ö†Ô∏è Too many points for mesh (' + points.length + '), downsampling to 20000');
                const skip = Math.ceil(points.length / 20000);
                pointsForMesh = [];
                for (let i = 0; i < points.length; i += skip) {
                    pointsForMesh.push(points[i]);
                }
            }
            
            const meshData = pointCloudProcessor.createImprovedMesh(pointsForMesh, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, using fallback');
                // Fallback: create simple mesh
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(points.length * 3);
                const colors = new Float32Array(points.length * 3);
                
                for (let i = 0; i < points.length; i++) {
                    positions[i * 3] = points[i].x;
                    positions[i * 3 + 1] = points[i].y;
                    positions[i * 3 + 2] = points[i].z;
                    
                    colors[i * 3] = (points[i].r || 128) / 255;
                    colors[i * 3 + 1] = (points[i].g || 128) / 255;
                    colors[i * 3 + 2] = (points[i].b || 128) / 255;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Simple sequential triangulation as fallback
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    flatShading: false // Smooth shading for better appearance
                });
                
                return new THREE.Mesh(geometry, material);
            }
            
            // Create geometry from improved mesh data
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            // Map original points to mesh vertices to preserve colors
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Find closest original point for color
                let closestIdx = 0;
                let minDist = Infinity;
                for (let j = 0; j < points.length; j++) {
                    const dist = Math.hypot(
                        points[j].x - v[0],
                        points[j].y - v[1],
                        points[j].z - v[2]
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        closestIdx = j;
                    }
                }
                
                colors[i * 3] = (points[closestIdx].r || 128) / 255;
                colors[i * 3 + 1] = (points[closestIdx].g || 128) / 255;
                colors[i * 3 + 2] = (points[closestIdx].b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices from faces
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            
            // Compute normals for smooth shading (this helps fix broken/rough surfaces)
            geometry.computeVertexNormals();
            
            // Compute normals for smooth shading
            geometry.computeVertexNormals();
            
            // Apply light smoothing to fix broken surfaces (without causing freeze)
            const positions = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const vertexCount = positions.count;
            
            // Create vertex neighbor map for smoothing
            const neighbors = new Array(vertexCount).fill(null).map(() => []);
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                if (!neighbors[i1].includes(i2)) neighbors[i1].push(i2);
                if (!neighbors[i1].includes(i3)) neighbors[i1].push(i3);
                if (!neighbors[i2].includes(i1)) neighbors[i2].push(i1);
                if (!neighbors[i2].includes(i3)) neighbors[i2].push(i3);
                if (!neighbors[i3].includes(i1)) neighbors[i3].push(i1);
                if (!neighbors[i3].includes(i2)) neighbors[i3].push(i2);
            }
            
            // Apply light Laplacian smoothing (only 1 iteration to prevent freeze)
            // But only smooth vertices that have enough neighbors (to preserve shape)
            const smoothingFactor = 0.15; // Light smoothing to preserve detail
            const newPositions = new Float32Array(positions.array.length);
            
            for (let i = 0; i < vertexCount; i++) {
                const x = positions.array[i * 3];
                const y = positions.array[i * 3 + 1];
                const z = positions.array[i * 3 + 2];
                
                // Only smooth if vertex has enough neighbors (at least 3)
                if (neighbors[i].length >= 3) {
                    // Average with neighbors
                    let avgX = 0, avgY = 0, avgZ = 0;
                    neighbors[i].forEach(nIdx => {
                        avgX += positions.array[nIdx * 3];
                        avgY += positions.array[nIdx * 3 + 1];
                        avgZ += positions.array[nIdx * 3 + 2];
                    });
                    avgX /= neighbors[i].length;
                    avgY /= neighbors[i].length;
                    avgZ /= neighbors[i].length;
                    
                    // Blend original with averaged position (preserve shape)
                    newPositions[i * 3] = x * (1 - smoothingFactor) + avgX * smoothingFactor;
                    newPositions[i * 3 + 1] = y * (1 - smoothingFactor) + avgY * smoothingFactor;
                    newPositions[i * 3 + 2] = z * (1 - smoothingFactor) + avgZ * smoothingFactor;
                } else {
                    // Keep original position for vertices with few neighbors (boundary/edge vertices)
                    newPositions[i * 3] = x;
                    newPositions[i * 3 + 1] = y;
                    newPositions[i * 3 + 2] = z;
                }
            }
            
            positions.array.set(newPositions);
            
            // Recompute normals after smoothing
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            
            // Repair mesh: remove duplicate faces and fix normals
            geometry = repairMeshGeometry(geometry);
            
            // Final pass: ensure mesh is watertight by checking for unpaired edges
            geometry = ensureWatertightMesh(geometry, positions, vertexCount);
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false // Smooth shading for better appearance
            });
            
            const finalVertexCount = meshData.vertices.length;
            console.log('‚úÖ Mesh created with', meshData.faces.length, 'faces,', finalVertexCount, 'vertices');
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Repair mesh: remove duplicate faces and ensure proper orientation
         */
        function repairMeshGeometry(geometry) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const positions = geometry.attributes.position.array;
            const faceSet = new Set();
            const newIndices = [];
            
            // Remove duplicate faces
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                // Create sorted key
                const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                
                if (!faceSet.has(triKey)) {
                    faceSet.add(triKey);
                    
                    // Use original orientation (assume it's correct)
                    newIndices.push(i1, i2, i3);
                }
            }
            
            // Update geometry with cleaned indices
            geometry.setIndex(newIndices);
            geometry.computeVertexNormals();
            
            console.log('‚úÖ Mesh repaired: removed', (indices.length - newIndices.length) / 3, 'duplicate faces');
            
            return geometry;
        }
        
        /**
         * Ensure mesh is watertight by filling remaining holes
         */
        function ensureWatertightMesh(geometry, positions, vertexCount) {
            if (!geometry.index) return geometry;
            
            const indices = geometry.index.array;
            const edgeMap = new Map();
            
            // Count edge occurrences
            for (let i = 0; i < indices.length; i += 3) {
                const i1 = indices[i];
                const i2 = indices[i + 1];
                const i3 = indices[i + 2];
                
                const edges = [
                    [i1, i2],
                    [i2, i3],
                    [i3, i1]
                ];
                
                edges.forEach(edge => {
                    const edgeKey = edge.sort((a, b) => a - b).join(',');
                    if (!edgeMap.has(edgeKey)) {
                        edgeMap.set(edgeKey, 0);
                    }
                    edgeMap.set(edgeKey, edgeMap.get(edgeKey) + 1);
                });
            }
            
            // Find boundary edges (appear only once)
            const boundaryEdges = [];
            edgeMap.forEach((count, edgeKey) => {
                if (count === 1) {
                    const [i1, i2] = edgeKey.split(',').map(Number);
                    boundaryEdges.push([i1, i2]);
                }
            });
            
            if (boundaryEdges.length === 0) {
                console.log('‚úÖ Mesh is watertight (no boundary edges)');
                return geometry;
            }
            
            console.log('üîß Found', boundaryEdges.length, 'boundary edges, attempting to close...');
            
            // Try to close small holes by finding nearby points
            const newIndices = Array.from(indices);
            const faceSet = new Set();
            
            // Rebuild face set
            for (let i = 0; i < indices.length; i += 3) {
                const tri = [indices[i], indices[i + 1], indices[i + 2]].sort((a, b) => a - b);
                faceSet.add(tri.join(','));
            }
            
            // Process boundary edges (limit for performance)
            let closed = 0;
            for (const [i1, i2] of boundaryEdges.slice(0, 1000)) { // Limit to 1000 for performance
                const p1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
                const p2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
                
                // Find closest point to form triangle
                let bestPoint = -1;
                let bestDist = Infinity;
                const edgeLength = p1.distanceTo(p2);
                
                for (let i = 0; i < vertexCount; i++) {
                    if (i === i1 || i === i2) continue;
                    
                    const p3 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const dist1 = p1.distanceTo(p3);
                    const dist2 = p2.distanceTo(p3);
                    
                    // Check if triangle is reasonable
                    if (dist1 < edgeLength * 2 && dist2 < edgeLength * 2) {
                        const avgDist = (dist1 + dist2) / 2;
                        if (avgDist < bestDist) {
                            bestDist = avgDist;
                            bestPoint = i;
                        }
                    }
                }
                
                // Create triangle if good candidate found
                if (bestPoint !== -1 && bestDist < edgeLength * 1.5) {
                    const tri = [i1, i2, bestPoint].sort((a, b) => a - b);
                    const faceKey = tri.join(',');
                    
                    if (!faceSet.has(faceKey)) {
                        faceSet.add(faceKey);
                        newIndices.push(tri[0], tri[1], tri[2]);
                        closed++;
                    }
                }
            }
            
            if (closed > 0) {
                geometry.setIndex(newIndices);
                geometry.computeVertexNormals();
                console.log('‚úÖ Closed', closed, 'holes in mesh');
            }
            
            return geometry;
        }
        
        function createTriangulation(points) {
            console.log('üîß Creating improved triangulation for ' + points.length.toLocaleString() + ' points...');

            // Use improved mesh generation from pointcloud processor
            // This creates better mesh with proper surface reconstruction
            const resolution = parseFloat(document.getElementById('meshResolutionSlider').value);
            const meshData = pointCloudProcessor.createImprovedMesh(points, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces from improved mesh, using fallback');
                // Fallback: simple sequential triangulation
                const indices = [];
                for (let i = 0; i < Math.min(points.length - 2, 10000); i += 3) {
                    if (i + 2 < points.length) {
                        indices.push(i, i + 1, i + 2);
                    }
                }
                return new Uint32Array(indices);
            }
            
            // Convert faces to indices array
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            console.log('‚úÖ Created ' + (indices.length / 3).toLocaleString() + ' triangles using improved mesh generation');
            
            return indices;
        }
        
        function exportSTL() {
            console.log('üíæ Exporting STL file...');

            let geometryToExport = null;
            let exportSource = '';

            // Check if we have mesh, otherwise create temporary mesh from point cloud
            if (mesh && mesh.geometry) {
                geometryToExport = mesh.geometry;
                exportSource = 'mesh';
                console.log('üì¶ Exporting from existing mesh');
            } else if (pointCloud.length > 0) {
                console.log('üì¶ No mesh found - creating temporary mesh from point cloud for export...');
                exportSource = 'pointcloud';

                // Create temporary simple mesh from point cloud
                const tempMesh = createSimpleMeshForExport(pointCloud);
                if (tempMesh && tempMesh.geometry) {
                    geometryToExport = tempMesh.geometry;
                    console.log('‚úÖ Temporary mesh created for export');
                } else {
                    // If mesh creation fails, try to export as point cloud directly
                    // Convert point cloud to simple STL format (point-based)
                    console.log('‚ö†Ô∏è Mesh creation failed, exporting point cloud as simple STL...');
                    try {
                        const stlString = convertPointCloudToSTL(pointCloud);
                        const blob = new Blob([stlString], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        a.download = 'kinect-scan-pointcloud-' + timestamp + '.stl';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log('‚úÖ Point cloud STL exported successfully:', a.download);
                        alert('File STL berhasil di-export dari point cloud: ' + a.download + '\n\nCatatan: File ini menggunakan triangulasi sederhana. Untuk hasil lebih baik, generate mesh terlebih dahulu.');
                        return;
                    } catch (error) {
                        alert('Gagal membuat mesh untuk export. Coba generate mesh terlebih dahulu atau pastikan ada cukup points.');
                        return;
                    }
                }
            } else {
                alert('Tidak ada data untuk di-export! Lakukan scanning terlebih dahulu.');
                return;
            }

            if (!geometryToExport) {
                alert('Gagal mengakses geometry untuk export.');
                return;
            }

            try {
                const stlString = convertToSTL(geometryToExport);
                const blob = new Blob([stlString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = 'kinect-scan-' + timestamp + '.stl';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('‚úÖ STL file exported successfully:', a.download);
                alert('File STL berhasil di-export: ' + a.download);
            } catch (error) {
                console.error('‚ùå Error exporting STL:', error);
                alert('Error saat mengekspor STL: ' + error.message);
            }
        }
        
        /**
         * Convert point cloud directly to STL format (fallback when mesh generation fails)
         * Creates simple triangles from nearby points
         */
        function convertPointCloudToSTL(points) {
            if (points.length < 3) {
                return 'solid kinect_scan\nendsolid kinect_scan\n';
            }
            
            console.log('üîß Converting point cloud to STL (simple triangulation)...');
            
            // Use simple spatial hashing for triangulation
            const maxDistance = 0.1; // 10cm max distance for connecting points
            const hashSize = 0.05; // 5cm grid cells
            const spatialHash = {};
            
            // Build spatial hash
            points.forEach((p, i) => {
                const hx = Math.floor(p.x / hashSize);
                const hy = Math.floor(p.y / hashSize);
                const hz = Math.floor(p.z / hashSize);
                const key = `${hx},${hy},${hz}`;
                if (!spatialHash[key]) spatialHash[key] = [];
                spatialHash[key].push(i);
            });
            
            const triangles = [];
            const processed = new Set();
            
            // Generate triangles from nearby points
            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const hx = Math.floor(p1.x / hashSize);
                const hy = Math.floor(p1.y / hashSize);
                const hz = Math.floor(p1.z / hashSize);
                
                // Check neighboring cells
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const key = `${hx+dx},${hy+dy},${hz+dz}`;
                            if (!spatialHash[key]) continue;
                            
                            spatialHash[key].forEach(j => {
                                if (j <= i) return;
                                const p2 = points[j];
                                const dist12 = Math.hypot(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                                if (dist12 > maxDistance) return;
                                
                                // Find third point
                                for (let dx2 = -1; dx2 <= 1; dx2++) {
                                    for (let dy2 = -1; dy2 <= 1; dy2++) {
                                        for (let dz2 = -1; dz2 <= 1; dz2++) {
                                            const key2 = `${hx+dx2},${hy+dy2},${hz+dz2}`;
                                            if (!spatialHash[key2]) continue;
                                            
                                            spatialHash[key2].forEach(k => {
                                                if (k === i || k === j) return;
                                                const p3 = points[k];
                                                const dist13 = Math.hypot(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                                                const dist23 = Math.hypot(p3.x - p2.x, p3.y - p2.y, p3.z - p2.z);
                                                
                                                if (dist13 <= maxDistance && dist23 <= maxDistance) {
                                                    const triKey = [i, j, k].sort().join(',');
                                                    if (!processed.has(triKey)) {
                                                        processed.add(triKey);
                                                        triangles.push([i, j, k]);
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // Convert to STL format
            let stl = 'solid kinect_scan\n';
            
            triangles.forEach(tri => {
                const p1 = points[tri[0]];
                const p2 = points[tri[1]];
                const p3 = points[tri[2]];
                
                // Calculate normal
                const v1 = new THREE.Vector3(p2.x - p1.x, p2.y - p1.y, p2.z - p1.z);
                const v2 = new THREE.Vector3(p3.x - p1.x, p3.y - p1.y, p3.z - p1.z);
                const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
                
                stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                stl += `    outer loop\n`;
                stl += `      vertex ${p1.x.toFixed(6)} ${p1.y.toFixed(6)} ${p1.z.toFixed(6)}\n`;
                stl += `      vertex ${p2.x.toFixed(6)} ${p2.y.toFixed(6)} ${p2.z.toFixed(6)}\n`;
                stl += `      vertex ${p3.x.toFixed(6)} ${p3.y.toFixed(6)} ${p3.z.toFixed(6)}\n`;
                stl += `    endloop\n`;
                stl += `  endfacet\n`;
            });
            
            stl += 'endsolid kinect_scan\n';
            console.log('‚úÖ Converted', triangles.length, 'triangles to STL');
            return stl;
        }
        
        /**
         * Convert Three.js geometry to STL format with validation
         * Ensures mesh is valid and properly formatted
         */
        function convertToSTL(geometry) {
            console.log('üîß Converting geometry to STL format...');
            
            // Validate and repair geometry before export
            geometry = validateAndRepairGeometry(geometry);
            
            let stl = 'solid kinect_scan\n';
            const positions = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;
            
            let validTriangles = 0;
            let invalidTriangles = 0;
            
            if (indices) {
                // Indexed geometry - more efficient
                const triangleSet = new Set(); // Track unique triangles
                
                for (let i = 0; i < indices.length; i += 3) {
                    const i1 = indices[i];
                    const i2 = indices[i + 1];
                    const i3 = indices[i + 2];
                    
                    // Validate indices
                    if (i1 === i2 || i2 === i3 || i1 === i3) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    // Check for duplicate triangles
                    const triKey = [i1, i2, i3].sort((a, b) => a - b).join(',');
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue; // Skip duplicate triangles
                    }
                    triangleSet.add(triKey);
                    
                    const idx1 = i1 * 3;
                    const idx2 = i2 * 3;
                    const idx3 = i3 * 3;
                    
                    // Validate array bounds
                    if (idx1 + 2 >= positions.length || idx2 + 2 >= positions.length || idx3 + 2 >= positions.length) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    const v1 = new THREE.Vector3(positions[idx1], positions[idx1 + 1], positions[idx1 + 2]);
                    const v2 = new THREE.Vector3(positions[idx2], positions[idx2 + 1], positions[idx2 + 2]);
                    const v3 = new THREE.Vector3(positions[idx3], positions[idx3 + 1], positions[idx3 + 2]);
                    
                    // Check for degenerate triangles (zero area)
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue; // Skip degenerate triangles
                    }
                    
                    normal.normalize();
                    
                    // Write triangle to STL
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            } else {
                // Non-indexed geometry
                const vertexCount = positions.length / 3;
                const triangleSet = new Set();
                
                for (let i = 0; i < vertexCount - 2; i += 3) {
                    const v1 = new THREE.Vector3(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                    const v2 = new THREE.Vector3(positions[(i + 1) * 3], positions[(i + 1) * 3 + 1], positions[(i + 1) * 3 + 2]);
                    const v3 = new THREE.Vector3(positions[(i + 2) * 3], positions[(i + 2) * 3 + 1], positions[(i + 2) * 3 + 2]);
                    
                    // Check for duplicate triangles
                    const triKey = `${i},${i+1},${i+2}`;
                    if (triangleSet.has(triKey)) {
                        invalidTriangles++;
                        continue;
                    }
                    triangleSet.add(triKey);
                    
                    // Check for degenerate triangles
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2);
                    const area = normal.length();
                    
                    if (area < 0.000001) {
                        invalidTriangles++;
                        continue;
                    }
                    
                    normal.normalize();
                    
                    stl += `  facet normal ${normal.x.toFixed(6)} ${normal.y.toFixed(6)} ${normal.z.toFixed(6)}\n`;
                    stl += `    outer loop\n`;
                    stl += `      vertex ${v1.x.toFixed(6)} ${v1.y.toFixed(6)} ${v1.z.toFixed(6)}\n`;
                    stl += `      vertex ${v2.x.toFixed(6)} ${v2.y.toFixed(6)} ${v2.z.toFixed(6)}\n`;
                    stl += `      vertex ${v3.x.toFixed(6)} ${v3.y.toFixed(6)} ${v3.z.toFixed(6)}\n`;
                    stl += `    endloop\n`;
                    stl += `  endfacet\n`;
                    validTriangles++;
                }
            }
            
            stl += 'endsolid kinect_scan\n';
            
            console.log('‚úÖ STL conversion complete:', validTriangles, 'valid triangles,', invalidTriangles, 'invalid triangles skipped');
            
            if (validTriangles === 0) {
                console.error('‚ùå No valid triangles in geometry!');
                return null;
            }
            
            return stl;
        }
        
        /**
         * Validate and repair geometry before STL export
         * Ensures mesh is watertight and properly formed
         */
        function validateAndRepairGeometry(geometry) {
            console.log('üîß Validating and repairing geometry...');
            
            if (!geometry.index) {
                console.log('‚ö†Ô∏è Geometry is not indexed, computing index...');
                // Try to merge vertices if BufferGeometryUtils is available
                if (typeof THREE.BufferGeometryUtils !== 'undefined') {
                    geometry = THREE.BufferGeometryUtils.mergeVertices(geometry, 0.001);
                }
                geometry.computeVertexNormals();
                return geometry;
            }
            
            // Remove duplicate vertices
            const positions = geometry.attributes.position.array;
            const indices = geometry.index.array;
            const vertexCount = positions.length / 3;
            
            // Recompute normals to ensure consistency
            geometry.computeVertexNormals();
            
            // Ensure bounding sphere is computed
            if (!geometry.boundingSphere) {
                geometry.computeBoundingSphere();
            }
            
            console.log('‚úÖ Geometry validated:', vertexCount, 'vertices,', indices.length / 3, 'triangles');
            
            return geometry;
        }
        
        function clearScan() {
            // Reset multi-phase data
            scanPhase = 0;
            pointCloudFront = [];
            pointCloudBack = [];
            isMultiPhaseMode = false;
            if (document.getElementById('enableMultiPhaseCheckbox')) {
                document.getElementById('enableMultiPhaseCheckbox').checked = false;
            }
            if (document.getElementById('phaseInfo')) {
                document.getElementById('phaseInfo').style.display = 'none';
            }
            if (document.getElementById('startPhase2Btn')) {
                document.getElementById('startPhase2Btn').style.display = 'none';
                document.getElementById('startPhase2Btn').disabled = true;
            }
            
            // Stop scanning if active
            if (isScanning) {
                stopScan();
            }
            
            pointCloud = [];
            pointCloudFrames = [];
            mesh = null;
            debugDataCount = 0;
            frameCount = 0;
            dataReceivedDuringScan = 0;
            pointCloudDataReceived = 0;
            kinectPosition = { x: 0, y: 0, z: 0 };
            
            if (scene) {
                const oldPointCloud = scene.getObjectByName('pointCloud');
                if (oldPointCloud) {
                    scene.remove(oldPointCloud);
                }
                
                const oldMesh = scene.getObjectByName('mesh');
                if (oldMesh) {
                    scene.remove(oldMesh);
                }
            }
            
            document.getElementById('generateMeshBtn').disabled = true;
            document.getElementById('exportSTLBtn').disabled = true;
            document.getElementById('scanStatus').textContent = 'Tidak aktif';
            const debugMsgEl = document.getElementById('debugMessage');
            const debugCountEl = document.getElementById('debugDataCount');
            if (debugMsgEl) debugMsgEl.textContent = '-';
            if (debugCountEl) debugCountEl.textContent = '0';
            
            // Reset progress bar
            const progressFillEl = document.getElementById('progressFill');
            if (progressFillEl) {
                progressFillEl.style.width = '0%';
                progressFillEl.textContent = '0%';
            }
            
            updateStats();
        }
        
        function updateStats() {
            const pointCountEl = document.getElementById('pointCount');
            const frameCountEl = document.getElementById('frameCount');
            const progressFillEl = document.getElementById('progressFill');
            
            // Update point count
            if (pointCountEl) pointCountEl.textContent = pointCloud.length.toLocaleString();
            
            // Update frame count (actual number of frames captured)
            if (frameCountEl) frameCountEl.textContent = frameCount.toLocaleString();
            
            // Update progress bar (based on point count, max 200k points = 100%)
            if (progressFillEl) {
                const maxPoints = maxTotalPoints; // Maximum expected points for a good scan
                const progress = Math.min(100, (pointCloud.length / maxPoints) * 100);
                progressFillEl.style.width = progress + '%';
                progressFillEl.textContent = Math.round(progress) + '%';
            }
        }
        
        /**
         * Calculate principal component analysis (PCA) to find main orientation
         * Returns rotation quaternion to align object upright
         */
        function calculateOrientationAlignment(points) {
            if (points.length < 3) return null;
            
            // Calculate bounding box to find longest dimension
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < points.length; i++) {
                minX = Math.min(minX, points[i].x);
                maxX = Math.max(maxX, points[i].x);
                minY = Math.min(minY, points[i].y);
                maxY = Math.max(maxY, points[i].y);
                minZ = Math.min(minZ, points[i].z);
                maxZ = Math.max(maxZ, points[i].z);
            }
            
            const sizeX = maxX - minX;
            const sizeY = maxY - minY;
            const sizeZ = maxZ - minZ;
            
            // Find longest dimension
            const maxSize = Math.max(sizeX, sizeY, sizeZ);
            
            // For human body, Y (height) should typically be longest
            // If it's not, rotate to make the longest dimension vertical
            const rotation = new THREE.Quaternion();
            
            // Only rotate if Y is not the longest (object is tilted)
            if (maxSize === sizeX && sizeX > sizeY * 1.2) {
                // Longest is X, rotate 90 degrees around Z to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI / 2);
                console.log('üîÑ Rotating: X-axis is longest, rotating 90¬∞ around Z');
            } else if (maxSize === sizeZ && sizeZ > sizeY * 1.2) {
                // Longest is Z, rotate 90 degrees around X to make it Y
                rotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
                console.log('üîÑ Rotating: Z-axis is longest, rotating 90¬∞ around X');
            }
            // If Y is already longest or close, no rotation needed
            
            return rotation;
        }
        
        /**
         * Apply rotation to align object upright (horizontal/tegak)
         */
        function alignObjectUpright(obj, points) {
            if (!obj || !points || points.length < 3) return;
            
            // Calculate orientation alignment
            const rotation = calculateOrientationAlignment(points);
            if (!rotation) return;
            
            // Check if rotation is needed (quaternion is not identity)
            if (rotation.x === 0 && rotation.y === 0 && rotation.z === 0 && rotation.w === 1) {
                return; // No rotation needed
            }
            
            // Apply rotation to object
            // Store original rotation if not already stored
            if (!obj.userData.originalRotation) {
                obj.userData.originalRotation = obj.quaternion.clone();
            }
            
            // Apply rotation
            obj.quaternion.copy(rotation);
            
            console.log('üîÑ Object rotated to upright orientation');
        }
        
        function centerModel() {
            if (!scene || !camera) return;
            
            // Get all objects that should be centered (point cloud or mesh)
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');
            
            const objectsToCenter = [];
            if (pointCloudObj && pointCloudObj.visible) objectsToCenter.push(pointCloudObj);
            if (meshObj && meshObj.visible) objectsToCenter.push(meshObj);
            
            if (objectsToCenter.length === 0) return;
            
            // Get points for orientation calculation
            let pointsForAlignment = [];
            if (pointCloudObj && pointCloud.length > 0) {
                pointsForAlignment = pointCloud;
            } else if (meshObj && meshObj.geometry) {
                // Extract points from mesh geometry
                const positions = meshObj.geometry.attributes.position;
                if (positions) {
                    for (let i = 0; i < positions.count; i++) {
                        pointsForAlignment.push({
                            x: positions.getX(i),
                            y: positions.getY(i),
                            z: positions.getZ(i)
                        });
                    }
                }
            }
            
            // DISABLED: Auto-rotation to preserve original landscape orientation
            // Uncomment below to enable auto-rotation if needed
            // if (pointsForAlignment.length > 0) {
            //     objectsToCenter.forEach(obj => {
            //         alignObjectUpright(obj, pointsForAlignment);
            //     });
            // }
            
            // Calculate bounding box of all objects
            const box = new THREE.Box3();
            objectsToCenter.forEach(obj => {
                obj.updateMatrixWorld();
                box.expandByObject(obj);
            });
            
            if (box.isEmpty()) return;
            
            // Calculate center and size
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            // Center all objects at origin (but preserve manual position offset)
            const offset = center.clone().negate();
            objectsToCenter.forEach(obj => {
                // Apply centering offset, then add manual position
                obj.position.set(
                    offset.x + (window.objectPosition ? window.objectPosition.x : 0),
                    offset.y + (window.objectPosition ? window.objectPosition.y : 0),
                    offset.z + (window.objectPosition ? window.objectPosition.z : 0)
                );
            });
            
            // Fit camera to view the object properly
            if (maxDim > 0) {
                // Get canvas dimensions
                const container = document.getElementById('viewer');
                const width = container ? container.clientWidth : 800;
                const height = container ? container.clientHeight : 600;
                
                // Calculate distance needed to fit object in view
                // Use FOV and object size to calculate optimal distance
                const fov = camera.fov * (Math.PI / 180); // Convert to radians
                const distance = Math.max(
                    maxDim / (2 * Math.tan(fov / 2)), // Fit width
                    maxDim / (2 * Math.tan(fov / 2) * (height / width)) // Fit height
                );
                
                // Add some padding (20% extra space around object)
                const distanceWithPadding = distance * 1.2;
                
                // Position camera to view the centered object
                // Place camera in front and slightly above to show object at center-upper part of canvas
                // For human body, we want to see it centered and slightly above (not below)
                const cameraY = size.y * 0.2; // Slight offset upward (20% of height)
                camera.position.set(0, cameraY, distanceWithPadding);
                camera.lookAt(0, cameraY * 0.5, 0); // Look at slightly above center
                camera.updateProjectionMatrix();
            }
            
            console.log('‚úÖ Model centered, aligned upright, and fitted to view. Size:', size, 'Center:', center);
        }
        
        /**
         * Create a simple mesh from point cloud for STL export
         * Uses improved triangulation to create a proper mesh
         */
        function createSimpleMeshForExport(points) {
            if (points.length < 3) {
                console.warn('Not enough points for mesh export');
                return null;
            }
            
            console.log('üîß Creating simple mesh for export from', points.length, 'points...');
            
            // Downsample if too many points for performance (use uniform sampling for better quality)
            let meshPoints = points;
            const maxPoints = 150000; // Increased limit for high-quality export
            
            if (points.length > maxPoints) {
                // Use uniform sampling instead of skip factor for better quality
                const step = points.length / maxPoints;
                meshPoints = [];
                for (let i = 0; i < points.length; i += step) {
                    const idx = Math.floor(i);
                    if (idx < points.length) {
                        meshPoints.push(points[idx]);
                    }
                }
                console.log('üìâ Downsampled to', meshPoints.length, 'points for export (uniform sampling)');
            }
            
            // Use improved mesh generation from pointcloud processor
            // Use finer resolution for better quality mesh
            const baseResolution = parseFloat(document.getElementById('meshResolutionSlider')?.value || 0.05);
            const resolution = Math.max(0.02, baseResolution * 0.8); // Finer resolution for export
            console.log('üîß Generating mesh with resolution:', resolution);
            
            const meshData = pointCloudProcessor.createImprovedMesh(meshPoints, resolution);
            
            if (meshData.faces.length === 0) {
                console.warn('‚ö†Ô∏è No faces generated, trying with coarser resolution...');
                // Try with coarser resolution
                const coarserMesh = pointCloudProcessor.createImprovedMesh(meshPoints, resolution * 2);
                if (coarserMesh.faces.length > 0) {
                    Object.assign(meshData, coarserMesh);
                    console.log('‚úÖ Generated mesh with coarser resolution');
                } else {
                    console.warn('‚ö†Ô∏è Still no faces, using fallback triangulation');
                    // Fallback: simple sequential triangulation (last resort)
                    const fallbackFaces = [];
                    for (let i = 0; i < Math.min(meshPoints.length - 2, 10000); i += 3) {
                        if (i + 2 < meshPoints.length) {
                            fallbackFaces.push([i, i + 1, i + 2]);
                        }
                    }
                    meshData.faces = fallbackFaces;
                }
            }
            
            console.log('‚úÖ Mesh data generated:', meshData.vertices.length, 'vertices,', meshData.faces.length, 'faces');
            
            // Create Three.js geometry
            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array(meshData.vertices.length * 3);
            const colors = new Float32Array(meshData.vertices.length * 3);
            
            for (let i = 0; i < meshData.vertices.length; i++) {
                const v = meshData.vertices[i];
                vertices[i * 3] = v[0];
                vertices[i * 3 + 1] = v[1];
                vertices[i * 3 + 2] = v[2];
                
                // Use original point colors if available
                const origPoint = meshPoints[i];
                colors[i * 3] = (origPoint.r || 128) / 255;
                colors[i * 3 + 1] = (origPoint.g || 128) / 255;
                colors[i * 3 + 2] = (origPoint.b || 128) / 255;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create indices
            const indices = new Uint32Array(meshData.faces.length * 3);
            for (let i = 0; i < meshData.faces.length; i++) {
                indices[i * 3] = meshData.faces[i][0];
                indices[i * 3 + 1] = meshData.faces[i][1];
                indices[i * 3 + 2] = meshData.faces[i][2];
            }
            
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                flatShading: false
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        /**
         * Filter point cloud to keep only human body, remove background
         * Uses simpler depth-based filtering - keeps points in typical human range
         * and removes outliers that are too far from the main cluster
         */
        function filterHumanBodyOnly(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m - Kinect optimal range for humans)
            const depthFiltered = points.filter(p => {
                // Z is typically the distance from Kinect (forward direction)
                // Use absolute value to handle negative Z
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                console.warn('‚ö†Ô∏è No points in human depth range, using all points');
                return points;
            }
            
            console.log('üìä After depth filter:', depthFiltered.length, 'points');
            
            // Step 2: Remove outliers using statistical filtering
            // Find the main cluster by removing points that are too far from the center
            
            // Calculate center of mass
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Calculate median distance (more robust than mean)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            
            // Keep points within 2x median distance (this keeps the main body, removes far background)
            const threshold = medianDist * 2.5; // More lenient threshold
            const filtered = depthFiltered.filter((p, i) => {
                return distances[i] <= threshold;
            });
            
            console.log('‚úÖ Human body filter:', points.length, '‚Üí', filtered.length, 'points (removed', (points.length - filtered.length), 'background points)');
            
            // If filter removed too many points (>70%), return depth-filtered only
            if (filtered.length < points.length * 0.3) {
                console.warn('‚ö†Ô∏è Filter too aggressive, using depth-filtered points only');
                return depthFiltered;
            }
            
            return filtered;
        }
        
        /**
         * Remove duplicate/overlapping points to prevent layering
         * Uses voxel-based approach for better deduplication
         * This ensures each voxel (3D cell) contains only one point
         */
        function removeDuplicatePoints(newPoints, existingPoints) {
            if (newPoints.length === 0) return newPoints;
            
            console.log('üîç Removing duplicate points using voxel-based deduplication...');
            
            // Use voxel-based approach: each voxel can only contain one point
            // This is more effective than distance-based for preventing layering
            const voxelSize = 0.02; // 2cm voxels - smaller for better precision
            const voxelMap = new Map();
            
            // Build voxel map from existing points
            existingPoints.forEach((p, idx) => {
                const vx = Math.floor(p.x / voxelSize);
                const vy = Math.floor(p.y / voxelSize);
                const vz = Math.floor(p.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Store only one point per voxel (the first one)
                if (!voxelMap.has(voxelKey)) {
                    voxelMap.set(voxelKey, p);
                }
            });
            
            // Filter new points: keep only if voxel is empty
            const filtered = [];
            const newVoxelMap = new Map();
            
            for (const point of newPoints) {
                const vx = Math.floor(point.x / voxelSize);
                const vy = Math.floor(point.y / voxelSize);
                const vz = Math.floor(point.z / voxelSize);
                const voxelKey = `${vx},${vy},${vz}`;
                
                // Check if voxel is already occupied
                const existingInVoxel = voxelMap.get(voxelKey);
                const newInVoxel = newVoxelMap.get(voxelKey);
                
                if (!existingInVoxel && !newInVoxel) {
                    // Voxel is empty, add point
                    filtered.push(point);
                    newVoxelMap.set(voxelKey, point);
                } else {
                    // Voxel is occupied, check if this point is better (closer to voxel center)
                    const voxelCenterX = (vx + 0.5) * voxelSize;
                    const voxelCenterY = (vy + 0.5) * voxelSize;
                    const voxelCenterZ = (vz + 0.5) * voxelSize;
                    
                    const pointDist = Math.hypot(
                        point.x - voxelCenterX,
                        point.y - voxelCenterY,
                        point.z - voxelCenterZ
                    );
                    
                    // Replace if this point is closer to voxel center
                    if (existingInVoxel) {
                        const existingDist = Math.hypot(
                            existingInVoxel.x - voxelCenterX,
                            existingInVoxel.y - voxelCenterY,
                            existingInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < existingDist) {
                            // Replace existing point in voxel
                            voxelMap.set(voxelKey, point);
                            // Note: we can't remove from existingPoints array, but this prevents future duplicates
                        }
                    } else if (newInVoxel) {
                        const newDist = Math.hypot(
                            newInVoxel.x - voxelCenterX,
                            newInVoxel.y - voxelCenterY,
                            newInVoxel.z - voxelCenterZ
                        );
                        
                        if (pointDist < newDist) {
                            // Replace in new points
                            const idx = filtered.indexOf(newInVoxel);
                            if (idx !== -1) {
                                filtered[idx] = point;
                                newVoxelMap.set(voxelKey, point);
                            }
                        }
                    }
                }
            }
            
            console.log('‚úÖ Voxel deduplication: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points (removed ' + (newPoints.length - filtered.length) + ' duplicates)');
            
            return filtered;
        }
        
        /**
         * Alternative: Temporal filtering to reduce layering
         * Only keeps points that are stable across frames
         */
        function applyTemporalFiltering(newPoints, pointCloudFrames) {
            if (pointCloudFrames.length < 2) return newPoints;
            
            console.log('üîç Applying temporal filtering to reduce noise...');
            
            // Build spatial hash for recent frames
            const cellSize = 0.03; // 3cm cells
            const frameGrids = [];
            
            // Get last 3 frames for temporal consistency
            const recentFrames = pointCloudFrames.slice(-3);
            
            recentFrames.forEach(frame => {
                const grid = new Map();
                frame.forEach((p, idx) => {
                    const gx = Math.floor(p.x / cellSize);
                    const gy = Math.floor(p.y / cellSize);
                    const gz = Math.floor(p.z / cellSize);
                    const key = `${gx},${gy},${gz}`;
                    
                    if (!grid.has(key)) {
                        grid.set(key, []);
                    }
                    grid.get(key).push(p);
                });
                frameGrids.push(grid);
            });
            
            // Keep points that appear in multiple frames (more stable)
            const filtered = newPoints.filter(point => {
                const gx = Math.floor(point.x / cellSize);
                const gy = Math.floor(point.y / cellSize);
                const gz = Math.floor(point.z / cellSize);
                
                let matchCount = 0;
                
                frameGrids.forEach(grid => {
                    // Check neighboring cells
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const key = `${gx + dx},${gy + dy},${gz + dz}`;
                                const cellPoints = grid.get(key) || [];
                                
                                for (const otherPoint of cellPoints) {
                                    const dist = Math.hypot(
                                        point.x - otherPoint.x,
                                        point.y - otherPoint.y,
                                        point.z - otherPoint.z
                                    );
                                    
                                    if (dist < cellSize) {
                                        matchCount++;
                                        return; // Found match in this frame
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Keep if appears in at least 1 other frame (temporal consistency)
                return matchCount >= 1;
            });
            
            console.log('‚úÖ Temporal filter: ' + newPoints.length + ' ‚Üí ' + filtered.length + ' points');
            
            return filtered;
        }
        
        /**
         * Aggressive filter for mesh generation - removes background more aggressively
         * Uses tighter clustering to ensure only human body remains
         */
        function filterHumanBodyOnlyAggressive(points) {
            if (points.length === 0) return points;
            
            console.log('üîç Aggressive filtering human body from', points.length, 'points...');
            
            // Step 1: Filter by depth range (0.85m to 4m)
            const depthFiltered = points.filter(p => {
                const dist = Math.abs(p.z);
                return dist >= 0.85 && dist <= 4.0;
            });
            
            if (depthFiltered.length === 0) {
                return points;
            }
            
            // Step 2: Find the main cluster using tighter threshold
            let centerX = 0, centerY = 0, centerZ = 0;
            depthFiltered.forEach(p => {
                centerX += p.x;
                centerY += p.y;
                centerZ += p.z;
            });
            centerX /= depthFiltered.length;
            centerY /= depthFiltered.length;
            centerZ /= depthFiltered.length;
            
            // Calculate distances from center
            const distances = depthFiltered.map(p => {
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dz = p.z - centerZ;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            });
            
            // Use tighter threshold for aggressive filtering (1.8x instead of 2.5x)
            const sortedDistances = [...distances].sort((a, b) => a - b);
            const medianDist = sortedDistances[Math.floor(sortedDistances.length / 2)];
            const threshold = medianDist * 1.8; // Tighter threshold for mesh
            
            // Also filter by Y position - human body is typically in middle-upper Y range
            // Remove points that are too low (likely floor) or too high (likely ceiling)
            const yValues = depthFiltered.map(p => p.y);
            const sortedY = [...yValues].sort((a, b) => a - b);
            const minY = sortedY[Math.floor(sortedY.length * 0.1)]; // 10th percentile
            const maxY = sortedY[Math.floor(sortedY.length * 0.9)]; // 90th percentile
            
            const filtered = depthFiltered.filter((p, i) => {
                // Check distance from center
                if (distances[i] > threshold) return false;
                // Check Y position (remove floor and ceiling)
                if (p.y < minY || p.y > maxY) return false;
                return true;
            });
            
            console.log('‚úÖ Aggressive filter:', points.length, '‚Üí', filtered.length, 'points');
            
            return filtered;
        }

        // Object position control variables - MUST be global
        window.objectPosition = { x: 0, y: 0, z: 0 };
        
        /**
         * Update object position in the scene
         * Applies position to both point cloud and mesh
         */
        window.updateObjectPosition = function() {
            if (!scene) {
                console.warn('Scene not initialized, cannot update position');
                return;
            }
            
            console.log('üìç Updating object position to:', window.objectPosition);
            
            const pointCloudObj = scene.getObjectByName('pointCloud');
            const meshObj = scene.getObjectByName('mesh');
            
            let updated = false;
            
            // Apply position to point cloud
            if (pointCloudObj) {
                pointCloudObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated point cloud position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Point cloud not found in scene');
            }
            
            // Apply position to mesh
            if (meshObj) {
                meshObj.position.set(window.objectPosition.x, window.objectPosition.y, window.objectPosition.z);
                console.log('‚úÖ Updated mesh position to:', window.objectPosition);
                updated = true;
            } else {
                console.log('‚ÑπÔ∏è Mesh not found in scene');
            }
            
            if (!updated) {
                console.warn('‚ö†Ô∏è No object found to update position (point cloud or mesh). Make sure you have scanned or generated mesh first.');
            }
            
            // Update display
            const posDisplay = document.getElementById('currentPosition');
            if (posDisplay) {
                posDisplay.textContent = `X: ${window.objectPosition.x.toFixed(2)}, Y: ${window.objectPosition.y.toFixed(2)}, Z: ${window.objectPosition.z.toFixed(2)}`;
            }
        };
        
        /**
         * Adjust position by increment
         */
        window.adjustPosition = function(axis, increment) {
            console.log(`üîß Adjusting position ${axis} by ${increment}`);
            window.objectPosition[axis] += increment;
            window.objectPosition[axis] = Math.max(-5, Math.min(5, window.objectPosition[axis])); // Clamp to -5 to 5
            
            // Update sliders and input fields
            const axisUpper = axis.toUpperCase();
            const slider = document.getElementById(`position${axisUpper}Slider`);
            const input = document.getElementById(`position${axisUpper}Value`);
            if (slider) {
                slider.value = window.objectPosition[axis];
                console.log(`Updated slider ${axis} to ${window.objectPosition[axis]}`);
            }
            if (input) {
                input.value = window.objectPosition[axis].toFixed(1);
                console.log(`Updated input ${axis} to ${window.objectPosition[axis]}`);
            }
            
            window.updateObjectPosition();
        };
        
        /**
         * Update position X
         */
        window.updatePositionX = function(value) {
            console.log('üîß Updating position X to:', value);
            window.objectPosition.x = parseFloat(value) || 0;
            window.objectPosition.x = Math.max(-5, Math.min(5, window.objectPosition.x));
            const slider = document.getElementById('positionXSlider');
            if (slider) {
                slider.value = window.objectPosition.x;
                console.log('Updated X slider to:', window.objectPosition.x);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Y
         */
        window.updatePositionY = function(value) {
            console.log('üîß Updating position Y to:', value);
            window.objectPosition.y = parseFloat(value) || 0;
            window.objectPosition.y = Math.max(-5, Math.min(5, window.objectPosition.y));
            const slider = document.getElementById('positionYSlider');
            if (slider) {
                slider.value = window.objectPosition.y;
                console.log('Updated Y slider to:', window.objectPosition.y);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Update position Z
         */
        window.updatePositionZ = function(value) {
            console.log('üîß Updating position Z to:', value);
            window.objectPosition.z = parseFloat(value) || 0;
            window.objectPosition.z = Math.max(-5, Math.min(5, window.objectPosition.z));
            const slider = document.getElementById('positionZSlider');
            if (slider) {
                slider.value = window.objectPosition.z;
                console.log('Updated Z slider to:', window.objectPosition.z);
            }
            window.updateObjectPosition();
        };
        
        /**
         * Reset object position to center
         */
        window.resetObjectPosition = function() {
            console.log('üîÑ Resetting object position to center');
            window.objectPosition = { x: 0, y: 0, z: 0 };
            
            // Update all sliders and inputs
            ['X', 'Y', 'Z'].forEach(axis => {
                const slider = document.getElementById(`position${axis}Slider`);
                const input = document.getElementById(`position${axis}Value`);
                if (slider) slider.value = 0;
                if (input) input.value = '0.0';
            });
            
            window.updateObjectPosition();
            centerModel(); // Also recenter the view
        };
        
        // Settings sliders
        document.addEventListener('DOMContentLoaded', function() {
            const maxPointsSlider = document.getElementById('maxPointsSlider');
            const meshResolutionSlider = document.getElementById('meshResolutionSlider');
            
            if (maxPointsSlider) {
                maxPointsSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('maxPointsValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            if (meshResolutionSlider) {
                meshResolutionSlider.addEventListener('input', (e) => {
                    const valueEl = document.getElementById('meshResolutionValue');
                    if (valueEl) valueEl.textContent = e.target.value;
                });
            }
            
            // Position control sliders - CRITICAL: Must be set up here
            const positionXSlider = document.getElementById('positionXSlider');
            const positionYSlider = document.getElementById('positionYSlider');
            const positionZSlider = document.getElementById('positionZSlider');
            
            if (positionXSlider) {
                positionXSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.x = value;
                    const input = document.getElementById('positionXValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position X slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position X slider not found');
            }
            
            if (positionYSlider) {
                positionYSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.y = value;
                    const input = document.getElementById('positionYValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Y slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Y slider not found');
            }
            
            if (positionZSlider) {
                positionZSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    window.objectPosition.z = value;
                    const input = document.getElementById('positionZValue');
                    if (input) input.value = value.toFixed(1);
                    window.updateObjectPosition();
                });
                console.log('‚úÖ Position Z slider event listener attached');
            } else {
                console.warn('‚ö†Ô∏è Position Z slider not found');
            }
        });

        // Auto-connect on page load
        window.addEventListener('load', function() {
            console.log('üîµ Page loaded, auto-connecting...');
            connect();
        });

        // Periodic state check for debugging
        setInterval(() => {
            if (currentMode === 'scanning') {
                const scanBtn = document.getElementById('startScanBtn');
                const hasScanningClass = scanBtn ? scanBtn.classList.contains('scanning') : false;
                if (hasScanningClass && !isScanning) {
                    console.warn('‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INCONSISTENT STATE DETECTED!');
                    console.warn('Button says "Scanning..." but isScanning = false');
                    console.warn('Forcing isScanning = true...');
                    isScanning = true;
                    window.isScanning = true;
                }
            }
        }, 1000); // Check every second

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            disconnect();
        });
    </script>
</body>
</html>


