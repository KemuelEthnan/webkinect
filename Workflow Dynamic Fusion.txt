Di bawah ini saya susun checklist lengkap, apa saja yang harus Anda persiapkan, dan apa saja yang harus Anda lakukan pada setiap bagian sistem.
Struktur ini dibuat praktis, realistis, dan langsung bisa dikerjakan, menyesuaikan proyek Anda sekarang (Kinect → Server → index.html).

PERSIAPAN BESAR (SEBELUM MULAI)
1. Perangkat Keras

✔ Kinect v1
✔ Kinect v1 power adapter
✔ PC Windows (disarankan GPU Nvidia karena DynamicFusion/InfiniTAM butuh CUDA)
✔ USB 2.0 port

2. Perangkat Lunak

✔ Windows 10/11
✔ Visual Studio 2019 atau 2022
✔ Kinect SDK v1.8
✔ CUDA Toolkit (versi sesuai GPU Anda, misalnya 11.x)
✔ CMake (jika menggunakan InfiniTAM atau repo C++ lain)
✔ Git
✔ Node.js (untuk testing web jika perlu)

3. Pengetahuan Minimal yang Perlu Dikuasai

✔ C++ dasar
✔ Cara build project C++ di Windows
✔ WebSocket dasar
✔ Three.js untuk load mesh

=====================================================
BAGIAN 1 — DynamicFusion Engine (C++)
=====================================================
A. Apa yang harus Anda persiapkan

Install Kinect SDK v1.8 (wajib, untuk driver & API)

Install CUDA Toolkit

Clone repo DynamicFusion:

git clone https://github.com/mihaibujanca/dynamicfusion


Install OpenCV (jika repo membutuhkan)

Visual Studio 2019/2022

B. Apa yang harus Anda lakukan
1. Build DynamicFusion dari source

Buka VS Solution

Set CUDA path

Set Kinect SDK include & lib path

Build (Release x64)

Hasil:
✔ Anda mendapatkan program DynamicFusion yang bisa membaca depth dan menghasilkan model 3D.

2. Modifikasi Input: Dari file menjadi Kinect v1 streaming

Repo DynamicFusion default memakai file .oni.
Anda perlu membuat class baru:

class KinectInput {
public:
    void init();
    bool update(cv::Mat& depth, cv::Mat& color);
};


Di tiap loop:

kinect.update(depth, color);
df.processFrame(depth, color);

3. Menambahkan Mesh Extraction

DynamicFusion sudah memiliki mesh extraction TSDF (Marching Cubes).
Anda harus pastikan fungsi seperti:

mesh = df.extractMesh();


Menghasilkan:

vertex array

face array

=====================================================
BAGIAN 2 — WebSocket Mesh Server (C++ atau C#)
=====================================================
A. Apa yang harus Anda persiapkan

Anda perlu memilih salah satu:

✔ C++ WebSocket (µWebSockets atau WebSocket++), atau
✔ C# WebSocket (lebih mudah, bisa pakai Fleck)

Karena proyek Anda sudah ada server C#, lebih aman pakai C# Fleck.

B. Apa yang harus Anda lakukan
1. Buat server WebSocket sederhana

Contoh C#:

var server = new WebSocketServer("ws://0.0.0.0:9090");

server.Start(socket => {
   socket.OnOpen = () => Console.WriteLine("Client connected");
   socket.OnClose = () => Console.WriteLine("Client disconnected");
});

2. Kirimkan mesh dari C++ ke C#

Cara yang stabil:

C++ → Simpan mesh ke file ply sementara
C# → Baca file ply → Kirim binary ke browser

Atau lebih cepat:
C++ → kirim byte array mesh langsung via NamedPipe → C# WebSocket → Browser

3. Browser menerima mesh

index.html:

socket.onmessage = (e) => {
   const blob = new Blob([e.data], { type: "application/octet-stream" });
   loadMesh(blob);
};

=====================================================
BAGIAN 3 — Three.js Frontend (index.html)
=====================================================
A. Apa yang harus Anda persiapkan

PLYLoader atau OBJLoader Three.js

Canvas 3D (sudah ada di proyek Anda)

WebSocket client JS

B. Apa yang harus Anda lakukan
1. Buat koneksi WebSocket
let socket = new WebSocket("ws://localhost:9090");

2. Load mesh setiap kali server mengirim file
function loadMesh(blob) {
    const url = URL.createObjectURL(blob);
    const loader = new THREE.PLYLoader();

    loader.load(url, geometry => {
        if (currentMesh) {
            currentMesh.geometry.dispose();
            scene.remove(currentMesh);
        }
        let material = new THREE.MeshStandardMaterial({ color: 0xffffff });
        currentMesh = new THREE.Mesh(geometry, material);
        scene.add(currentMesh);
    });
}

3. Render ulang scene

Loop render Anda tidak berubah.

=====================================================
BAGIAN 4 — Integrasi Real-time Scan
=====================================================
A. Persiapan

Anda harus pastikan:

✔ Kinect tidak banyak noise
✔ Cahaya stabil
✔ User berdiri tidak terlalu dekat

B. Langkah Integrasi
1. Loop utama DynamicFusion
while (true) {
    kinect.update(depth, color);
    df.processFrame(depth, color);

    if (frameIndex % 20 == 0) {
       mesh = df.extractMesh();
       sendMeshToServer(mesh);
    }

    frameIndex++;
}

2. Dalam C#: kirim mesh ke browser

C# code:

byte[] meshBytes = File.ReadAllBytes(meshPath);
socket.Send(meshBytes);

3. Browser memperbarui mesh 3D

Real-time perubahan akan terlihat setiap 0.4–0.5 detik.

=====================================================
BAGIAN 5 — TUNING AGAR HASIL SCAN MIRIP SKANECT
=====================================================
A. Pengaturan penting DynamicFusion

TSDF truncation

Voxel size → atur antara 0.005 – 0.008 m

Max integration weight

Depth cutoff → 0.5 – 3 meter

B. Pengaturan Kamera Kinect

Room lighting cukup

Background tidak terlalu berwarna

User berputar 360° perlahan (6–10 detik)

=====================================================
BAGIAN 6 — CHECKLIST SINGKAT PER BAGIAN
=====================================================
Bagian DynamicFusion / C++ Engine

✔ Install Kinect SDK
✔ Install CUDA
✔ Build DynamicFusion
✔ Ganti input ke Kinect v1
✔ Implementasikan mesh extraction
✔ Implementasikan loop real-time

Bagian WebSocket Server

✔ Pilih C# atau C++
✔ Buat server WebSocket
✔ C++ kirim mesh ke server
✔ Server broadcast mesh ke browser

Bagian Frontend Three.js

✔ Implement websocket client
✔ PLYLoader / OBJLoader
✔ Update scene secara real-time
✔ Render loop tetap berjalan

Bagian Integrasi

✔ Meshing tiap 0.4–0.6 detik
✔ Sinkronisasi mesh → browser
✔ Tuning kualitas visual

=====================================================
Jika Anda mau, saya bisa lanjut dengan:
✔ Membuatkan template project lengkap:

C++ DynamicFusion Engine

C# WebSocket Server

JS mesh updater

index.html Three.js

✔ Membuatkan seluruh kode C++ yang lengkap (class by class)
✔ Membuatkan seluruh C# WebSocket server yang kompatibel
✔ Membuatkan seluruh kode Three.js loader & updater